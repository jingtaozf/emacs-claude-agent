#+TITLE: SDD Workflow Container
#+PROPERTY: TAG sdd
#+PROPERTY: TYPE tag

* Summary
:PROPERTIES:
:CUSTOM_ID: tags-sdd-summary
:END:

| Property | Value |
|----------+-------|
| Tag | =:sdd:= |
| Purpose | Structured workflow: Research → Design → Planning → Implementation |
| Output | Update sibling sections (Research Output, Spec, Features) |

SDD sections: Workflow, Research Output (=:research_output:=), Spec (=:spec:=), Features (=:features:=).

Full instructions: [[file:docs/prompts/tags/sdd.org::*Details][Read Details]]

** CRITICAL: Use CUSTOM_ID Links

*NEVER search by heading text* - there may be multiple sections with same name.

When updating SDD sections, extract the CUSTOM_ID from the link below and search for it:

#+begin_example
;; WRONG - finds first match, may be wrong section!
(re-search-forward "Research Output :research_output:" nil t)

;; CORRECT - use the CUSTOM_ID from the link
(re-search-forward ":CUSTOM_ID: claude-agent-dev-research-output-sdd-YYYYMMDD-HHMMSS" nil t)
#+end_example

* Details
:PROPERTIES:
:CUSTOM_ID: tags-sdd-details
:END:

You are working within a Spec-Driven Development (SDD) workflow. This is a structured
approach following the Atomic pattern: Research → Design → Planning → Implementation.

** SDD Structure

The current SDD has these sibling sections:

| Section | Tag | Purpose |
|---------+-----+---------|
| *Workflow* | =:sdd:= | AI interaction phases (you are here) |
| *Research Output* | =:research_output:= | Synthesized findings from exploration |
| *Spec* | =:spec:= | Living RFC document (Goals, Non-Goals, Solution) |
| *Features* | =:features:= | Atomic TODO items to implement |

** Finding Current Progress

Before starting work, understand where things stand:

1. *Check Features section*: Look for TODO/DONE states
   - Find the first incomplete TODO - that's the current focus
   - Review completed items for context

2. *Read Spec section*: Understand the technical design
   - Goals and Non-Goals define scope
   - Proposed Solution describes the approach
   - Technical Design has implementation details

3. *Review Research Output*: Access collected knowledge
   - Codebase Patterns: Existing patterns to follow
   - Relevant Files: Key files with file:line references
   - External References: Documentation and resources

** Updating Sibling Sections

As you work, update the appropriate sibling sections using MCP org tools:

*** Research Output Section

When you discover important information during exploration:

#+begin_example
Use: org_update_section
file_path: <current org file>
section_path: /<Feature Name>/Research Output/Codebase Patterns
new_content: |
  - Pattern: Repository pattern in =src/db/repos/=
  - Pattern: Factory functions in =src/utils/factories.py=
#+end_example

Update subsections:
- *Codebase Patterns*: Design patterns, coding conventions found
- *Relevant Files*: Key files with line references (=file.py:42=)
- *External References*: Links to docs, articles, related PRs

*** Spec Section

When design decisions are made:

#+begin_example
Use: org_update_section
file_path: <current org file>
section_path: /<Feature Name>/Spec/Proposed Solution
new_content: |
  Implement authentication using JWT tokens:
  1. Create AuthService class
  2. Add middleware for token validation
  3. Store refresh tokens in Redis
#+end_example

Update subsections:
- *Goals*: What we're trying to achieve
- *Non-Goals*: Explicit scope boundaries
- *Proposed Solution*: High-level approach
- *Technical Design*: Implementation details

*** Features Section

When breaking down work into atomic tasks:

#+begin_example
Use: org_update_section
file_path: <current org file>
section_path: /<Feature Name>/Features
new_content: |
  :PROPERTIES:
  :ORDERED: t
  :END:

  *** TODO Create AuthService class
  *** TODO Add JWT validation middleware
  *** TODO Implement refresh token logic
  *** TODO Write integration tests
#+end_example

** Workflow Phases

Each AI block can be tagged with a phase for focused behavior:

| Phase | Tag | Purpose | Output |
|-------+-----+---------+--------|
| Research | =:research:= | Explore codebase | → Research Output section |
| Design | =:design:= | Technical RFC | → Spec section |
| Planning | =:planning:= | Task breakdown | → Features section (TODOs) |
| Implementation | =:implementation:= | Write code | → Mark TODOs as DONE |

Select phase tags when inserting new AI blocks via =C-c C-/= → =n=.

** Key Principles

1. *Dual Memory*: Spec = lasting memory, Workflow = active memory
2. *Human Checkpoints*: Get approval at Research→Design and Planning→Implementation
3. *Atomic Features*: Each TODO should be completable in one session
4. *40-60 Rule*: Aim for 40-60% completion, humans refine the rest
5. *Update as you go*: Keep Research Output, Spec, Features current

** Navigating SDD Sections (CRITICAL)

SDD sections are linked via =CUSTOM_ID= properties for stable navigation.

*** Using the Section Links

The "SDD Section Links" section below contains org links in format:
=[[file:path.org::#custom-id][Section Name]]=

*ALWAYS* use these CUSTOM_ID-based links to navigate. Do NOT use heading-based
links like =[[file:path::*Heading]]= as they are ambiguous when multiple SDDs exist.

*** If a Link Fails to Resolve

If =org_read_section= or navigation fails for a linked section:

1. *STOP* - Do not guess or use a different section
2. *WARN the user*: "Cannot find section with CUSTOM_ID: <id>"
3. *Ask for guidance*: The section may need its CUSTOM_ID property restored

*** Finding Sections by CUSTOM_ID

When reading/updating sections, prefer CUSTOM_ID over section_path:

#+begin_example
# Preferred: Use CUSTOM_ID from the link
org_read_section(file_path, custom_id="claude-agent-dev-research-output-sdd-20251229-145304")

# Fallback only if CUSTOM_ID approach unavailable
org_read_section(file_path, section_path="/Feature Name/Research Output")
#+end_example

*Why*: Multiple SDDs in the same file may have identically-named sections.
CUSTOM_ID guarantees you update the correct section for THIS workflow.

** Session Handoff

When context is running low or session ends, create a handoff summary:

*** Required Sections

| Section | Content |
|---------+---------|
| *Primary Request* | What the user explicitly asked for |
| *Key Files* | Files modified with =file:line= references |
| *Pending Tasks* | Checkbox list of remaining work |
| *Anti-Context* | Rejected approaches (what NOT to do) |
| *Next Step* | Single concrete next action |

*** Handoff Template

#+begin_example
,* Session Handoff
:PROPERTIES:
:DATE: [timestamp]
:GIT_COMMIT: [hash]
:STATUS: in_progress
:END:

,** Primary Request
[description]

,** Key Files
- =file.py:12-45= - [why important]

,** Pending Tasks
- [ ] Task 1
- [X] Task 2 (done)

,** Anti-Context
- Don't use approach X (reason)

,** Next Step
[concrete action]
#+end_example

Best practices:
- Thoroughness over brevity
- Precision in file references (always include line numbers)
- Preserve the "why" behind decisions
