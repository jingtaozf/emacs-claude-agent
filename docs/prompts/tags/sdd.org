#+TITLE: SDD Workflow Container
#+PROPERTY: TAG sdd
#+PROPERTY: TYPE tag

* SDD WORKFLOW

You are working within a Spec-Driven Development (SDD) workflow. This is a structured
approach following the Atomic pattern: Research → Design → Planning → Implementation.

** SDD Structure

The current SDD has these sibling sections:

| Section | Tag | Purpose |
|---------+-----+---------|
| *Workflow* | =:sdd:= | AI interaction phases (you are here) |
| *Research Output* | =:research_output:= | Synthesized findings from exploration |
| *Spec* | =:spec:= | Living RFC document (Goals, Non-Goals, Solution) |
| *Features* | =:features:= | Atomic TODO items to implement |

** Finding Current Progress

Before starting work, understand where things stand:

1. *Check Features section*: Look for TODO/DONE states
   - Find the first incomplete TODO - that's the current focus
   - Review completed items for context

2. *Read Spec section*: Understand the technical design
   - Goals and Non-Goals define scope
   - Proposed Solution describes the approach
   - Technical Design has implementation details

3. *Review Research Output*: Access collected knowledge
   - Codebase Patterns: Existing patterns to follow
   - Relevant Files: Key files with file:line references
   - External References: Documentation and resources

** Updating Sibling Sections

As you work, update the appropriate sibling sections using MCP org tools:

*** Research Output Section

When you discover important information during exploration:

#+begin_example
Use: org_update_section
file_path: <current org file>
section_path: /<Feature Name>/Research Output/Codebase Patterns
new_content: |
  - Pattern: Repository pattern in =src/db/repos/=
  - Pattern: Factory functions in =src/utils/factories.py=
#+end_example

Update subsections:
- *Codebase Patterns*: Design patterns, coding conventions found
- *Relevant Files*: Key files with line references (=file.py:42=)
- *External References*: Links to docs, articles, related PRs

*** Spec Section

When design decisions are made:

#+begin_example
Use: org_update_section
file_path: <current org file>
section_path: /<Feature Name>/Spec/Proposed Solution
new_content: |
  Implement authentication using JWT tokens:
  1. Create AuthService class
  2. Add middleware for token validation
  3. Store refresh tokens in Redis
#+end_example

Update subsections:
- *Goals*: What we're trying to achieve
- *Non-Goals*: Explicit scope boundaries
- *Proposed Solution*: High-level approach
- *Technical Design*: Implementation details

*** Features Section

When breaking down work into atomic tasks:

#+begin_example
Use: org_update_section
file_path: <current org file>
section_path: /<Feature Name>/Features
new_content: |
  :PROPERTIES:
  :ORDERED: t
  :END:

  *** TODO Create AuthService class
  *** TODO Add JWT validation middleware
  *** TODO Implement refresh token logic
  *** TODO Write integration tests
#+end_example

** Workflow Phases

Each AI block can be tagged with a phase for focused behavior:

| Phase | Tag | Purpose | Output |
|-------+-----+---------+--------|
| Research | =:research:= | Explore codebase | → Research Output section |
| Design | =:design:= | Technical RFC | → Spec section |
| Planning | =:planning:= | Task breakdown | → Features section (TODOs) |
| Implementation | =:implementation:= | Write code | → Mark TODOs as DONE |

Select phase tags when inserting new AI blocks via =C-c C-/= → =n=.

** Key Principles

1. *Dual Memory*: Spec = lasting memory, Workflow = active memory
2. *Human Checkpoints*: Get approval at Research→Design and Planning→Implementation
3. *Atomic Features*: Each TODO should be completable in one session
4. *40-60 Rule*: Aim for 40-60% completion, humans refine the rest
5. *Update as you go*: Keep Research Output, Spec, Features current
