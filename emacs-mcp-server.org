#+TITLE: Emacs MCP Server
#+AUTHOR: Jingtao Xu

* Overview

This is a standalone MCP (Model Context Protocol) HTTP server for Emacs that
exposes tools to Claude Code CLI. It implements JSON-RPC 2.0 over HTTP with
the MCP Streamable HTTP transport protocol.

Key features:
- Single =evalElisp= tool for unlimited flexibility via elisp evaluation
- State preservation by default (buffer, point, window)
- Extensible tool registration API
- Permission modes for controlling Claude's access

Prerequisites:
- Emacs 27.1+
- =web-server= package (from ELPA)

* Dependencies

#+BEGIN_SRC elisp
(require 'json)
(require 'cl-lib)
(require 'web-server)
#+END_SRC

* MCP Server Foundation

The MCP server provides an HTTP interface for external tools (like Claude Code)
to interact with Emacs.

** Customization

#+BEGIN_SRC elisp
(defgroup emacs-mcp-server nil
  "Standalone MCP HTTP server."
  :group 'tools
  :prefix "emacs-mcp-server-")

(defcustom emacs-mcp-server-default-port 9999
  "Default port for the MCP server.
Set to 0 for auto-select."
  :type 'integer
  :group 'emacs-mcp-server)

(defcustom emacs-mcp-server-permission-mode "acceptEdits"
  "Permission mode for MCP tools.
Options: \"acceptEdits\", \"bypassPermissions\", \"plan\", \"default\".
Default is acceptEdits which enables permission callbacks."
  :type 'string
  :group 'emacs-mcp-server)

(defcustom emacs-mcp-server-allowed-tools '("mcp__emacs__*")
  "List of allowed tool patterns for auto-approval.
Uses Claude Code permission pattern syntax."
  :type '(repeat string)
  :group 'emacs-mcp-server)


(defcustom emacs-mcp-server-verbose nil
  "When non-nil, log detailed eval info to *MCP Server Log* buffer."
  :type 'boolean
  :group 'emacs-mcp-server)

(defcustom emacs-mcp-server-show-mode-line t
  "When non-nil, show MCP activity indicator in mode-line."
  :type 'boolean
  :group 'emacs-mcp-server)
(defcustom emacs-mcp-server-max-output-length 50000
  "Maximum length of output from evalElisp."
  :type 'integer
  :group 'emacs-mcp-server)
#+END_SRC

** Constants and State

Protocol version and server information:

#+BEGIN_SRC elisp
(defconst emacs-mcp-server-protocol-version "2024-11-05"
  "MCP protocol version. Must match version expected by Claude Code CLI.")

(defconst emacs-mcp-server--server-info
  '((name . "emacs-mcp-server")
    (version . "0.1.0"))
  "Server information for initialize response.")
#+END_SRC

Server state variables:

#+BEGIN_SRC elisp
(defvar emacs-mcp-server--server nil
  "The web-server instance.")

(defvar emacs-mcp-server--port nil
  "Port the server is running on.")

(defvar emacs-mcp-server--tools '()
  "List of registered MCP tools.")


;; Mode-line indicator state
(defvar emacs-mcp-server--eval-active nil
  "Non-nil when MCP eval is in progress.")

(defvar emacs-mcp-server--eval-count 0
  "Number of active eval operations.")

(defvar emacs-mcp-server--spinner-index 0
  "Current spinner frame index.")

(defvar emacs-mcp-server--spinner-timer nil
  "Timer for spinner animation.")

(defconst emacs-mcp-server--spinner-frames
  ["⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏"]
  "Spinner animation frames.")

(defvar emacs-mcp-server-activity-string ""
  "Current activity string for mode-line display.
Updated directly when eval starts/ends, like claude-agent-activity-string.")

(defconst emacs-mcp-server--log-buffer "*MCP Server Log*"
  "Buffer name for verbose logging.")
(defvar emacs-mcp-server--sessions (make-hash-table :test 'equal)
  "Active session ID -> session data mapping.")
#+END_SRC

** evalElisp Tool

The core tool that enables all Emacs operations. It evaluates arbitrary elisp
and returns the result as JSON.

*** Mode-Line Indicator

#+BEGIN_SRC elisp
(defun emacs-mcp-server--update-activity-string ()
  "Update the activity mode-line string based on eval state.
Sets `emacs-mcp-server-activity-string` directly like claude-agent does."
  (if (and emacs-mcp-server-show-mode-line
           emacs-mcp-server--eval-active)
      (let* ((spinner (aref emacs-mcp-server--spinner-frames
                            emacs-mcp-server--spinner-index))
             (text (format " [MCP%s] " spinner)))
        (setq emacs-mcp-server-activity-string
              (propertize text
                          'face '(:foreground "steel blue")
                          'help-echo "MCP Server: Evaluating elisp...")))
    (setq emacs-mcp-server-activity-string ""))
  (force-mode-line-update t))

(defun emacs-mcp-server--start-spinner ()
  "Start the spinner animation timer."
  (unless emacs-mcp-server--spinner-timer
    (setq emacs-mcp-server--spinner-timer
          (run-with-timer 0 0.15 #'emacs-mcp-server--advance-spinner))))

(defun emacs-mcp-server--stop-spinner ()
  "Stop the spinner animation timer."
  (when emacs-mcp-server--spinner-timer
    (cancel-timer emacs-mcp-server--spinner-timer)
    (setq emacs-mcp-server--spinner-timer nil))
  (setq emacs-mcp-server--spinner-index 0))

(defun emacs-mcp-server--advance-spinner ()
  "Advance spinner frame and update mode-line."
  (setq emacs-mcp-server--spinner-index
        (mod (1+ emacs-mcp-server--spinner-index)
             (length emacs-mcp-server--spinner-frames)))
  (emacs-mcp-server--update-activity-string))

(defun emacs-mcp-server--eval-start ()
  "Called when eval starts. Updates mode-line immediately."
  (cl-incf emacs-mcp-server--eval-count)
  (setq emacs-mcp-server--eval-active t)
  ;; Update string IMMEDIATELY before starting timer
  (emacs-mcp-server--update-activity-string)
  (emacs-mcp-server--start-spinner))

(defun emacs-mcp-server--eval-end ()
  "Called when eval ends. Clears mode-line indicator."
  (cl-decf emacs-mcp-server--eval-count)
  (when (<= emacs-mcp-server--eval-count 0)
    (setq emacs-mcp-server--eval-count 0)
    (setq emacs-mcp-server--eval-active nil)
    (emacs-mcp-server--stop-spinner)
    (emacs-mcp-server--update-activity-string)))

;; Add to mode-line using variable pattern (like claude-agent-activity-string)
(unless (member '(:eval emacs-mcp-server-activity-string) mode-line-misc-info)
  (push '(:eval emacs-mcp-server-activity-string) mode-line-misc-info))
#+END_SRC

*** Verbose Logging

#+BEGIN_SRC elisp
(defun emacs-mcp-server--log (format-string &rest args)
  "Log message to MCP log buffer if verbose mode is enabled."
  (when emacs-mcp-server-verbose
    (let ((buf (get-buffer-create emacs-mcp-server--log-buffer)))
      (with-current-buffer buf
        (goto-char (point-max))
        (insert (format-time-string "[%H:%M:%S.%3N] "))
        (insert (apply #'format format-string args))
        (insert "\n")))))

(defun emacs-mcp-server--log-eval-start (code)
  "Log the start of an eval operation."
  (emacs-mcp-server--log ">>> EVAL START")
  (emacs-mcp-server--log "    Code: %s"
                         (emacs-mcp-server--truncate code 200)))

(defun emacs-mcp-server--log-eval-end (result elapsed)
  "Log the end of an eval operation with RESULT and ELAPSED time."
  (emacs-mcp-server--log "    Result: %s"
                         (emacs-mcp-server--truncate
                          (format "%S" result) 200))
  (emacs-mcp-server--log "<<< EVAL END (%.3fs)" elapsed))

(defun emacs-mcp-server--log-eval-error (err elapsed)
  "Log an eval error with ERR and ELAPSED time."
  (emacs-mcp-server--log "    ERROR: %s" (error-message-string err))
  (emacs-mcp-server--log "<<< EVAL FAILED (%.3fs)" elapsed))

(defun emacs-mcp-server-toggle-verbose ()
  "Toggle verbose logging mode."
  (interactive)
  (setq emacs-mcp-server-verbose (not emacs-mcp-server-verbose))
  (message "MCP Server verbose mode: %s"
           (if emacs-mcp-server-verbose "ON" "OFF"))
  (when emacs-mcp-server-verbose
    (emacs-mcp-server--log "--- Verbose logging enabled ---")))

(defun emacs-mcp-server-show-log ()
  "Show the MCP server log buffer."
  (interactive)
  (pop-to-buffer (get-buffer-create emacs-mcp-server--log-buffer)))
#+END_SRC

*** Helper Functions

#+BEGIN_SRC elisp
(defun emacs-mcp-server--truncate (str max-len)
  "Truncate STR to MAX-LEN, adding ... if truncated."
  (if (> (length str) max-len)
      (concat (substring str 0 (- max-len 3)) "...")
    str))


(defun emacs-mcp-server--eval-with-state-preservation (form)
  "Eval FORM while preserving buffer, point, and window state.
This prevents elisp evaluation from disrupting the user's current editing context."
  (let ((orig-buffer (current-buffer))
        (orig-point (point))
        (orig-window (selected-window))
        (orig-window-buffer (window-buffer (selected-window))))
    (unwind-protect
        (eval form t)
      ;; Restore window's buffer first (handles switch-to-buffer)
      (when (and (window-live-p orig-window)
                 (buffer-live-p orig-window-buffer))
        (set-window-buffer orig-window orig-window-buffer))
      ;; Restore selected window
      (when (window-live-p orig-window)
        (select-window orig-window t))
      ;; Restore buffer context and point
      (when (buffer-live-p orig-buffer)
        (set-buffer orig-buffer)
        (goto-char (min orig-point (point-max)))))))
(defun emacs-mcp-server--pp-to-string (value)
  "Pretty-print VALUE to string, handling special cases."
  (condition-case _
      (let ((print-length 100)
            (print-level 10)
            (print-circle t))
        (pp-to-string value))
    (error (format "%S" value))))
#+END_SRC

*** Handler

#+BEGIN_SRC elisp
(defun emacs-mcp-server--handler-eval-elisp (params _session)
  "Handler for evalElisp tool.  PARAMS contains code and optional save_current_state."
  (let* ((code (alist-get 'code params))
         (save-state (if (assq 'save_current_state params)
                         (not (eq (alist-get 'save_current_state params) :json-false))
                       t))  ;; Default: true
         (start-time (current-time))
         result)
    ;; Start indicators
    (emacs-mcp-server--eval-start)
    (redisplay t)  ;; Force display update so spinner shows immediately
    (emacs-mcp-server--log-eval-start code)
    ;; Execute with cleanup
    (unwind-protect
        (setq result
              (condition-case err
                  (let ((form (car (read-from-string code)))
                        eval-result)
                    (setq eval-result
                          (if save-state
                              (emacs-mcp-server--eval-with-state-preservation form)
                            (eval form t)))
                    (emacs-mcp-server--log-eval-end
                     eval-result
                     (float-time (time-subtract (current-time) start-time)))
                    `((success . t)
                      (result . ,(emacs-mcp-server--pp-to-string eval-result))))
                (error
                 (emacs-mcp-server--log-eval-error
                  err
                  (float-time (time-subtract (current-time) start-time)))
                 `((success . :json-false)
                   (error . ,(error-message-string err))
                   (errorType . ,(symbol-name (car err)))))))
      ;; End indicators (always runs)
      (emacs-mcp-server--eval-end))
    (list `((type . "text")
            (text . ,(emacs-mcp-server--truncate
                      (json-encode result)
                      emacs-mcp-server-max-output-length))))))
#+END_SRC

*** Built-in Tools Definition

#+BEGIN_SRC elisp
(defconst emacs-mcp-server--builtin-tools
  `(((name . "evalElisp")
     (description . "Evaluate an Emacs Lisp expression and return the result. This is the single tool for all Emacs operations - use Skills to learn how to construct elisp code for specific tasks like buffer manipulation, variable inspection, navigation, etc.")
     (handler . emacs-mcp-server--handler-eval-elisp)
     (inputSchema . ((type . "object")
                     (properties . ((code . ((type . "string")
                                             (description . "Elisp code to evaluate")))
                                    (save_current_state . ((type . "boolean")
                                                           (description . "Whether to preserve buffer, point, and window state during evaluation. Default: true. Set to false only when you need the side effects (e.g., switching buffers).")))))
                     (required . ["code"])))))
  "Built-in MCP tools.")
#+END_SRC

** HTTP Response Helpers

HTTP responses follow RFC 7230 format with status line, headers, and body.
JSON-RPC responses are wrapped in HTTP - even errors return HTTP 200 with
an error payload (per JSON-RPC spec), except parse errors which use HTTP 400.

*** Raw HTTP Response Construction

The foundation for all responses. Constructs proper HTTP/1.1 response format
with status line, headers (CRLF-separated), blank line, then body.

#+NAME: http-response-raw
#+BEGIN_SRC elisp
(defun emacs-mcp-server--send-raw-response (process status-code headers body)
  "Send a complete HTTP response with STATUS-CODE, HEADERS, and BODY.
HEADERS is an alist of (name . value) pairs.
Safely handles deleted processes without signaling errors."
  (when (and process (process-live-p process))
    (condition-case nil
        (let* ((status-text (pcase status-code
                              (200 "OK")
                              (202 "Accepted")
                              (400 "Bad Request")
                              (404 "Not Found")
                              (500 "Internal Server Error")
                              (_ "Unknown")))
               (response-line (format "HTTP/1.1 %d %s\r\n" status-code status-text)))
          ;; Send status line
          (process-send-string process response-line)
          ;; Send headers
          (dolist (header headers)
            (process-send-string process
                                 (format "%s: %s\r\n" (car header) (cdr header))))
          ;; End headers
          (process-send-string process "\r\n")
          ;; Send body
          (when body
            (process-send-string process body)))
      (error nil))))  ;; Silently ignore errors on dead processes
(defun emacs-mcp-server--send-raw-response (process status-code headers body)
  "Send a complete HTTP response with STATUS-CODE, HEADERS, and BODY.
HEADERS is an alist of (name . value) pairs."
  (let* ((status-text (pcase status-code
                        (200 "OK")
                        (202 "Accepted")
                        (400 "Bad Request")
                        (404 "Not Found")
                        (500 "Internal Server Error")
                        (_ "Unknown")))
         (response-line (format "HTTP/1.1 %d %s\r\n" status-code status-text)))
    ;; Send status line
    (process-send-string process response-line)
    ;; Send headers
    (dolist (header headers)
      (process-send-string process
                           (format "%s: %s\r\n" (car header) (cdr header))))
    ;; End headers
    (process-send-string process "\r\n")
    ;; Send body
    (when body
      (process-send-string process body))))
#+END_SRC

*** Success Response Helper

Sends a JSON-RPC 2.0 success response. The =initialize= method includes
a session ID header for the client to use in subsequent requests.

#+NAME: http-response-success
#+BEGIN_SRC elisp
(defun emacs-mcp-server--send-response (request id result &optional new-session-id)
  "Send JSON-RPC success response to REQUEST with ID and RESULT.
If NEW-SESSION-ID is provided, include it in headers."
  (with-slots (process) request
    (let* ((response `((jsonrpc . "2.0")
                       (id . ,id)
                       (result . ,result)))
           (body (json-encode response))
           (headers `(("Content-Type" . "application/json")
                      ("Content-Length" . ,(number-to-string (string-bytes body)))
                      ("MCP-Protocol-Version" . ,emacs-mcp-server-protocol-version))))
      (when new-session-id
        (push `("Mcp-Session-Id" . ,new-session-id) headers))
      (emacs-mcp-server--send-raw-response process 200 headers body))))

(defun emacs-mcp-server--send-accepted (request)
  "Send HTTP 202 Accepted for notifications to REQUEST."
  (with-slots (process) request
    (emacs-mcp-server--send-raw-response
     process 202
     '(("Content-Type" . "text/plain")
       ("Content-Length" . "0"))
     nil)))
#+END_SRC

*** Error Response Helper

Sends a JSON-RPC 2.0 error response. Note: JSON-RPC errors still use HTTP 200
status - the error is in the response body, not the HTTP status.

Standard JSON-RPC error codes:
- =-32700=: Parse error (invalid JSON)
- =-32600=: Invalid Request
- =-32601=: Method not found
- =-32603=: Internal error

#+NAME: http-response-error
#+BEGIN_SRC elisp
(defun emacs-mcp-server--send-error (request id code message)
  "Send JSON-RPC error response to REQUEST with ID, CODE, and MESSAGE."
  (with-slots (process) request
    (let* ((response `((jsonrpc . "2.0")
                       (id . ,id)
                       (error . ((code . ,code)
                                 (message . ,message)))))
           (body (json-encode response)))
      (emacs-mcp-server--send-raw-response
       process 200
       `(("Content-Type" . "application/json")
         ("Content-Length" . ,(number-to-string (string-bytes body))))
       body))))
#+END_SRC

** MCP Method Handlers

The MCP protocol defines a set of JSON-RPC methods that clients (like Claude Code)
call to interact with the server. Each method has a specific role:

| Method | Purpose |
|--------+---------|
| =initialize= | Handshake - exchange protocol versions and capabilities |
| =tools/list= | Discovery - client learns what tools are available |
| =tools/call= | Execution - client invokes a specific tool |
| =prompts/list= | (Unused) List available prompt templates |
| =resources/list= | (Unused) List available resources |

*** Initialize Handler

The =initialize= method is called once when the client connects. It:
1. Creates a unique session ID for tracking this connection
2. Reports our protocol version (must match client's expected version)
3. Declares server capabilities (we support tools, no dynamic list changes)

#+NAME: mcp-handler-initialize
#+BEGIN_SRC elisp
(defun emacs-mcp-server--handle-initialize (_params)
  "Handle initialize method.  Return server info and capabilities."
  (let ((session-id (format "%d-%s"
                            emacs-mcp-server--port
                            (secure-hash 'md5 (format "%s" (current-time))))))
    (puthash session-id
             `((created . ,(current-time)))
             emacs-mcp-server--sessions)
    (cons session-id
          `((protocolVersion . ,emacs-mcp-server-protocol-version)
            (capabilities . ((tools . ((listChanged . :json-false)))))
            (serverInfo . ,emacs-mcp-server--server-info)))))
#+END_SRC

*** Schema Conversion Helpers

MCP requires JSON Schema format for tool definitions. Elisp alists have a quirk:
empty lists =()= encode as =null= in JSON, but MCP expects ={}= for empty objects.
This helper recursively converts empty alists to hash tables.

#+NAME: mcp-handler-schema-helpers
#+BEGIN_SRC elisp
(defun emacs-mcp-server--fix-empty-alists (obj)
  "Recursively fix empty alists in OBJ to use hash tables.
Empty alists () encode as null in JSON, but we need {} for MCP schema.
This converts empty () to an empty hash-table which encodes as {}."
  (cond
   ;; Empty list -> empty hash table (encodes as {})
   ((null obj) (make-hash-table))
   ;; Vector -> process elements
   ((vectorp obj) (vconcat (mapcar #'emacs-mcp-server--fix-empty-alists obj)))
   ;; Cons cell (alist entry) -> process value
   ((consp obj)
    (if (and (car obj) (not (consp (car obj))))
        ;; This is an alist entry (key . value)
        (cons (car obj) (emacs-mcp-server--fix-empty-alists (cdr obj)))
      ;; This is a list of entries
      (mapcar #'emacs-mcp-server--fix-empty-alists obj)))
   ;; Other values pass through
   (t obj)))

(defun emacs-mcp-server--tool-to-mcp-format (tool)
  "Convert TOOL to MCP wire format (without handler)."
  (let ((schema (or (alist-get 'inputSchema tool)
                    '((type . "object") (properties)))))
    `((name . ,(alist-get 'name tool))
      (description . ,(alist-get 'description tool))
      (inputSchema . ,(emacs-mcp-server--fix-empty-alists schema)))))
#+END_SRC

*** Tools List Handler

Returns all available tools (built-in + user-registered) in MCP format.
The client calls this after =initialize= to discover what operations are available.

#+NAME: mcp-handler-tools-list
#+BEGIN_SRC elisp
(defun emacs-mcp-server--handle-tools-list ()
  "Handle tools/list method.  Return registered tools (builtin + user-registered)."
  (let ((all-tools (append emacs-mcp-server--builtin-tools emacs-mcp-server--tools)))
    `((tools . ,(vconcat
                 (mapcar #'emacs-mcp-server--tool-to-mcp-format
                         all-tools))))))
#+END_SRC

*** Tools Call Handler

Executes a tool by name with provided arguments. This is the main workhorse -
every actual operation (evalElisp, org operations, etc.) flows through here.

#+NAME: mcp-handler-tools-call
#+BEGIN_SRC elisp
(defun emacs-mcp-server--handle-tools-call (params session-id)
  "Handle tools/call method.  Execute tool with PARAMS using SESSION-ID."
  (let* ((tool-name (alist-get 'name params))
         (arguments (alist-get 'arguments params))
         (all-tools (append emacs-mcp-server--builtin-tools emacs-mcp-server--tools))
         (tool (cl-find-if
                (lambda (tl) (equal (alist-get 'name tl) tool-name))
                all-tools)))
    (unless tool
      (error "Unknown tool: %s" tool-name))
    (let* ((handler (alist-get 'handler tool))
           (result (funcall handler arguments session-id)))
      `((content . ,(vconcat result))))))
#+END_SRC

*** Method Dispatcher

Routes incoming JSON-RPC method calls to the appropriate handler.
Returns empty arrays for =prompts/list= and =resources/list= since we don't
implement those MCP features.

#+NAME: mcp-handler-dispatch
#+BEGIN_SRC elisp
(defun emacs-mcp-server--dispatch (method params)
  "Dispatch MCP METHOD with PARAMS and return result."
  (pcase method
    ("initialize"
     (emacs-mcp-server--handle-initialize params))
    ("tools/list"
     (emacs-mcp-server--handle-tools-list))
    ("tools/call"
     (emacs-mcp-server--handle-tools-call params nil))
    ("prompts/list"
     '((prompts . [])))
    ("resources/list"
     '((resources . [])))
    (_
     (error "Method not found: %s" method))))
#+END_SRC

** HTTP Request Handler

Main entry point for HTTP requests.

#+BEGIN_SRC elisp
(defun emacs-mcp-server--handle-post (request)
  "Handle POST REQUEST to /mcp endpoint."
  (condition-case err
      (let* ((body (ws-body request))
             (json-obj (json-parse-string body :object-type 'alist))
             (method (alist-get 'method json-obj))
             (params (alist-get 'params json-obj))
             (id (alist-get 'id json-obj)))

        (if (null id)
            ;; Notification - return 202 Accepted immediately
            (emacs-mcp-server--send-accepted request)
          ;; Request - dispatch and respond
          (let ((result (emacs-mcp-server--dispatch method params)))
            ;; Special handling for initialize - extract session ID
            (if (and (equal method "initialize") (consp result) (stringp (car result)))
                (let ((session-id (car result))
                      (response (cdr result)))
                  (emacs-mcp-server--send-response request id response session-id))
              (emacs-mcp-server--send-response request id result)))))

    (json-parse-error
     (emacs-mcp-server--send-error request nil -32700 "Parse error"))
    (error
     (emacs-mcp-server--send-error request nil -32603
                                   (format "Internal error: %s"
                                           (error-message-string err))))))
#+END_SRC

** Public API

These are the main entry points for users.

*** Server Control

#+BEGIN_SRC elisp
;;;###autoload
(defun emacs-mcp-server-start (&optional port)
  "Start the MCP HTTP server on PORT.
If PORT is nil, uses `emacs-mcp-server-default-port'.
Returns the actual port number."
  (interactive)
  (require 'web-server)
  (when emacs-mcp-server--server
    (emacs-mcp-server-stop))
  (let* ((use-port (or port emacs-mcp-server-default-port))
         (server (ws-start
                  `(((:POST . "^/mcp.*$") . emacs-mcp-server--handle-post))
                  use-port
                  nil
                  :host "127.0.0.1")))
    (setq emacs-mcp-server--server server)
    (let* ((proc (ws-process server))
           (actual-port (process-contact proc :service)))
      (setq emacs-mcp-server--port actual-port)
      (message "MCP server started on port %d" actual-port)
      actual-port)))

;;;###autoload
(defun emacs-mcp-server-stop ()
  "Stop the MCP HTTP server."
  (interactive)
  (when emacs-mcp-server--server
    (ws-stop emacs-mcp-server--server)
    (setq emacs-mcp-server--server nil
          emacs-mcp-server--port nil)
    (clrhash emacs-mcp-server--sessions)
    (message "MCP server stopped")))
#+END_SRC

*** Tool Registration

#+BEGIN_SRC elisp
;;;###autoload
(defun emacs-mcp-server-register-tool (tool-spec)
  "Register a tool.
TOOL-SPEC is an alist with keys: name, description, handler, inputSchema.
Handler signature: (handler params session) -> list of ((type . \"text\") (text . \"result\"))."
  (let ((name (alist-get 'name tool-spec)))
    (unless name
      (error "Tool spec must have 'name'"))
    (unless (alist-get 'handler tool-spec)
      (error "Tool spec must have 'handler'"))
    ;; Remove existing tool with same name
    (setq emacs-mcp-server--tools
          (cl-remove-if (lambda (tl) (equal (alist-get 'name tl) name))
                        emacs-mcp-server--tools))
    ;; Add new tool
    (push tool-spec emacs-mcp-server--tools)
    (message "MCP tool registered: %s" name)
    name))

;;;###autoload
(defun emacs-mcp-server-unregister-tool (name)
  "Unregister tool by NAME."
  (setq emacs-mcp-server--tools
        (cl-remove-if (lambda (tl) (equal (alist-get 'name tl) name))
                      emacs-mcp-server--tools))
  (message "MCP tool unregistered: %s" name))

(defun emacs-mcp-server-clear-tools ()
  "Clear all registered tools."
  (setq emacs-mcp-server--tools '())
  (message "All MCP tools cleared"))
#+END_SRC

*** Status Functions

#+BEGIN_SRC elisp
(defun emacs-mcp-server-running-p ()
  "Return non-nil if server is running."
  (and emacs-mcp-server--server emacs-mcp-server--port))

(defun emacs-mcp-server-port ()
  "Return current server port, or nil if not running."
  emacs-mcp-server--port)
#+END_SRC

* Provide

#+BEGIN_SRC elisp
(provide 'emacs-mcp-server)
#+END_SRC

* Tests

Tests for emacs-mcp-server are located in the =tests/= directory:

| Test File | Description | Command |
|-----------+-------------+---------|
| =test-mcp-mode-line.el= | Mode-line spinner, logging, state preservation | =make test-mcp-mode-line= |
| =test-mcp-ide-integration.el= | IDE diagnostics (flycheck/flymake) | =make test-mcp-ide= |

Run all MCP tests:
#+begin_example
make test-mcp-mode-line test-mcp-ide
#+end_example
