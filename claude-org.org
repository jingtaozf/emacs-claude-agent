# -*- encoding:utf-8 Mode: POLY-ORG; org-src-preserve-indentation: t; -*-
#+TITLE: Claude Org Integration
#+SUBTITLE: Org-mode integration for Claude Agent SDK
#+AUTHOR: Jingtao Xu
#+OPTIONS: toc:2
#+Startup: noindent
#+PROPERTY: header-args :results silent
#+PROPERTY: literate-lang elisp
#+PROPERTY: literate-load yes

* Table of Contents                                            :TOC:noexport:
- [[#introduction][Introduction]]
- [[#dependencies][Dependencies]]
- [[#customization][Customization]]
- [[#session-management][Session Management]]
  - [[#session-id-functions][Session ID Functions]]
  - [[#session-scope-detection][Session Scope Detection]]
  - [[#session-recovery][Session Recovery]]
- [[#project-configuration][Project Configuration]]
  - [[#project-root][PROJECT_ROOT]]
  - [[#system-prompts][System Prompts]]
- [[#process-management][Process Management]]
  - [[#state-variables][State Variables]]
  - [[#session-state-accessors][Session State Accessors]]
- [[#block-detection][Block Detection]]
- [[#block-insertion][Block Insertion]]
- [[#slash-command-completion][Slash Command Completion]]
  - [[#command-discovery][Command Discovery]]
  - [[#company-backend][Company Backend]]
- [[#response-handling][Response Handling]]
  - [[#debounced-font-lock][Debounced Font-Lock]]
  - [[#token-handling][Token Handling]]
  - [[#message-handling][Message Handling]]
  - [[#error-handling][Error Handling]]
- [[#execution][Execution]]
  - [[#execute-command][Execute Command]]
  - [[#send-request][Send Request]]
- [[#header-line][Header Line]]
- [[#cancel-support][Cancel Support]]
- [[#session-manager-ui][Session Manager UI]]
- [[#mode-definition][Mode Definition]]
  - [[#keymap][Keymap]]
  - [[#minor-mode][Minor Mode]]
- [[#tests][Tests]]
- [[#package-footer][Package Footer]]

* Introduction

Claude Org Integration is a minor mode for org-mode that enables interactive
streaming AI queries directly within org files using ~#+begin_src ai~ blocks.

This package depends on ~claude-agent~ for Claude communication and provides
org-specific features on top of it.

** Features

- *Token-by-token streaming*: Responses stream token-by-token with debounced
  font-lock for smooth rendering.

- *Multi-session support*: Multiple queries with different CLAUDE_SESSION_ID
  values can run concurrently.

- *Session recovery*: When backend sessions expire, context is collected from
  the org file and rebuilt automatically.

- *Project support*: PROJECT_ROOT property sets cwd; :system_prompt: tagged
  sections provide project guidelines.

** Usage Example

#+BEGIN_SRC org :load no
,#+PROPERTY: PROJECT_ROOT /path/to/project

,* Project Guidelines :system_prompt:
This project uses Python 3.11.
Always use absolute imports.

,* Tasks

,** Instruction 1 :claude_chat:

,#+begin_src ai
How do I read a JSON file in Python?
,#+end_src

Response will appear here after pressing C-c C-c inside the ai block.
#+END_SRC

* Dependencies

#+BEGIN_SRC elisp
;;; claude-org.el --- Org-mode integration for Claude Agent SDK -*- lexical-binding: t; -*-

;; Copyright (C) 2024 Jingtao Xu

;; Author: Jingtao Xu
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1") (claude-agent "0.1.0"))
;; Keywords: tools, org, ai
;; URL: https://github.com/user/claude-agent

;; This file is not part of GNU Emacs.

;;; Commentary:

;; Claude Org Integration - Streaming AI queries in org-mode.
;; Use #+begin_src ai blocks to query Claude with C-c C-c.

;;; Code:

(require 'claude-agent)
(require 'org)
(require 'cl-lib)
(require 'cl)  ; For lexical-let in callback closures
#+END_SRC

* Customization

#+BEGIN_SRC elisp
(defgroup claude-org nil
  "Streaming Claude AI for org-mode."
  :group 'org
  :prefix "claude-org-")

(defcustom claude-org-fontlock-delay 0.05
  "Delay in seconds before font-lock after token insertion.
Lower = more responsive, higher = better performance."
  :type 'number
  :group 'claude-org)

(defcustom claude-org-heading-tag "claude_chat"
  "Default tag for claude chat headings."
  :type 'string
  :group 'claude-org)

(defcustom claude-org-session-tag "claude_session"
  "Tag that marks a section as having independent session scope."
  :type 'string
  :group 'claude-org)

(defcustom claude-org-output-tag "ai_output"
  "Tag for AI output sections in flat pattern.
Used to mark sections containing Claude's responses."
  :type 'string
  :group 'claude-org)

(defcustom claude-org-auto-create-response-section t
  "Whether to automatically create Response sections after executing AI blocks.
When non-nil, claude-org-execute will create a Response heading with :ai_output: tag."
  :type 'boolean
  :group 'claude-org)

(defcustom claude-org-include-ide-context t
  "Whether to include IDE context (current file, open files, selection) in prompts.
When non-nil, a <system-reminder> tag with context is prepended to each message."
  :type 'boolean
  :group 'claude-org)

(defcustom claude-org-show-system-messages nil
  "Whether to display system messages in the response."
  :type 'boolean
  :group 'claude-org)

(defcustom claude-org-allowed-tools '("Read" "Glob" "Grep" "WebFetch" "WebSearch")
  "List of tool patterns to auto-approve.
These tools will not require user approval regardless of permission mode.
Useful for allowing read operations in plan mode.
Pattern syntax: \"ToolName\" or \"ToolName(pattern)\" e.g. \"Bash(git *)\"."
  :type '(repeat string)
  :group 'claude-org)

(defcustom claude-org-auto-start-mcp-server t
  "Whether to auto-start MCP server when claude-org-mode is enabled.
When non-nil, the MCP server will be started automatically if not running."
  :type 'boolean
  :group 'claude-org)


(defcustom claude-org-setting-sources '("user")
  "List of setting sources for Claude CLI.
Controls where Claude loads skills and settings from.
Valid values: \"user\", \"project\", \"local\".

Can be overridden per-section via CLAUDE_SETTING_SOURCES property."
  :type '(repeat string)
  :group 'claude-org)

(defcustom claude-org-line-width 170
  "Maximum line width for Claude's output.
Claude will be instructed to keep lines under this many characters."
  :type 'integer
  :group 'claude-org)

(defcustom claude-org-normalize-headers t
  "When non-nil, normalize org headers in Claude's output.
Headers are adjusted so top-level headers match the current section level + 1.
This ensures Claude's output fits properly within the document hierarchy."
  :type 'boolean
  :group 'claude-org)

(defcustom claude-org-builtin-slash-commands
  '("/add-dir" "/clear" "/compact" "/content" "/help" "/ls" "/pwd" "/cd")
  "Built-in Claude Code slash commands.
These are embedded commands in the Claude Code CLI."
  :type '(repeat string)
  :group 'claude-org)

(defcustom claude-org-default-system-prompts
  '("You are a Claude agent, built on Anthropic's Claude Agent SDK.You are communicating with a senior developer through Emacs org-mode.

User Workflow:
- The user writes instructions in #+begin_src ai blocks within an org file
- Your response is streamed and appended directly after the ai block
- The conversation history is preserved in the same org file, visible above
- This works like a computational notebook where code and responses interleave

Working with Org Files:
- Treat org sections as a hierarchical filesystem (like directories and files)
- Section paths use slash notation: /Project/Tasks/Todo
- When editing the current org file or any org file, prefer org_* MCP tools:
  - org_list_sections: Browse structure (like ls)
  - org_read_section: Read content by path (like cat)
  - org_update_section: Modify section content (like editing a file)
  - org_create_section: Add new subsections
  - org_get/set_property: Manage org properties (metadata)
  - org_get/set/add/remove_tag: Manage org tags
- For non-org operations, use evalElisp to execute any Emacs Lisp
- IMPORTANT: Buffer position management for org edit tasks:
  - Before starting an org edit task, save current buffer and position using evalElisp
  - An org edit task may involve multiple MCP tool calls (read, update, create, etc.)
  - Only restore buffer and position ONCE after the entire task is complete
  - Do NOT save/restore for each individual MCP call within the same task
  - Example pattern:
    1. evalElisp: (setq my--saved-buf (current-buffer) my--saved-pos (point))
    2. Multiple org_* tool calls for the edit task...
    3. evalElisp: (when (buffer-live-p my--saved-buf) (switch-to-buffer my--saved-buf) (goto-char my--saved-pos))

Response Format:
- Your output appears directly in the org file
- Use org-mode syntax, NOT markdown:
  - Headers: MUST have space after asterisks: '* Title' (not '*Title'), '** Section' (not '**Section')
  - Bold: *bold* (not **bold**)
  - Italic: /italic/ (not _italic_)
  - Code inline: =code= or ~code~ (not backticks)
  - Code blocks: #+begin_src lang / #+end_src (not triple backticks)
  - Tables: | col1 | col2 | with |-+-| separator rows
  - Links: [[url][description]]
- Lists work the same: - or + for unordered, 1. for ordered
- Be concise - the response becomes part of the document

Important: When showing org-mode syntax examples in your response:
- NEVER use markdown code fences (```org```)
- Instead, use #+begin_example and #+end_example blocks
- Prefix org special lines (like #+BEGIN_SRC, #+PROPERTY) with a comma
- Example of correct way to show org syntax:
  #+begin_example
  ,#+PROPERTY: PROJECT_ROOT /path/to/project
  ,* My Section
  ,#+begin_src ai
  query here
  ,#+end_src
  #+end_example")
  "List of default system prompt strings for claude-org queries.
Each string in the list will be concatenated with newlines and prepended
to any user-defined :system_prompt: sections.

You can customize this by adding domain-specific prompts:
  (add-to-list \\='claude-org-default-system-prompts
               \"Always use Python 3.11 with type hints.\")"
  :type '(repeat string)
  :group 'claude-org)

(defconst claude-org-permission-property "CLAUDE_PERMISSION_MODE"
  "Org property name for permission mode.")

(defconst claude-org-sdk-uuid-property "CLAUDE_SDK_UUID"
  "Org property name for SDK session UUID (used for --resume).")

(defconst claude-org-setting-sources-property "CLAUDE_SETTING_SOURCES"
  "Org property name for setting sources (comma-separated list).")

(defconst claude-org-env-properties
  '("ANTHROPIC_MODEL" "ANTHROPIC_BASE_URL" "ANTHROPIC_AUTH_TOKEN")
  "List of environment variable org properties to pass to Claude CLI.
These can be set as org properties (file-level or section-level) and will
be passed as environment variables when starting the Claude process.")

(defconst claude-org--permission-mode-map
  '(("readonly"      . (:cli "default"            :short "RO"))
    ("accept-edits"  . (:cli "acceptEdits"        :short "ED"))
    ("plan"          . (:cli "plan"               :short "PL"))
    ("bypass"        . (:cli "bypassPermissions"  :short "BP")))
  "Map permission preset names to CLI values and short display names.
Each entry is (PRESET . (:cli CLI-VALUE :short SHORT-NAME)).")
#+END_SRC

* Session Management

Session identity is determined by file path + optional CLAUDE_SESSION_ID property.

** Helper Functions

#+BEGIN_SRC elisp
(defun claude-org--get-file-level-property (property)
  "Get PROPERTY value from file-level #+PROPERTY keyword.
Only searches in the file header area (before first heading).
Returns nil if not found."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      ;; Limit search to before first heading (file header area)
      (let ((limit (save-excursion
                     (if (re-search-forward "^\\*+ " nil t)
                         (line-beginning-position)
                       (point-max)))))
        (when (re-search-forward
               (format "^#\\+PROPERTY:[ \t]+%s[ \t]+\\(.+\\)$"
                       (regexp-quote property))
               limit t)
          (string-trim (match-string-no-properties 1)))))))
#+END_SRC

** Session ID Functions

#+BEGIN_SRC elisp
(defun claude-org--get-session-id ()
  "Get user-defined CLAUDE_SESSION_ID from org properties.
Searches section property drawer first, then file-level #+PROPERTY.
Returns nil if no session ID is defined (file path will be used alone)."
  (save-excursion
    ;; org-entry-get with t enables inheritance up the heading tree
    (org-entry-get nil "CLAUDE_SESSION_ID" t)))

(defun claude-org--get-session-scope ()
  "Determine the scope of the current CLAUDE_SESSION_ID.
Returns `section' if defined in a property drawer, `file' if defined
at file level, or nil if no session ID is defined."
  (save-excursion
    (let ((local-session (org-entry-get nil "CLAUDE_SESSION_ID" nil))
          (inherited-session (org-entry-get nil "CLAUDE_SESSION_ID" t)))
      (cond
       (local-session 'section)
       (inherited-session 'file)
       (t nil)))))

(defun claude-org--current-session-key ()
  "Get the session key for the current context.
Combines file path with optional CLAUDE_SESSION_ID property.
Uses claude-agent session key format for consistency."
  (let ((custom-id (claude-org--get-session-id)))
    (claude-agent--make-session-key buffer-file-name custom-id)))
#+END_SRC

** Session Scope Detection

#+BEGIN_SRC elisp
(defun claude-org--has-session-tag-p ()
  "Check if current section has the session tag.
Returns non-nil if current heading has :claude_session: tag."
  (save-excursion
    (when (org-at-heading-p)
      (let ((tags (org-get-tags nil t)))
        (member claude-org-session-tag tags)))))

(defun claude-org--find-session-scope-heading ()
  "Find the heading that defines the session scope.
Walks up the heading tree looking for :claude_session: tag or CLAUDE_SESSION_ID.
Checks current heading first, then walks upward.
Returns the heading position or nil if at file scope."
  (save-excursion
    (catch 'found
      ;; First check current heading (if at one)
      (when (org-at-heading-p)
        (when (or (claude-org--has-session-tag-p)
                  (org-entry-get nil "CLAUDE_SESSION_ID" nil))
          (throw 'found (point))))
      ;; Then walk up the tree
      (while (org-up-heading-safe)
        (when (or (claude-org--has-session-tag-p)
                  (org-entry-get nil "CLAUDE_SESSION_ID" nil))
          (throw 'found (point))))
      nil)))
#+END_SRC

** SDK UUID Management

The SDK UUID is the session identifier returned by Claude Code CLI. It's stored
as an org property to enable session resumption across Emacs restarts.

#+BEGIN_SRC elisp
(defun claude-org--get-sdk-uuid ()
  "Get SDK UUID from org properties for current session.
Only retrieves UUID from the same scope where CLAUDE_SESSION_ID is defined:
- If session ID is in a heading, gets UUID from that heading's property drawer
- If no session ID in headings, gets UUID from file-level #+PROPERTY
Returns nil if not set."
  (let ((session-heading (claude-org--find-session-scope-heading)))
    (if session-heading
        ;; Section-level: get UUID from the heading that defines the session
        (save-excursion
          (goto-char session-heading)
          (org-entry-get nil claude-org-sdk-uuid-property nil))  ;; nil = no inheritance
      ;; File-level: get from #+PROPERTY keyword
      (claude-org--get-file-level-property claude-org-sdk-uuid-property))))

(defun claude-org--set-sdk-uuid (uuid)
  "Set SDK UUID in org property.
Stores at the appropriate scope based on where CLAUDE_SESSION_ID is defined:
- If session ID is in a heading (current or parent), stores in that heading's property drawer
- Otherwise stores at file level."
  (let ((session-heading (claude-org--find-session-scope-heading)))
    (if session-heading
        ;; Section-level: set in the heading that defines the session
        (save-excursion
          (goto-char session-heading)
          (org-set-property claude-org-sdk-uuid-property uuid))
      ;; File-level: use #+PROPERTY keyword
      (save-excursion
        (goto-char (point-min))
        (if (re-search-forward
             (format "^#\\+PROPERTY:[ \t]+%s[ \t]+.+$" claude-org-sdk-uuid-property)
             nil t)
            ;; Update existing
            (replace-match (format "#+PROPERTY: %s %s"
                                   claude-org-sdk-uuid-property uuid))
          ;; Insert new after other properties
          (goto-char (point-min))
          (if (re-search-forward "^#\\+PROPERTY:" nil t)
              (progn
                (end-of-line)
                (insert (format "\n#+PROPERTY: %s %s"
                                claude-org-sdk-uuid-property uuid)))
            ;; No properties, insert after title or at beginning
            (if (re-search-forward "^#\\+TITLE:" nil t)
                (progn
                  (end-of-line)
                  (insert (format "\n#+PROPERTY: %s %s"
                                  claude-org-sdk-uuid-property uuid)))
              (insert (format "#+PROPERTY: %s %s\n" claude-org-sdk-uuid-property uuid)))))))))

(defun claude-org--clear-sdk-uuid ()
  "Clear SDK UUID from org properties.
Removes the property from the appropriate scope based on where CLAUDE_SESSION_ID is defined."
  (let ((session-heading (claude-org--find-session-scope-heading)))
    (if session-heading
        ;; Section-level: remove from property drawer
        (save-excursion
          (goto-char session-heading)
          (org-delete-property claude-org-sdk-uuid-property))
      ;; File-level: remove #+PROPERTY line
      (save-excursion
        (goto-char (point-min))
        (when (re-search-forward
               (format "^#\\+PROPERTY:[ \t]+%s[ \t]+.+\n?"
                       claude-org-sdk-uuid-property)
               nil t)
          (replace-match ""))))))
#+END_SRC

** Session Recovery

#+BEGIN_SRC elisp
(defun claude-org--section-has-archive-tag-p ()
  "Check if current heading has :ARCHIVE: tag.
Point must be at a heading."
  (when (org-at-heading-p)
    (member "ARCHIVE" (org-get-tags nil t))))

(defun claude-org--collect-ai-blocks-in-section ()
  "Collect AI blocks in current section (not including subsections).
Returns list of (question . response) pairs.
Point must be at a heading, or before first heading for top-level content."
  (let ((conversations '())
        (section-start (if (org-at-heading-p)
                           ;; Start after the heading line
                           (save-excursion
                             (forward-line 1)
                             (point))
                         ;; Before first heading: start from current point
                         (point)))
        (section-end (save-excursion
                       (if (org-at-heading-p)
                           ;; End is before next same-level heading
                           (progn
                             (org-end-of-subtree t t)
                             (point))
                         ;; Before first heading: search until first heading
                         (if (re-search-forward "^\\*+ " nil t)
                             (line-beginning-position)
                           (point-max))))))
    (save-excursion
      (save-restriction
        (narrow-to-region section-start section-end)
        ;; Find all ai blocks in this section only (not subsections)
        (goto-char (point-min))
        (while (re-search-forward "^[ \t]*#\\+begin_src[ \t]+ai" nil t)
          ;; Make sure we're not in a subsection
          (let ((block-pos (point)))
            (save-excursion
              (beginning-of-line)
              ;; Check if there's a heading between section start and block
              (goto-char (point-min))
              (unless (re-search-forward "^\\*+ " block-pos t)
                ;; No heading found, this block is in current section
                (goto-char block-pos)
                (let* ((q-start (progn (forward-line 1) (point)))
                       (q-end (progn (re-search-forward "^[ \t]*#\\+end_src" nil t)
                                     (line-beginning-position)))
                       (question (string-trim (buffer-substring-no-properties q-start q-end)))
                       ;; Response is content after #+end_src until next heading or ai block
                       (r-start (progn (forward-line 1) (point)))
                       (r-end (save-excursion
                                (if (re-search-forward "^\\(\\*+ \\|[ \t]*#\\+begin_src\\)" nil t)
                                    (line-beginning-position)
                                  (point-max))))
                       (response (string-trim (buffer-substring-no-properties r-start r-end))))
                  (when (not (string-empty-p question))
                    (push (cons question response) conversations)))))))))
    (nreverse conversations)))

(defun claude-org--collect-session-context ()
  "Collect conversation history from current session scope.
If CLAUDE_SESSION_ID is defined in a section, narrows to that subtree.
Otherwise, collects from the entire file.
Skips sections tagged with :ARCHIVE: for better performance with large files.
Returns list of (question . response) pairs for recovery."
  (let ((conversations '())
        (scope (claude-org--get-session-scope)))
    (save-excursion
      (save-restriction
        ;; Narrow to section scope if session ID is defined locally
        (when (eq scope 'section)
          (unless (org-at-heading-p)
            (org-back-to-heading t))
          (org-narrow-to-subtree))

        ;; Collect blocks from before first heading
        (goto-char (point-min))
        (unless (org-at-heading-p)
          (setq conversations (append conversations (claude-org--collect-ai-blocks-in-section))))

        ;; Iterate through top-level sections, skipping archived ones
        (goto-char (point-min))
        (when (re-search-forward "^\\*+ " nil t)
          (beginning-of-line)
          (while (not (eobp))
            (if (claude-org--section-has-archive-tag-p)
                ;; Skip entire archived subtree
                (org-end-of-subtree t t)
              ;; Collect blocks from this section
              (setq conversations (append conversations (claude-org--collect-ai-blocks-in-section)))
              ;; Move to next same-level heading
              (org-end-of-subtree t t))
            ;; Move to next top-level heading
            (unless (re-search-forward "^\\*+ " nil t)
              (goto-char (point-max)))
            (beginning-of-line)))))
    conversations))

(defun claude-org--build-recovery-prompt (context original-prompt)
  "Build recovery prompt with CONTEXT history and ORIGINAL-PROMPT."
  (let ((scope (claude-org--get-session-scope)))
    (concat
     "<session_recovery>\n"
     "The previous session expired. Here is the conversation history from this "
     (if (eq scope 'section) "section" "file")
     ":\n\n"
     (mapconcat
      (lambda (pair)
        (format "**User:** %s\n\n**Assistant:** %s\n\n---\n"
                (car pair) (cdr pair)))
      context "")
     "</session_recovery>\n\n"
     "Please continue the conversation. The user's current question is:\n\n"
     original-prompt)))

(defun claude-org--recover-session (session-key &optional reason)
  "Recover session for SESSION-KEY by collecting context and retrying.
REASON can be 'context-limit or 'expired (default)."
  (claude-org--session-put session-key :recovering t)
  ;; Notify user with appropriate message
  (let ((marker (claude-org--session-get session-key :marker))
        (msg (pcase reason
               ('context-limit "/Context limit reached, recovering with history.../")
               (_ "/Session expired, recovering with context.../"))))
    (when marker
      (with-current-buffer (marker-buffer marker)
        (save-excursion
          (goto-char marker)
          (insert (format "\n%s\n\n" msg))
          (set-marker marker (point)))
        ;; Clear old session UUID from org property
        (claude-org--clear-sdk-uuid))))
  ;; Collect context and retry
  (let* ((context (claude-org--collect-session-context))
         (original-prompt (claude-org--session-get session-key :original-prompt))
         (recovery-prompt (claude-org--build-recovery-prompt context original-prompt)))
    ;; Retry with recovery prompt
    (claude-org--send-request recovery-prompt)))
#+END_SRC

* Environment Variable Loading

Load environment variables from `.env` files with variable substitution support.

** ENV File Loading

#+BEGIN_SRC elisp
(defun claude-org--parse-env-file (file-path)
  "Parse .env FILE-PATH and return alist of (VAR . VALUE).
Supports standard .env syntax:
  KEY=value
  KEY=\"value with spaces\"
  # Comments
  export KEY=value (export prefix ignored)

Performs tilde expansion on file-path."
  (let ((expanded-path (expand-file-name file-path))
        (env-alist '()))
    (when (file-exists-p expanded-path)
      (with-temp-buffer
        (insert-file-contents expanded-path)
        (goto-char (point-min))
        (while (not (eobp))
          (let ((line (string-trim (buffer-substring-no-properties
                                    (line-beginning-position)
                                    (line-end-position)))))
            ;; Skip empty lines and comments
            (unless (or (string-empty-p line)
                        (string-prefix-p "#" line))
              ;; Remove optional "export " prefix
              (when (string-match "^export[ \t]+" line)
                (setq line (substring line (match-end 0))))
              ;; Parse KEY=VALUE
              (when (string-match "^\\([A-Za-z_][A-Za-z0-9_]*\\)=\\(.*\\)$" line)
                (let* ((key (match-string 1 line))
                       (value (match-string 2 line))
                       ;; Remove surrounding quotes if present
                       (unquoted-value (if (and (>= (length value) 2)
                                                (or (and (string-prefix-p "\"" value)
                                                         (string-suffix-p "\"" value))
                                                    (and (string-prefix-p "'" value)
                                                         (string-suffix-p "'" value))))
                                           (substring value 1 -1)
                                         value)))
                  (push (cons key unquoted-value) env-alist)))))
          (forward-line 1))))
    (nreverse env-alist)))

(defun claude-org--get-env-file-path ()
  "Get ENV_FILE path from org properties.
Returns nil if not set. Supports tilde expansion."
  (when-let ((env-file (claude-org--get-org-property "ENV_FILE" t))) ; no-expand=t
    (expand-file-name env-file)))

(defun claude-org--load-env-file ()
  "Load environment variables from ENV_FILE property.
Returns alist of (VAR . VALUE), or nil if no ENV_FILE is set."
  (when-let ((env-file-path (claude-org--get-env-file-path)))
    (if (file-exists-p env-file-path)
        (claude-org--parse-env-file env-file-path)
      (message "Warning: ENV_FILE not found: %s" env-file-path)
      nil)))
#+END_SRC

** Variable Substitution

#+BEGIN_SRC elisp
(defun claude-org--expand-env-vars (value env-alist)
  "Expand ${VAR} references in VALUE using ENV-ALIST.
ENV-ALIST is an alist of (VAR-NAME . VAR-VALUE).
Also expands environment variables from process-environment.

Examples:
  \"${HOME}/projects\"     -> \"/Users/user/projects\"
  \"token=${API_TOKEN}\"   -> \"token=sk-abc123\"
  \"${VAR:-default}\"      -> Uses default if VAR not set (bash syntax)"
  (when value
    (let ((result value))
      ;; Replace ${VAR} with values from env-alist or process-environment
      (while (string-match "\\${\\([A-Za-z_][A-Za-z0-9_]*\\)\\(:-\\([^}]*\\)\\)?}" result)
        (let* ((var-name (match-string 1 result))
               (default-value (match-string 3 result))
               ;; Look up in env-alist first, then process-environment
               (var-value (or (cdr (assoc var-name env-alist))
                              (getenv var-name)
                              default-value
                              "")))
          (setq result (replace-match var-value t t result))))
      result)))
#+END_SRC

* Permission Mode

Permission mode can be stored as org property `CLAUDE_PERMISSION_MODE`.
- File-level: =#+PROPERTY: CLAUDE_PERMISSION_MODE accept-edits=
- Section-level: =:CLAUDE_PERMISSION_MODE: bypass= in property drawer

** Permission Mode Functions

#+BEGIN_SRC elisp
(defun claude-org--get-permission-mode-property ()
  "Get CLAUDE_PERMISSION_MODE from org properties.
Checks section property drawer first, then file-level #+PROPERTY.
Returns nil if not set."
  (or
   ;; Section-level property (with inheritance)
   (org-entry-get nil claude-org-permission-property t)
   ;; File-level property via keyword
   (claude-org--get-file-level-property claude-org-permission-property)))

(defun claude-org--get-permission-mode ()
  "Get effective permission mode for current session.
Priority: org property > global preset > 'readonly'.
Returns CLI permission-mode value."
  (let* ((preset (or (claude-org--get-permission-mode-property)
                     claude-agent-permission-preset
                     "readonly"))
         (mode-info (cdr (assoc preset claude-org--permission-mode-map))))
    (if mode-info
        (plist-get mode-info :cli)
      "default")))

(defun claude-org--get-permission-mode-display ()
  "Get current permission mode name for display."
  (or (claude-org--get-permission-mode-property)
      claude-agent-permission-preset
      "readonly"))

(defun claude-org--permission-mode-short ()
  "Get short permission mode string for header-line display."
  (let* ((preset (claude-org--get-permission-mode-display))
         (mode-info (cdr (assoc preset claude-org--permission-mode-map))))
    (if mode-info
        (plist-get mode-info :short)
      "??")))

(defun claude-org--get-setting-sources ()
  "Get setting sources for Claude CLI.
Checks CLAUDE_SETTING_SOURCES org property first, then uses default.
Returns list of strings like (\"user\" \"project\")."
  (let ((prop-value
         (or
          ;; Section-level property (with inheritance)
          (org-entry-get nil claude-org-setting-sources-property t)
          ;; File-level property via keyword
          (claude-org--get-file-level-property claude-org-setting-sources-property))))
    (if prop-value
        ;; Parse comma-separated string from property
        (mapcar #'string-trim (split-string prop-value ","))
      ;; Use default
      claude-org-setting-sources)))

(defun claude-org--get-org-property (property &optional no-expand)
  "Get PROPERTY value from org properties with variable expansion.
Checks section property drawer first (with inheritance), then file-level #+PROPERTY.
Returns nil if not set.

By default, expands ${VAR} references using ENV_FILE variables and process environment.
Set NO-EXPAND to t to disable variable expansion."
  (let ((raw-value
         (or
          ;; Section-level property (with inheritance)
          (org-entry-get nil property t)
          ;; File-level property via keyword
          (claude-org--get-file-level-property property))))
    ;; Apply variable expansion unless disabled
    (if (or no-expand (not raw-value))
        raw-value
      (let ((env-alist (claude-org--load-env-file)))
        (claude-org--expand-env-vars raw-value env-alist)))))

(defun claude-org--get-env-vars ()
  "Collect environment variables from org properties.
Returns an alist of (VAR-NAME . VALUE) for all properties in
`claude-org-env-properties' that have values set."
  (let (env-vars)
    (dolist (prop claude-org-env-properties)
      (let ((value (claude-org--get-org-property prop)))
        (when (and value (not (string-empty-p value)))
          (push (cons prop value) env-vars))))
    (nreverse env-vars)))
#+END_SRC

** Permission Mode Setter

#+BEGIN_SRC elisp
(defun claude-org--set-permission-mode (mode)
  "Set permission MODE in org property.
Sets at the appropriate scope based on where CLAUDE_SESSION_ID is defined:
- If session ID is in a heading (current or parent), sets in that heading's property drawer
- Otherwise sets at file level."
  (let ((session-heading (claude-org--find-session-scope-heading)))
    (if session-heading
        ;; Section-level: set property in the heading that defines the session
        (save-excursion
          (goto-char session-heading)
          (org-set-property claude-org-permission-property mode))
      ;; File-level: use #+PROPERTY keyword
      (save-excursion
        (goto-char (point-min))
        (if (re-search-forward
             (format "^#\\+PROPERTY:[ \t]+%s[ \t]+.+$" claude-org-permission-property)
             nil t)
            ;; Update existing
            (replace-match (format "#+PROPERTY: %s %s"
                                   claude-org-permission-property mode))
          ;; Insert new after other properties
          (if (re-search-forward "^#\\+PROPERTY:" nil t)
              (progn
                (end-of-line)
                (insert (format "\n#+PROPERTY: %s %s"
                                claude-org-permission-property mode)))
            ;; No properties, insert at beginning
            (insert (format "#+PROPERTY: %s %s\n" claude-org-permission-property mode))))))
    ;; Clear org's keyword property cache so org-entry-get reads fresh values
    ;; Without this, org-entry-get with inheritance returns stale cached values
    (setq-local org-keyword-properties nil)))

(defun claude-org-switch-permission-mode ()
  "Show current permission mode and switch to another.
Sets the CLAUDE_PERMISSION_MODE property at the appropriate scope."
  (interactive)
  (let* ((current (claude-org--get-permission-mode-display))
         (presets '(("readonly - Require approval for all tools" . "readonly")
                    ("accept-edits - Accept file edits without prompts" . "accept-edits")
                    ("plan - Suggests changes, requires approval for edits" . "plan")
                    ("bypass - All tools auto-approved" . "bypass")))
         (choices (mapcar (lambda (p)
                            (if (string= (cdr p) current)
                                (cons (concat (car p) " [current]") (cdr p))
                              p))
                          presets))
         (selection (completing-read
                     (format "Permission mode [%s]: " current)
                     (mapcar #'car choices)
                     nil t))
         (mode (cdr (assoc (replace-regexp-in-string " \\[current\\]$" "" selection)
                           choices))))
    (when mode
      (claude-org--set-permission-mode mode)
      (claude-org--refresh-header-line)
      (message "Permission mode set to: %s" mode))))
#+END_SRC

** MCP Server Integration

Automatically start MCP server and pass configuration to Claude CLI.

#+BEGIN_SRC elisp
(defun claude-org--ensure-mcp-server ()
  "Ensure MCP server is running if auto-start is enabled.
Starts the MCP server on `emacs-mcp-server-default-port' if not already running."
  (when (and claude-org-auto-start-mcp-server
             (fboundp 'emacs-mcp-server-running-p)
             (not (emacs-mcp-server-running-p)))
    (emacs-mcp-server-start)))

(defun claude-org--get-mcp-config ()
  "Get MCP config JSON string if server is running.
Returns nil if MCP server is not available or not running."
  (when (and (fboundp 'emacs-mcp-server-running-p)
             (emacs-mcp-server-running-p))
    (let ((port (emacs-mcp-server-port)))
      (json-encode
       `((mcpServers . ((emacs . ((type . "http")
                                  (url . ,(format "http://localhost:%d/mcp" port)))))))))))
#+END_SRC

* Project Configuration

Project configuration for cwd and system prompts.

** PROJECT_ROOT

#+BEGIN_SRC elisp
(defun claude-org--get-project-root ()
  "Get project root from org properties with inheritance.
Checks section-level property drawer first, then inherits from parent headings,
finally falls back to file-level #+PROPERTY.
Returns nil if not set (will use default-directory).

Usage in org file:
  File-level: #+PROPERTY: PROJECT_ROOT /path/to/project
  Section-level (property drawer):
    * My Section
    :PROPERTIES:
    :PROJECT_ROOT: /other/path
    :END:"
  (org-entry-get nil "PROJECT_ROOT" t))
#+END_SRC

** System Prompts

#+BEGIN_SRC elisp
(defun claude-org--collect-system-prompts ()
  "Collect content from all org sections tagged :system_prompt:.
Returns concatenated string of heading + body for each section, or nil if none.

Usage in org file:
  * Project Guidelines :system_prompt:
  This project uses Python 3.11 with Django.
  Always use absolute imports."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      (let ((prompts '())
            (heading-re "^\\(\\*+\\) +\\(.*\\):system_prompt:"))
        ;; Use regex search instead of org-map-entries to avoid cache issues
        (while (re-search-forward heading-re nil t)
          (let* ((stars (match-string 1))
                 (heading-text (match-string 2))
                 (heading (string-trim (replace-regexp-in-string ":.*$" "" heading-text)))
                 (beg (save-excursion
                        (forward-line 1)
                        ;; Skip property drawers and planning lines
                        (while (and (not (eobp))
                                    (looking-at "^[ \t]*\\(:\\|DEADLINE:\\|SCHEDULED:\\|CLOSED:\\)"))
                          (forward-line 1))
                        (point)))
                 (end (save-excursion
                        (beginning-of-line)
                        (org-end-of-subtree t t)
                        (point)))
                 (body (when (< beg end)
                         (string-trim (buffer-substring-no-properties beg end)))))
            (when (and heading (not (string-empty-p heading)))
              (push (concat "* " heading
                            (when (and body (not (string-empty-p body)))
                              (concat "\n" body)))
                    prompts))))
        (when prompts
          (mapconcat #'identity (nreverse prompts) "\n\n"))))))

(defun claude-org--build-system-prompt ()
  "Build complete system prompt from defaults and org sections.
Combines `claude-org-default-system-prompts' with any :system_prompt: tagged sections.
Also appends line width instruction based on `claude-org-line-width'."
  (let ((defaults (when claude-org-default-system-prompts
                    (mapconcat #'identity claude-org-default-system-prompts "\n\n")))
        (org-prompts (claude-org--collect-system-prompts))
        (line-width-hint (when (and claude-org-line-width (> claude-org-line-width 0))
                           (format "Keep output lines under %d characters, break long lines naturally."
                                   claude-org-line-width))))
    (let ((base-prompt (cond
                        ((and defaults org-prompts) (concat defaults "\n\n" org-prompts))
                        (defaults defaults)
                        (org-prompts org-prompts)
                        (t nil))))
      (if (and base-prompt line-width-hint)
          (concat base-prompt "\n\n" line-width-hint)
        (or base-prompt line-width-hint)))))
#+END_SRC

* Process Management

Multi-session process management allowing concurrent queries.

** State Variables

#+BEGIN_SRC elisp
(defvar-local claude-org--sessions nil
  "Hash table mapping session-key -> session state plist.
Each session state contains:
  :process-state - claude-agent process state
  :marker        - insertion marker
  :busy          - boolean busy state
  :spinner       - spinner frame index (0-3)
  :start-time    - request start time (float-time)
  :original-prompt - for session recovery
  :recovering    - non-nil during recovery
  :section-level - heading level for response adjustment

Initialized to a new hash table when `claude-org-mode' is enabled.")

(defvar-local claude-org--fontlock-timer nil
  "Timer for debounced font-lock during streaming.")
#+END_SRC

** Session State Accessors

#+BEGIN_SRC elisp
(defun claude-org--get-session (session-key)
  "Get or create session state for SESSION-KEY."
  ;; Ensure hash table exists (lazy initialization per buffer)
  ;; Must use setq-local to create buffer-local binding
  (unless (local-variable-p 'claude-org--sessions)
    (setq-local claude-org--sessions (make-hash-table :test 'equal)))
  (or (gethash session-key claude-org--sessions)
      (let ((state (list :process-state nil
                         :marker nil
                         :busy nil
                         :spinner 0
                         :start-time nil
                         :original-prompt nil
                         :recovering nil
                         :section-level 0)))
        (puthash session-key state claude-org--sessions)
        state)))

(defun claude-org--session-put (session-key prop value)
  "Set PROP to VALUE in session SESSION-KEY."
  (let ((state (claude-org--get-session session-key)))
    (plist-put state prop value)
    (puthash session-key state claude-org--sessions)))

(defun claude-org--session-get (session-key prop)
  "Get PROP from session SESSION-KEY."
  (plist-get (claude-org--get-session session-key) prop))

(defun claude-org--active-session-count ()
  "Return count of sessions with :busy t."
  (let ((count 0))
    (when (hash-table-p claude-org--sessions)
      (maphash (lambda (_id state)
                 (when (plist-get state :busy)
                   (cl-incf count)))
               claude-org--sessions))
    count))

(defun claude-org--session-display-name (session-key)
  "Extract display name from SESSION-KEY.
Returns just the custom part after :: or a shortened file path."
  (if (string-match "::\\(.+\\)$" session-key)
      (match-string 1 session-key)
    ;; No custom ID, show abbreviated file name
    (file-name-nondirectory session-key)))

(defun claude-org--format-elapsed (start-time)
  "Format elapsed time since START-TIME as human-readable string.
Uses verbose format for header-line display."
  (claude-agent-format-elapsed-time start-time 'verbose))
#+END_SRC

* Block Detection

Block detection functions.

#+BEGIN_SRC elisp
(defun claude-org--get-section-level ()
  "Get the current org section level (number of stars).
Returns 0 if not inside any heading, otherwise returns the heading level."
  (save-excursion
    (if (org-before-first-heading-p)
        0
      (org-back-to-heading t)
      (org-current-level))))

(defun claude-org--in-ai-block-p ()
  "Return t if point is inside a #+begin_src ai block."
  (save-excursion
    (let ((case-fold-search t)
          (pos (point)))
      (when (re-search-backward "^[ \t]*#\\+begin_src[ \t]+ai\\b" nil t)
        (let ((block-start (point)))
          ;; If we find end_src, check we're between begin and end
          ;; If no end_src found, assume we're still inside the block (incomplete block)
          (if (re-search-forward "^[ \t]*#\\+end_src" nil t)
              (and (>= pos block-start)
                   (<= pos (point)))
            ;; No end found, we're in an incomplete block - that's OK
            (>= pos block-start)))))))

(defun claude-org--get-block-content ()
  "Get content of the ai block at point."
  (save-excursion
    (let ((case-fold-search t))
      (when (re-search-backward "^[ \t]*#\\+begin_src[ \t]+ai\\b" nil t)
        (forward-line 1)
        (let ((start (point)))
          (when (re-search-forward "^[ \t]*#\\+end_src" nil t)
            (forward-line 0)
            (string-trim (buffer-substring-no-properties start (point)))))))))

(defun claude-org--find-block-end ()
  "Find position at end of #+end_src line."
  (save-excursion
    (let ((case-fold-search t))
      (when (re-search-forward "^[ \t]*#\\+end_src" nil t)
        (line-end-position)))))

(defun claude-org--in-output-section-p ()
  "Check if cursor is inside an :ai_output: tagged section.
Returns non-nil if current heading or any parent heading has the output tag."
  (save-excursion
    (let ((tags (org-get-tags nil t)))
      (member claude-org-output-tag tags))))

(defun claude-org--find-instruction-number ()
  "Extract instruction number from current or parent heading.
Returns nil if not in an Instruction heading."
  (save-excursion
    (when (ignore-errors (org-back-to-heading t))
      (when (looking-at "^\\*+ Instruction \\([0-9]+\\)")
        (string-to-number (match-string 1))))))

(defun claude-org--skip-to-after-output-section ()
  "Skip to after the current :ai_output: section.
Moves point to after the output section's subtree, ready to insert sibling."
  (when (claude-org--in-output-section-p)
    (org-back-to-heading t)
    ;; Move to the end of this subtree
    (org-end-of-subtree t t)))
#+END_SRC

* Block Insertion

Block insertion and session info commands.

#+BEGIN_SRC elisp
(defun claude-org--next-instruction-number ()
  "Find the next available instruction number."
  (save-excursion
    (goto-char (point-min))
    (let ((max-num 0))
      (while (re-search-forward "^\\*+ Instruction \\([0-9]+\\)" nil t)
        (setq max-num (max max-num (string-to-number (match-string 1)))))
      (1+ max-num))))

(defun claude-org-insert-block ()
  "Insert an AI query block with auto-numbered Instruction heading.
Smart insertion that skips :ai_output: sections to maintain flat pattern.
Inserts at the same level as the last Instruction heading, or current level if no Instructions exist."
  (interactive)
  ;; If inside an output section, skip to after it
  (claude-org--skip-to-after-output-section)
  ;; Find the level by looking for the last Instruction heading
  (let* ((level (or (save-excursion
                      (when (re-search-backward "^\\(\\*+\\) Instruction [0-9]+" nil t)
                        (length (match-string 1))))
                    (org-current-level)
                    1))
         (stars (make-string level ?*))
         (num (claude-org--next-instruction-number)))
    (insert stars " Instruction " (number-to-string num) " :" claude-org-heading-tag ":\n\n")
    (insert "#+begin_src ai\n\n#+end_src\n")
    (forward-line -2)))

(defun claude-org-insert-session-block ()
  "Insert an AI query block with independent section-scoped session.
The :claude_session: tag creates a new conversation context for this subtree."
  (interactive)
  (let* ((level (or (org-current-level) 1))
         (stars (make-string level ?*))
         (num (claude-org--next-instruction-number)))
    (insert stars " Session " (number-to-string num) " :" claude-org-session-tag ":\n\n")
    (insert "#+begin_src ai\n\n#+end_src")
    (forward-line -1)))

(defun claude-org-insert-story ()
  "Insert a new story section with unique CLAUDE_SESSION_ID.
Prompts for story title and creates a section with session property.
The story has its own isolated conversation context."
  (interactive)
  (let* ((title (read-string "Story title: "))
         (session-id (format "story-%s" (format-time-string "%Y%m%d-%H%M%S")))
         (level (or (org-current-level) 1))
         (stars (make-string level ?*)))
    ;; Insert heading
    (insert stars " " title "\n")
    ;; Insert property drawer with session ID
    (insert ":PROPERTIES:\n")
    (insert ":CLAUDE_SESSION_ID: " session-id "\n")
    (insert ":END:\n\n")
    ;; Position cursor for content
    (message "Created story '%s' with session ID: %s" title session-id)))

(defun claude-org-show-session-info ()
  "Display current session information.
Shows the session identity which is file_path + optional CLAUDE_SESSION_ID."
  (interactive)
  (let* ((session-id (claude-org--get-session-id))
         (scope (claude-org--get-session-scope))
         (file-path (or buffer-file-name "unsaved")))
    (if session-id
        (message "Session: %s::%s (scope: %s)" file-path session-id scope)
      (message "Session: %s (file path only, no CLAUDE_SESSION_ID property)" file-path))))
#+END_SRC

* Slash Command Completion

Auto-completion for Claude Code slash commands in AI blocks.

** Command Discovery

#+BEGIN_SRC elisp
(defun claude-org--scan-command-dir (dir)
  "Scan DIR for .md files and return list of slash commands.
Subdirectories create namespaced commands with : separator.
Example: dir/custom/test.md becomes /custom:test"
  (when (file-directory-p dir)
    (let ((commands nil))
      (dolist (file (directory-files-recursively dir "\\.md$"))
        (let* ((relative (file-relative-name file dir))
               (parts (split-string relative "/"))
               (name (file-name-sans-extension (car (last parts))))
               (namespace (butlast parts)))
          (push (if namespace
                    (concat "/" (mapconcat #'identity namespace ":") ":" name)
                  (concat "/" name))
                commands)))
      commands)))

(defun claude-org--scan-plugin-commands ()
  "Scan plugin commands from ~/.claude/plugins/marketplaces/*/plugins/*/commands/*.md.
Returns list of slash commands with plugin namespace.
Example: /plugin-name:command"
  (let ((commands nil)
        (plugins-dir (expand-file-name "~/.claude/plugins")))
    (when (file-directory-p plugins-dir)
      ;; Scan both direct plugins and marketplace plugins
      (dolist (search-pattern (list (expand-file-name "*/commands" plugins-dir)
                                     (expand-file-name "marketplaces/*/plugins/*/commands" plugins-dir)))
        (dolist (commands-dir (file-expand-wildcards search-pattern))
          (when (file-directory-p commands-dir)
            (let* ((plugin-dir (file-name-directory (directory-file-name commands-dir)))
                   (plugin-name (file-name-nondirectory (directory-file-name plugin-dir))))
              ;; Only scan root of commands/ (flat, no recursion)
              (dolist (file (directory-files commands-dir nil "\\.md$"))
                (let ((cmd-name (file-name-sans-extension file)))
                  (push (concat "/" plugin-name ":" cmd-name) commands))))))))
    commands))

(defun claude-org--discover-slash-commands ()
  "Discover all available slash commands from user, project, and plugins.
Returns list of command strings with / prefix."
  (let ((commands (copy-sequence claude-org-builtin-slash-commands))
        (user-dir (expand-file-name "~/.claude/commands"))
        (project-root (claude-org--get-project-root)))
    ;; Add user commands
    (setq commands (append commands (claude-org--scan-command-dir user-dir)))
    ;; Add project commands if PROJECT_ROOT is set
    (when project-root
      (let ((project-dir (expand-file-name ".claude/commands" project-root)))
        (setq commands (append commands (claude-org--scan-command-dir project-dir)))))
    ;; Add plugin commands
    (setq commands (append commands (claude-org--scan-plugin-commands)))
    ;; Remove duplicates (first match wins)
    (delete-dups commands)
    commands))
#+END_SRC

** Company Backend

#+BEGIN_SRC elisp
(defun claude-org--at-line-start-p ()
  "Check if point is at the start of a line (ignoring whitespace)."
  (save-excursion
    (skip-chars-backward " \t")
    (bolp)))

(defun claude-org-company-slash-commands (command &optional arg &rest ignored)
  "Company backend for Claude slash commands in AI blocks.
Only triggers when / is at the start of a line."
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'claude-org-company-slash-commands))
    (prefix (when (claude-org--in-ai-block-p)
              (if (and (save-excursion
                         ;; Skip back over the partial command and whitespace
                         (skip-chars-backward "/a-z:_- \t")
                         (bolp))
                       (looking-back "/[a-z:_-]*" (line-beginning-position)))
                  ;; Return prefix with :length 1 to trigger on just "/"
                  ;; This overrides company-minimum-prefix-length
                  (let ((prefix (match-string-no-properties 0)))
                    (cons prefix (length prefix)))
                ;; In AI block but not a slash command - don't interfere
                nil)))
    (candidates (let ((commands (claude-org--discover-slash-commands)))
                  (cl-remove-if-not
                   (lambda (c) (string-prefix-p arg c t))  ;; case-insensitive
                   commands)))
    (sorted t)))
#+END_SRC

* Response Handling

Response handling for streaming tokens.

** Debounced Font-Lock

#+BEGIN_SRC elisp
(defun claude-org--schedule-fontlock ()
  "Schedule a debounced font-lock refresh.
Batches rapid updates during streaming for better performance."
  (when claude-org--fontlock-timer
    (cancel-timer claude-org--fontlock-timer))
  (setq claude-org--fontlock-timer
        (run-with-timer claude-org-fontlock-delay nil
                        (lambda ()
                          (when (and (buffer-live-p (current-buffer))
                                     (derived-mode-p 'org-mode))
                            (font-lock-flush)
                            (redisplay))))))
#+END_SRC

** Header Normalization

Normalize org headers in Claude's output to fit the document hierarchy.
Headers are adjusted so Claude's top-level (=*=) becomes the target level.

Uses simple regex replacement - no buffering needed since =^= matches
both start of string and start of line (after newline).

#+BEGIN_SRC elisp
(defun claude-org--normalize-headers-in-text (text target-level)
  "Normalize org headers in TEXT to start at TARGET-LEVEL.
Headers at line start are adjusted: Claude's level N becomes target-level + (N-1).
Only lines starting with asterisks followed by space are treated as headers.
No buffering - processes each token independently using regex."
  (if (not claude-org-normalize-headers)
      text
    (let ((offset (1- target-level)))
      (replace-regexp-in-string
       "^\\(\\*+\\) "
       (lambda (match)
         (let* ((stars (match-string 1 match))
                (new-level (+ (length stars) offset)))
           (concat (make-string (max 1 new-level) ?*) " ")))
       text))))
#+END_SRC

** Token Handling

#+BEGIN_SRC elisp
(defun claude-org--handle-token (session-key text)
  "Handle incoming TEXT token for SESSION-KEY.
Normalizes org headers and inserts text at the session's marker."
  (let ((marker (claude-org--session-get session-key :marker)))
    (when (and marker (marker-buffer marker))
      (with-current-buffer (marker-buffer marker)
        (let* ((target-level (1+ (or (claude-org--session-get session-key :section-level) 0)))
               (normalized-text (claude-org--normalize-headers-in-text text target-level)))
          ;; Insert normalized text
          (when (> (length normalized-text) 0)
            (save-excursion
              (goto-char marker)
              (insert normalized-text)
              (set-marker marker (point)))))
        (claude-org--schedule-fontlock)))))
#+END_SRC

** Message Handling

#+BEGIN_SRC elisp
(defun claude-org--format-todo-item (todo)
  "Format a single TODO item as org checkbox.
TODO is a plist with :content, :status, and :activeForm.
When status is in_progress, show activeForm instead of content
since activeForm is the present continuous form of the same task."
  (let* ((content (plist-get todo :content))
         (status (plist-get todo :status))
         (active-form (plist-get todo :activeForm))
         (checkbox (pcase status
                     ("completed" "[X]")
                     ("in_progress" "[-]")
                     (_ "[ ]")))
         ;; Use activeForm for in_progress, content otherwise
         (display-text (if (and (string= status "in_progress") active-form)
                           active-form
                         content)))
    (format "- %s %s" checkbox display-text)))

(defun claude-org--format-todos (todos)
  "Format TODOS list as org checkbox list.
TODOS is a list of plists with :content, :status, :activeForm."
  (when todos
    (concat "\n*Todos:*\n"
            (mapconcat #'claude-org--format-todo-item todos "\n")
            "\n")))

(defun claude-org--handle-tool-use (session-key tool-name tool-input)
  "Handle special TOOL-NAME with TOOL-INPUT for SESSION-KEY.
Returns formatted string to insert, or nil if not a special tool."
  (pcase tool-name
    ("TodoWrite"
     (let ((todos (plist-get tool-input :todos)))
       (claude-org--format-todos todos)))
    (_ nil)))

(defun claude-org--handle-message (session-key msg)
  "Handle incoming MSG for SESSION-KEY.
Extracts session ID from result messages and stores it."
  ;; Store SDK UUID to org property when we get a result message
  (when (claude-agent-result-message-p msg)
    (let ((sdk-uuid (claude-agent-result-message-session-id msg))
          (marker (claude-org--session-get session-key :marker)))
      (when (and sdk-uuid marker (marker-buffer marker))
        (with-current-buffer (marker-buffer marker)
          (save-excursion
            (goto-char marker)
            (claude-org--set-sdk-uuid sdk-uuid))))))
  ;; Handle special tool uses in assistant messages
  (when (claude-agent-assistant-message-p msg)
    (let ((marker (claude-org--session-get session-key :marker)))
      (when (and marker (marker-buffer marker))
        (dolist (block (claude-agent-assistant-message-content msg))
          (when (claude-agent-tool-use-block-p block)
            (let* ((tool-name (claude-agent-tool-use-block-name block))
                   (tool-input (claude-agent-tool-use-block-input block))
                   (formatted (claude-org--handle-tool-use session-key tool-name tool-input)))
              (when formatted
                (with-current-buffer (marker-buffer marker)
                  (save-excursion
                    (goto-char marker)
                    (insert formatted)
                    (set-marker marker (point)))))))))))
  ;; Display system messages if enabled
  (when (and claude-org-show-system-messages
             (claude-agent-system-message-p msg))
    (let ((marker (claude-org--session-get session-key :marker)))
      (when (and marker (marker-buffer marker))
        (with-current-buffer (marker-buffer marker)
          (save-excursion
            (goto-char marker)
            (insert (format "\n[System: %s]\n"
                            (claude-agent-system-message-subtype msg)))
            (set-marker marker (point))))))))

(defun claude-org--handle-complete (session-key result)
  "Handle query completion for SESSION-KEY with RESULT."
  (claude-org--session-put session-key :busy nil)
  (claude-org--session-put session-key :recovering nil)
  (claude-org--stop-spinner session-key)
  ;; Add newlines after response
  (let ((marker (claude-org--session-get session-key :marker)))
    (when (and marker (marker-buffer marker))
      (with-current-buffer (marker-buffer marker)
        (save-excursion
          (goto-char marker)
          (insert "\n")))))
  ;; Update header line
  (claude-org--refresh-header-line))
#+END_SRC

** Error Handling

#+BEGIN_SRC elisp
(defun claude-org--extract-error-message (error)
  "Extract human-readable message from ERROR.
ERROR can be (symbol :message ...) plist, a string, or other."
  (cond
   ;; CLI error: (claude-agent-cli-error :message "..." ...) - plist starts at cdr
   ((and (listp error) (symbolp (car error)) (plist-get (cdr error) :message))
    (plist-get (cdr error) :message))
   ;; Plain plist with :message
   ((and (listp error) (plist-get error :message))
    (plist-get error :message))
   ;; String error
   ((stringp error) error)
   ;; Fallback: convert to string
   (t (format "%s" error))))

(defun claude-org--handle-error (session-key error)
  "Handle error ERROR for SESSION-KEY.
Attempts session recovery if error indicates expired session or context too long."
  (let ((error-msg (claude-org--extract-error-message error)))
    (cond
     ;; Context too long - clear UUID and recover with conversation history
     ((and (claude-agent--context-too-long-p error-msg)
           (not (claude-org--session-get session-key :recovering)))
      (message "Claude context limit reached, starting fresh session with history...")
      (claude-org--recover-session session-key 'context-limit))
     ;; Session expired - clear UUID and recover
     ((and (claude-agent--session-expired-p error-msg)
           (not (claude-org--session-get session-key :recovering)))
      (message "Claude session expired, starting new session...")
      (claude-org--recover-session session-key 'expired))
     ;; Other error - display it
     (t
      (claude-org--insert-error session-key error-msg)))))

(defun claude-org--insert-error (session-key error-msg)
  "Insert ERROR-MSG at SESSION-KEY's marker and clean up."
  (claude-org--session-put session-key :busy nil)
  (claude-org--stop-spinner session-key)
  (let ((marker (claude-org--session-get session-key :marker)))
    (when (and marker (marker-buffer marker))
      (with-current-buffer (marker-buffer marker)
        (save-excursion
          (goto-char marker)
          (insert (format "\n[Error: %s]\n" error-msg))
          (set-marker marker (point))))))
  (claude-org--refresh-header-line))
#+END_SRC

* Execution

Execution and request handling.

** Execute Command

#+BEGIN_SRC elisp
(defun claude-org-execute ()
  "Execute the AI query at point.
Must be called when point is inside a #+begin_src ai block.
Sends the query to Claude and streams the response below the block.
When `claude-org-auto-create-response-section' is non-nil, creates a Response
section with :ai_output: tag for flat pattern organization."
  (interactive)
  (unless (claude-org--in-ai-block-p)
    (user-error "Not inside an ai block. Use #+begin_src ai ... #+end_src"))
  (let* ((content (claude-org--get-block-content))
         (session-key (claude-org--current-session-key)))
    (unless content
      (user-error "Empty ai block"))
    (when (claude-org--session-get session-key :busy)
      (user-error "Session is busy. Use C-c C-k to cancel or wait for completion"))
    ;; Find insertion point (after #+end_src)
    (let ((insert-point (claude-org--find-block-end))
          (instr-num (claude-org--find-instruction-number)))
      (unless insert-point
        (user-error "Cannot find block end"))
      ;; Set up marker at insertion point
      (save-excursion
        (goto-char insert-point)
        (insert "\n\n")
        ;; Create Response section if enabled and we found an instruction number
        (when (and claude-org-auto-create-response-section instr-num)
          (let* ((level (claude-org--get-section-level))
                 (stars (make-string level ?*)))
            (insert stars " Response " (number-to-string instr-num)
                    " :" claude-org-output-tag ":\n\n")))
        (let ((marker (point-marker)))
          (claude-org--session-put session-key :marker marker)
          (claude-org--session-put session-key :original-prompt content)
          (claude-org--session-put session-key :section-level (claude-org--get-section-level))
          (claude-org--session-put session-key :start-time (float-time))
          (claude-org--session-put session-key :busy t)))
      ;; Start spinner and send request
      (claude-org--start-spinner session-key)
      (claude-org--send-request content))))

(defun org-babel-execute:ai (body _params)
  "Execute an AI block via claude-org.
BODY is the query text, PARAMS are org-babel header arguments.
This integrates with org-babel's C-c C-c execution mechanism."
  (claude-org-execute)
  ;; Return nil - output is streamed directly into buffer
  nil)
#+END_SRC

** Send Request Helpers

#+BEGIN_SRC elisp
(defun claude-org--build-ide-context-reminder (project-root)
  "Build IDE context system reminder for PROJECT-ROOT.
Returns nil if IDE context is disabled or unavailable."
  (when claude-org-include-ide-context
    (let ((ide-context (claude-agent-collect-ide-context
                        (or project-root default-directory))))
      (when ide-context
        (claude-agent-build-system-reminder
         :current-file (plist-get ide-context :current-file)
         :open-files (plist-get ide-context :open-files)
         :selection (plist-get ide-context :selection)
         :file-path buffer-file-name
         :cwd (plist-get ide-context :cwd))))))

(defun claude-org--build-query-options (project-root system-prompt sdk-uuid)
  "Build options plist for claude-agent query.
PROJECT-ROOT: Working directory
SYSTEM-PROMPT: System prompt text
SDK-UUID: Session UUID for resume"
  (claude-agent-options
   :cwd (or project-root default-directory)
   :system-prompt system-prompt
   :resume sdk-uuid
   :permission-mode (claude-org--get-permission-mode)
   :allowed-tools claude-org-allowed-tools
   :mcp-config (claude-org--get-mcp-config)
   :setting-sources (claude-org--get-setting-sources)
   :env (claude-org--get-env-vars)))
#+END_SRC

** Send Request

#+BEGIN_SRC elisp
(defun claude-org--send-request (prompt)
  "Send PROMPT to Claude via claude-agent."
  (let* ((session-key (claude-org--current-session-key))
         (sdk-uuid (claude-org--get-sdk-uuid))
         (project-root (claude-org--get-project-root))
         (system-prompt (claude-org--build-system-prompt))
         ;; Build IDE context reminder and query options using helpers
         (system-reminder (claude-org--build-ide-context-reminder project-root))
         (options (claude-org--build-query-options project-root system-prompt sdk-uuid))
         ;; Build full prompt with system reminder
         (full-prompt (if (and system-reminder
                               (not (string-empty-p system-reminder)))
                          (concat system-reminder "\n" prompt)
                        prompt)))
    ;; Use lexical-let to properly capture variables for callbacks
    (lexical-let ((buf (current-buffer))
                  (session-key session-key))
      ;; Send query via claude-agent
      (let ((state (claude-agent-query
                    full-prompt
                    :options options
                    :session-key session-key
                    :on-token (lambda (text)
                                (when (buffer-live-p buf)
                                  (with-current-buffer buf
                                    (claude-org--handle-token session-key text))))
                    :on-message (lambda (msg)
                                  (when (buffer-live-p buf)
                                    (with-current-buffer buf
                                      (claude-org--handle-message session-key msg))))
                    :on-error (lambda (err)
                                (when (buffer-live-p buf)
                                  (with-current-buffer buf
                                    (claude-org--handle-error session-key err))))
                    :on-complete (lambda (result)
                                   (when (buffer-live-p buf)
                                     (with-current-buffer buf
                                       (claude-org--handle-complete session-key result)))))))
        ;; Store process state for cancellation
        (claude-org--session-put session-key :process-state state)))))
#+END_SRC

* Header Line

Dynamic header line showing session status, IDE context, and thinking state.

** State Variables

#+BEGIN_SRC elisp
(defvar-local claude-org--original-header-line nil
  "Original header-line-format before enabling claude-org-mode.")

(defvar-local claude-org--original-truncate-lines nil
  "Original truncate-lines value before enabling claude-org-mode.")

(defconst claude-org--spinner-frames '("|" "/" "-" "\\")
  "Frames for the busy spinner animation.")

(defvar claude-org--header-timer nil
  "Timer for refreshing header line across all claude-org buffers.")

(defvar claude-org--session-badge-map
  (let ((map (make-sparse-keymap)))
    (define-key map [header-line mouse-1] #'claude-org-list-sessions)
    map)
  "Keymap for clicking on the session badge in the header line.")
#+END_SRC

** Spinner Control

#+BEGIN_SRC elisp
(defun claude-org--start-spinner (session-key)
  "Start spinner animation for SESSION-KEY."
  (claude-org--session-put session-key :spinner 0)
  (claude-org--ensure-header-timer))

(defun claude-org--stop-spinner (session-key)
  "Stop spinner animation for SESSION-KEY."
  (claude-org--session-put session-key :spinner nil))
#+END_SRC

** Timer Management

#+BEGIN_SRC elisp
(defun claude-org--ensure-header-timer ()
  "Ensure header refresh timer is running."
  (unless (and claude-org--header-timer
               (timerp claude-org--header-timer))
    (setq claude-org--header-timer
          (run-at-time 0.2 0.2 #'claude-org--refresh-all-headers))))

(defun claude-org--stop-header-timer ()
  "Stop header refresh timer if no active sessions."
  (when (and claude-org--header-timer
             (zerop (claude-org--active-session-count)))
    (cancel-timer claude-org--header-timer)
    (setq claude-org--header-timer nil)))

(defun claude-org--refresh-all-headers ()
  "Refresh header line in all claude-org buffers."
  (dolist (buf (buffer-list))
    (when (buffer-live-p buf)
      (with-current-buffer buf
        (when (bound-and-true-p claude-org-mode)
          (claude-org--refresh-header-line)
          ;; Advance spinner for busy sessions (guard against nil hash table)
          (when (hash-table-p claude-org--sessions)
            (maphash (lambda (key state)
                       (when (plist-get state :busy)
                         (let* ((frame (or (plist-get state :spinner) 0))
                                (next-frame (mod (1+ frame) 4)))
                           (plist-put state :spinner next-frame))))
                     claude-org--sessions)))))))

(defun claude-org--refresh-header-line ()
  "Refresh the header line with current session status."
  (setq header-line-format (claude-org--header-line))
  (force-mode-line-update))
#+END_SRC

** Tooltip Formatting

#+BEGIN_SRC elisp
(defun claude-org--format-session-tooltip ()
  "Format tooltip showing all active sessions."
  (let ((lines (list "Active Sessions" "")))
    (maphash
     (lambda (id state)
       (when (plist-get state :busy)
         (let* ((spinner-idx (or (plist-get state :spinner) 0))
                (spinner-char (nth spinner-idx claude-org--spinner-frames))
                (display-name (claude-org--session-display-name id))
                (elapsed (claude-org--format-elapsed (plist-get state :start-time))))
           (push (format " %s  [%s %s]" display-name spinner-char elapsed)
                 lines))))
     claude-org--sessions)
    (if (= (length lines) 2)
        "No active sessions\n\nClick to open session manager"
      (concat (string-join (nreverse lines) "\n")
              "\n\nClick to open session manager"))))
#+END_SRC

** Header Line Generation

#+BEGIN_SRC elisp
(defun claude-org--header-line ()
  "Generate the header line content for Claude Org buffer."
  (let* ((file-name (if buffer-file-name
                        (file-name-nondirectory buffer-file-name)
                      "untitled"))
         ;; Show user-defined session ID if present
         (session-id (claude-org--get-session-id))
         (session-scope (claude-org--get-session-scope))
         ;; Display: [sec:mysession] or [file:mysession] or [file-only]
         (session-str (if session-id
                          (propertize (format " [%s:%s...]"
                                              (if (eq session-scope 'section) "sec" "file")
                                              (substring session-id 0 (min 12 (length session-id))))
                                      'face (if (eq session-scope 'section)
                                                'font-lock-constant-face
                                              'font-lock-type-face))
                        (propertize " [file-only]" 'face 'font-lock-comment-face)))
         ;; Permission mode indicator
         (perm-str (propertize (format " [%s]" (claude-org--permission-mode-short))
                               'face 'font-lock-warning-face
                               'help-echo (format "Permission: %s (C-c C-p to change)"
                                                  (claude-org--get-permission-mode-display))))
         ;; Active session count badge with thinking indicator
         (active-count (claude-org--active-session-count))
         (active-str (if (> active-count 0)
                         (propertize (format " [%d thinking...]" active-count)
                                     'face '(:foreground "orange" :weight bold)
                                     'help-echo (claude-org--format-session-tooltip)
                                     'mouse-face 'mode-line-highlight
                                     'local-map claude-org--session-badge-map)
                       ""))
         ;; Project root
         (project-root (claude-org--get-project-root))
         (project-str (if project-root
                          (propertize (format " [%s]"
                                              (file-name-nondirectory
                                               (directory-file-name project-root)))
                                      'face 'font-lock-keyword-face)
                        ""))
         ;; Current open file (from IDE context)
         (ide-context (claude-agent-collect-ide-context))
         (current-file (plist-get ide-context :current-file))
         (file-str (if current-file
                       (propertize (format " | %s%s"
                                           (or (plist-get current-file :name) "?")
                                           (if (plist-get current-file :modified) "*" ""))
                                   'face 'font-lock-string-face)
                     ""))
         ;; Selection info
         (selection (plist-get ide-context :selection))
         (sel-str (if (and selection (plist-get selection :text))
                      (let* ((start-line (plist-get selection :start-line))
                             (end-line (plist-get selection :end-line))
                             (text-len (length (plist-get selection :text))))
                        (propertize (format " | sel:%d-%d (%d)" start-line end-line text-len)
                                    'face 'font-lock-comment-face))
                    "")))
    (concat " Claude Org: "
            (propertize file-name 'face 'font-lock-function-name-face)
            session-str perm-str active-str project-str file-str sel-str)))
#+END_SRC

* Cancel Support

#+BEGIN_SRC elisp
(defun claude-org-cancel ()
  "Cancel the current session's active query."
  (interactive)
  (let* ((session-key (claude-org--current-session-key))
         (process-state (claude-org--session-get session-key :process-state)))
    (if (and process-state (claude-org--session-get session-key :busy))
        (progn
          (claude-agent-query-interrupt process-state)
          (claude-org--session-put session-key :busy nil)
          (claude-org--stop-spinner session-key)
          (let ((marker (claude-org--session-get session-key :marker)))
            (when (and marker (marker-buffer marker))
              (with-current-buffer (marker-buffer marker)
                (save-excursion
                  (goto-char marker)
                  (insert "\n[Cancelled]\n")))))
          (claude-org--refresh-header-line)
          (message "Query cancelled"))
      (message "No active query to cancel"))))

(defun claude-org-cancel-all ()
  "Cancel all active queries in this buffer."
  (interactive)
  (let ((cancelled 0))
    (maphash (lambda (key state)
               (when (plist-get state :busy)
                 (let ((process-state (plist-get state :process-state)))
                   (when process-state
                     (claude-agent-query-interrupt process-state)
                     (plist-put state :busy nil)
                     (cl-incf cancelled)))))
             claude-org--sessions)
    (claude-org--refresh-header-line)
    (message "Cancelled %d queries" cancelled)))
#+END_SRC

* Verbose Output

#+BEGIN_SRC elisp
(defun claude-org-show-verbose ()
  "Show verbose output buffer for current session."
  (interactive)
  (let ((session-key (claude-org--current-session-key)))
    (if-let ((buf (gethash session-key claude-agent--session-verbose-buffers)))
        (if (buffer-live-p buf)
            (display-buffer buf)
          (message "Verbose buffer no longer exists"))
      (message "No verbose buffer for session: %s" session-key))))
#+END_SRC

* Session Manager UI

#+BEGIN_SRC elisp
(defun claude-org-list-sessions ()
  "Display a list of all sessions in this buffer."
  (interactive)
  (let ((sessions '()))
    (maphash (lambda (key state)
               (push (list key
                           (if (plist-get state :busy) "busy" "idle")
                           (claude-org--format-elapsed (plist-get state :start-time)))
                     sessions))
             claude-org--sessions)
    (if sessions
        (with-output-to-temp-buffer "*Claude Org Sessions*"
          (princ "Claude Org Sessions\n")
          (princ "==================\n\n")
          (dolist (session (nreverse sessions))
            (princ (format "%-40s  %-6s  %s\n"
                           (claude-org--session-display-name (nth 0 session))
                           (nth 1 session)
                           (nth 2 session)))))
      (message "No sessions in this buffer"))))
#+END_SRC

* Mode Definition

** Keymap

#+BEGIN_SRC elisp
(defvar claude-org-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-c C-c") #'claude-org-maybe-execute)
    (define-key map (kbd "C-c C-k") #'claude-org-cancel)
    (define-key map (kbd "C-c C-l") #'claude-org-list-sessions)
    (define-key map (kbd "C-c C-n") #'claude-org-insert-block)
    (define-key map (kbd "C-c C-s") #'claude-org-insert-story)
    (define-key map (kbd "C-c C-i") #'claude-org-show-session-info)
    (define-key map (kbd "C-c C-v") #'claude-org-show-verbose)
    (define-key map (kbd "C-c C-p") #'claude-org-switch-permission-mode)
    map)
  "Keymap for `claude-org-mode'.")

(defun claude-org-maybe-execute ()
  "Execute AI query if in ai block, otherwise run org default."
  (interactive)
  (if (claude-org--in-ai-block-p)
      (claude-org-execute)
    ;; Fall back to org-mode's C-c C-c
    (org-ctrl-c-ctrl-c)))
#+END_SRC

** Minor Mode

#+BEGIN_SRC elisp
(defun claude-org--register-exclusion ()
  "Register claude-org buffers as excluded from IDE context."
  (add-to-list 'claude-agent-ide-context-exclude-predicates
               (lambda (buf)
                 (with-current-buffer buf
                   (bound-and-true-p claude-org-mode)))))

;;;###autoload
(define-minor-mode claude-org-mode
  "Minor mode for streaming Claude AI queries in org-mode.

Use #+begin_src ai blocks to query Claude. Press C-c C-c inside a block
to send the query and stream the response.

\\{claude-org-mode-map}"
  :lighter " ClaudeOrg"
  :keymap claude-org-mode-map
  :group 'claude-org
  (if claude-org-mode
      (progn
        ;; Save original header line
        (setq claude-org--original-header-line header-line-format)
        ;; Save and disable line truncation (so long lines wrap)
        (setq claude-org--original-truncate-lines truncate-lines)
        (setq truncate-lines nil)
        ;; Set up header line
        (claude-org--refresh-header-line)
        ;; Register exclusion
        (claude-org--register-exclusion)
        ;; Auto-start MCP server
        (claude-org--ensure-mcp-server)
        ;; Install org file protection hook (prevents Edit/Write on .org files)
        (claude-org--install-protection-hook)
        ;; Add company backend for slash commands (buffer-local, high priority)
        (when (boundp 'company-backends)
          (set (make-local-variable 'company-backends)
               (cons 'claude-org-company-slash-commands
                     (if (listp company-backends)
                         company-backends
                       (list company-backends))))))
    ;; Restore original header line
    (setq header-line-format claude-org--original-header-line)
    ;; Restore original truncate-lines
    (setq truncate-lines claude-org--original-truncate-lines)
    ;; Cancel any active queries
    (claude-org-cancel-all)
    ;; Remove org file protection hook
    (claude-org--remove-protection-hook)
    ;; Stop header timer if no more claude-org buffers
    (claude-org--stop-header-timer)
    ;; Company backends will be cleaned up automatically (buffer-local)
    ))

;;;###autoload
(defun claude-org-cleanup ()
  "Clean up claude-org resources."
  (interactive)
  (claude-org-cancel-all)
  (clrhash claude-org--sessions))
#+END_SRC

* Tests

#+BEGIN_SRC elisp :load test
(require 'ert)

(ert-deftest claude-org-test-session-key-creation ()
  "Test session key creation from file path and session ID."
  (let ((buffer-file-name "/path/to/file.org"))
    ;; Without custom session ID
    (cl-letf (((symbol-function 'claude-org--get-session-id) (lambda () nil)))
      (should (equal "/path/to/file.org" (claude-org--current-session-key))))
    ;; With custom session ID
    (cl-letf (((symbol-function 'claude-org--get-session-id) (lambda () "my-session")))
      (should (equal "/path/to/file.org::my-session" (claude-org--current-session-key))))))

(ert-deftest claude-org-test-session-display-name ()
  "Test session display name extraction."
  (should (equal "my-session"
                 (claude-org--session-display-name "/path/to/file.org::my-session")))
  (should (equal "file.org"
                 (claude-org--session-display-name "/path/to/file.org"))))

(ert-deftest claude-org-test-session-state-accessors ()
  "Test session state put/get operations."
  (let ((claude-org--sessions (make-hash-table :test 'equal)))
    (claude-org--session-put "test-key" :foo "bar")
    (should (equal "bar" (claude-org--session-get "test-key" :foo)))
    (claude-org--session-put "test-key" :busy t)
    (should (equal t (claude-org--session-get "test-key" :busy)))))

(ert-deftest claude-org-test-active-session-count ()
  "Test active session counting."
  (let ((claude-org--sessions (make-hash-table :test 'equal)))
    (should (= 0 (claude-org--active-session-count)))
    (claude-org--session-put "session-1" :busy t)
    (should (= 1 (claude-org--active-session-count)))
    (claude-org--session-put "session-2" :busy t)
    (should (= 2 (claude-org--active-session-count)))
    (claude-org--session-put "session-1" :busy nil)
    (should (= 1 (claude-org--active-session-count)))))

(ert-deftest claude-org-test-format-elapsed ()
  "Test elapsed time formatting."
  (should (equal "unknown" (claude-org--format-elapsed nil)))
  (should (string-match-p "started [0-9]+ seconds ago"
                          (claude-org--format-elapsed (- (float-time) 30))))
  (should (string-match-p "started [0-9]+ minutes ago"
                          (claude-org--format-elapsed (- (float-time) 120)))))

(ert-deftest claude-org-test-normalize-headers-in-text ()
  "Test org header normalization with regex replacement."
  (let ((claude-org-normalize-headers t))
    ;; Simple case: single header
    (should (equal "**** Top\n" (claude-org--normalize-headers-in-text "* Top\n" 4)))
    ;; Multiple headers
    (should (equal "**** Top\n***** Sub\n"
                   (claude-org--normalize-headers-in-text "* Top\n** Sub\n" 4)))
    ;; Mixed content
    (should (equal "Hello\n**** Head\nText\n"
                   (claude-org--normalize-headers-in-text "Hello\n* Head\nText\n" 4)))
    ;; Non-headers unchanged
    (should (equal "  * not at start\n"
                   (claude-org--normalize-headers-in-text "  * not at start\n" 4)))
    (should (equal "*no space after\n"
                   (claude-org--normalize-headers-in-text "*no space after\n" 4)))
    ;; Empty string
    (should (equal "" (claude-org--normalize-headers-in-text "" 4)))
    ;; No newline - still works
    (should (equal "**** Header" (claude-org--normalize-headers-in-text "* Header" 4)))))

(ert-deftest claude-org-test-normalize-headers-disabled ()
  "Test that normalization can be disabled."
  (let ((claude-org-normalize-headers nil))
    (should (equal "* Top\n" (claude-org--normalize-headers-in-text "* Top\n" 4)))))

(ert-deftest claude-org-test-normalize-headers-streaming ()
  "Test header normalization with streaming tokens."
  (let ((claude-org-normalize-headers t)
        (output ""))
    ;; Simulate streaming - each token is processed independently
    (dolist (token '("Here is " "the ans" "wer:\n" "* Sum" "mary\n" "Text\n"))
      (setq output (concat output (claude-org--normalize-headers-in-text token 4))))
    (should (equal "Here is the answer:\n**** Summary\nText\n" output))))
#+END_SRC

* Org File Protection Hook

Prevent Claude from using Edit/Write tools on .org files. Claude should use
Emacs MCP org_* tools instead for proper org structure handling.

#+BEGIN_SRC elisp
(defun claude-org--protect-org-files (input-data tool-use-id context)
  "Hook to prevent Edit/Write tools on .org files.

INPUT-DATA: plist with :tool_name and :tool_input
TOOL-USE-ID: string ID (may be nil)
CONTEXT: plist with :signal

Returns nil to allow, or a hook output plist to deny with error message."
  (let* ((tool-name (plist-get input-data :tool_name))
         (tool-input (plist-get input-data :tool_input))
         (file-path (plist-get tool-input :file_path)))
    (when (and (member tool-name '("Edit" "Write"))
               file-path
               (string-match-p "\\.org$" file-path))
      ;; Deny with helpful error message
      (list :reason "Org files require Emacs MCP tools for proper structure handling"
            :systemMessage
            (concat " Cannot use " tool-name " on .org files.\n\n"
                    "Use Emacs MCP tools instead:\n"
                    "- mcp__emacs__org_read_section - Read section by path\n"
                    "- mcp__emacs__org_update_section - Update section content\n"
                    "- mcp__emacs__org_create_section - Create new subsection\n"
                    "- mcp__emacs__org_delete_section - Delete section\n"
                    "- mcp__emacs__org_set_property - Set property value\n"
                    "- mcp__emacs__org_set_tags - Set section tags\n\n"
                    "These tools preserve org structure and work with Emacs directly.")
            :hookSpecificOutput
            (list :hookEventName "PreToolUse"
                  :permissionDecision "deny"
                  :permissionDecisionReason
                  (format "Use Emacs MCP org_* tools for %s" file-path))))))

(defun claude-org--install-protection-hook ()
  "Install the org file protection hook globally.
The hook must be global because it runs in process filter context,
not in the org buffer where the query originated."
  (add-hook 'claude-agent-pre-tool-use-hook
            #'claude-org--protect-org-files))

(defun claude-org--remove-protection-hook ()
  "Remove the org file protection hook if no claude-org buffers remain."
  ;; Only remove if no other claude-org-mode buffers exist
  (unless (cl-some (lambda (buf)
                     (and (not (eq buf (current-buffer)))
                          (buffer-live-p buf)
                          (with-current-buffer buf
                            claude-org-mode)))
                   (buffer-list))
    (remove-hook 'claude-agent-pre-tool-use-hook
                 #'claude-org--protect-org-files)))
#+END_SRC

* Package Footer

#+BEGIN_SRC elisp
(provide 'claude-org)
;;; claude-org.el ends here
#+END_SRC
