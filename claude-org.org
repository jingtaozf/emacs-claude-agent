# -*- encoding:utf-8 Mode: POLY-ORG; org-src-preserve-indentation: t; -*-
#+TITLE: Claude Org Integration
#+SUBTITLE: Org-mode integration for Claude Agent SDK
#+AUTHOR: Jingtao Xu
#+OPTIONS: toc:2
#+Startup: noindent
#+PROPERTY: header-args :results silent
#+PROPERTY: literate-lang elisp
#+PROPERTY: literate-load yes
#+TAGS: explore(e) plan(p) code(c) test(t) review(r) commit(m)
#+TAGS: strict(s) security(S) no_edit(n) parallel(P)

* Table of Contents                                            :TOC:noexport:
- [[#introduction][Introduction]]
- [[#dependencies][Dependencies]]
- [[#customization][Customization]]
- [[#session-management][Session Management]]
  - [[#session-id-functions][Session ID Functions]]
  - [[#session-scope-detection][Session Scope Detection]]
  - [[#session-recovery][Session Recovery]]
- [[#project-configuration][Project Configuration]]
  - [[#project-root][PROJECT_ROOT]]
  - [[#system-prompts][System Prompts]]
- [[#process-management][Process Management]]
  - [[#state-variables][State Variables]]
  - [[#session-state-accessors][Session State Accessors]]
- [[#block-detection][Block Detection]]
- [[#block-insertion][Block Insertion]]
- [[#slash-command-completion][Slash Command Completion]]
  - [[#command-discovery][Command Discovery]]
  - [[#company-backend][Company Backend]]
- [[#response-handling][Response Handling]]
  - [[#debounced-font-lock][Debounced Font-Lock]]
  - [[#token-handling][Token Handling]]
  - [[#message-handling][Message Handling]]
  - [[#error-handling][Error Handling]]
- [[#execution][Execution]]
  - [[#execute-command][Execute Command]]
  - [[#send-request][Send Request]]
- [[#header-line][Header Line]]
- [[#cancel-support][Cancel Support]]
- [[#session-manager-ui][Session Manager UI]]
- [[#mode-definition][Mode Definition]]
  - [[#keymap][Keymap]]
  - [[#minor-mode][Minor Mode]]
- [[#tests][Tests]]
- [[#package-footer][Package Footer]]

* Introduction

Claude Org Integration is a minor mode for org-mode that enables interactive
streaming AI queries directly within org files using ~#+begin_src ai~ blocks.

This package depends on ~claude-agent~ for Claude communication and provides
org-specific features on top of it.

** Features

- *Token-by-token streaming*: Responses stream token-by-token with debounced
  font-lock for smooth rendering.

- *Multi-session support*: Multiple queries with different CLAUDE_SESSION_ID
  values can run concurrently.

- *Session recovery*: When backend sessions expire, context is collected from
  the org file and rebuilt automatically.

- *Project support*: PROJECT_ROOT property sets cwd; :system_prompt: tagged
  sections provide project guidelines.

** Usage Example

#+BEGIN_SRC org :load no
,#+PROPERTY: PROJECT_ROOT /path/to/project

,* Project Guidelines :system_prompt:
This project uses Python 3.11.
Always use absolute imports.

,* Tasks

,** Instruction 1 :claude_chat:

,#+begin_src ai
How do I read a JSON file in Python?
,#+end_src

Response will appear here after pressing C-c C-c inside the ai block.
#+END_SRC

* Dependencies

#+BEGIN_SRC elisp
;;; claude-org.el --- Org-mode integration for Claude Agent SDK -*- lexical-binding: t; -*-

;; Copyright (C) 2024 Jingtao Xu

;; Author: Jingtao Xu
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1") (claude-agent "0.1.0"))
;; Keywords: tools, org, ai
;; URL: https://github.com/user/claude-agent

;; This file is not part of GNU Emacs.

;;; Commentary:

;; Claude Org Integration - Streaming AI queries in org-mode.
;; Use #+begin_src ai blocks to query Claude with C-c C-c.

;;; Code:

(require 'claude-agent)
(require 'org)
(require 'cl-lib)
(require 'cl)  ; For lexical-let in callback closures
#+END_SRC

* Customization

User-configurable options for claude-org. These control how AI blocks are
processed, how responses are displayed, and what behaviors are triggered.

** Customization Group

The defgroup establishes the =claude-org= customization namespace.

#+NAME: custom-group
#+BEGIN_SRC elisp
(defgroup claude-org nil
  "Streaming Claude AI for org-mode."
  :group 'org
  :prefix "claude-org-")
#+END_SRC

** Tag Names

These define the org tags used to mark different types of sections.
Customize these if you prefer different naming conventions.

| Tag | Purpose |
|-----+---------|
| =claude_chat= | Marks instruction headings |
| =claude_session= | Creates isolated session scope |
| =ai_output= | Marks Claude's response sections |

#+NAME: custom-tags
#+BEGIN_SRC elisp
(defcustom claude-org-heading-tag "claude_chat"
  "Default tag for claude chat headings."
  :type 'string
  :group 'claude-org)

(defcustom claude-org-session-tag "claude_session"
  "Tag that marks a section as having independent session scope."
  :type 'string
  :group 'claude-org)

(defcustom claude-org-output-tag "ai_output"
  "Tag for AI output sections in flat pattern.
Used to mark sections containing Claude's responses."
  :type 'string
  :group 'claude-org)
#+END_SRC

** Display Settings

Options controlling how Claude's output appears in the buffer:
- Font-lock delay balances responsiveness vs. performance during streaming
- Line width constrains output for readability
- Header normalization ensures responses fit document hierarchy
- Auto-break splits long lines at sentence boundaries

#+NAME: custom-display
#+BEGIN_SRC elisp
(defcustom claude-org-fontlock-delay 0.05
  "Delay in seconds before font-lock after token insertion.
Lower = more responsive, higher = better performance."
  :type 'number
  :group 'claude-org)

(defcustom claude-org-line-width 170
  "Maximum line width for Claude's output.
Claude will be instructed to keep lines under this many characters."
  :type 'integer
  :group 'claude-org)

(defcustom claude-org-normalize-headers t
  "When non-nil, normalize org headers in Claude's output.
Headers are adjusted so top-level headers match the current section level + 1.
This ensures Claude's output fits properly within the document hierarchy."
  :type 'boolean
  :group 'claude-org)

(defcustom claude-org-auto-break-line-length -1
  "Auto-break lines exceeding this length after sentence-ending punctuation.
When set to a positive integer, lines longer than this will be broken
after sentence-ending punctuation (. ! ?) followed by a space.
Set to -1 (default) to disable automatic line breaking."
  :type 'integer
  :group 'claude-org)
#+END_SRC

** Execution Behavior

Options controlling what happens when AI blocks are executed:
- Auto-create response sections for the flat Instruction/Response pattern
- IDE context adds buffer info, selection, and open files to prompts
- System messages toggle shows/hides Claude's internal messages
- Allowed tools auto-approve certain operations without confirmation

#+NAME: custom-execution
#+BEGIN_SRC elisp
(defcustom claude-org-auto-create-response-section t
  "Whether to automatically create Response sections after executing AI blocks.
When non-nil, claude-org-execute will create a Response heading with :ai_output: tag."
  :type 'boolean
  :group 'claude-org)

(defcustom claude-org-include-ide-context t
  "Whether to include IDE context (current file, open files, selection) in prompts.
When non-nil, a <system-reminder> tag with context is prepended to each message."
  :type 'boolean
  :group 'claude-org)

(defcustom claude-org-show-system-messages nil
  "Whether to display system messages in the response."
  :type 'boolean
  :group 'claude-org)

(defcustom claude-org-allowed-tools '("Read" "Glob" "Grep" "WebFetch" "WebSearch")
  "List of tool patterns to auto-approve.
These tools will not require user approval regardless of permission mode.
Useful for allowing read operations in plan mode.
Pattern syntax: \"ToolName\" or \"ToolName(pattern)\" e.g. \"Bash(git *)\"."
  :type '(repeat string)
  :group 'claude-org)

(defcustom claude-org-auto-start-mcp-server t
  "Whether to auto-start MCP server when claude-org-mode is enabled.
When non-nil, the MCP server will be started automatically if not running."
  :type 'boolean
  :group 'claude-org)

(defcustom claude-org-setting-sources '("user")
  "List of setting sources for Claude CLI.
Controls where Claude loads skills and settings from.
Valid values: \"user\", \"project\", \"local\".

Can be overridden per-section via CLAUDE_SETTING_SOURCES property."
  :type '(repeat string)
  :group 'claude-org)

(defcustom claude-org-auto-generate-title t
  "Whether to auto-generate titles for AI blocks with generic headings.
When non-nil, headings matching `claude-org-auto-title-heading-pattern'
(e.g., \"Instruction 1\") will be replaced with AI-generated titles
using the Haiku model in parallel with the main query."
  :type 'boolean
  :group 'claude-org)

(defcustom claude-org-auto-title-heading-pattern "^Instruction [0-9]+$"
  "Regexp pattern for headings that should be auto-titled.
Only headings matching this pattern will have their titles replaced.
Default matches \"Instruction 1\", \"Instruction 2\", etc."
  :type 'regexp
  :group 'claude-org)
#+END_SRC

** Execution Hooks

Hooks that run at key points during AI block execution, enabling extensions
like block history tracking without modifying core code.

#+NAME: custom-hooks
#+BEGIN_SRC elisp
(defvar claude-org-execute-hook nil
  "Hook run before AI block execution begins.
Functions receive (SESSION-KEY QUERY MARKER).
Run after validation but before any buffer modifications.")

(defvar claude-org-execute-after-hook nil
  "Hook run after AI block execution starts (query sent).
Functions receive (SESSION-KEY QUERY MARKER).
Default: includes `claude-org--record-block-execution'.")

(defvar claude-org-complete-hook nil
  "Hook run when AI block execution completes or errors.
Functions receive (SESSION-KEY RESULT STATUS).
STATUS is symbol: `completed' or `error'.
Default: includes `claude-org--update-block-status'.")
#+END_SRC

** Block History

Persistent tracking of executed AI blocks, enabling quick navigation to
recent blocks across Emacs sessions.

*** Configuration

#+NAME: history-config
#+BEGIN_SRC elisp
(defcustom claude-org-history-directory
  (expand-file-name "claude-org" user-emacs-directory)
  "Directory for persistent block history files.
Each org file gets its own history file named <basename>--<hash>.el."
  :type 'directory
  :group 'claude-org)

(defcustom claude-org-history-max-entries 100
  "Maximum number of block entries to keep per org file."
  :type 'integer
  :group 'claude-org)

(defconst claude-org--history-save-delay 2.0
  "Seconds to wait before saving history after changes.")
#+END_SRC

*** State Variables

#+NAME: history-state
#+BEGIN_SRC elisp
(defvar-local claude-org--block-history nil
  "In-memory cache of block history for current buffer.
Alist of (BLOCK-ID . PLIST) where PLIST contains:
  :timestamp  - float-time of execution start
  :status     - symbol: `in-progress', `completed', `error'
  :title      - string heading text
  :line       - integer line number
  :marker     - marker (transient, not persisted)")

(defvar-local claude-org--history-loaded nil
  "Non-nil if history has been loaded from disk for this buffer.")

(defvar claude-org--history-save-timer nil
  "Debounce timer for saving history to disk.")
#+END_SRC

** Slash Commands

Built-in CLI commands that can be used in AI blocks. These are passed
directly to Claude Code rather than being interpreted as user prompts.

#+NAME: custom-slash-commands
#+BEGIN_SRC elisp
(defcustom claude-org-builtin-slash-commands
  '("/add-dir" "/clear" "/compact" "/content" "/help" "/ls" "/pwd" "/cd")
  "Built-in Claude Code slash commands.
These are embedded commands in the Claude Code CLI."
  :type '(repeat string)
  :group 'claude-org)
#+END_SRC

** File-Based Prompt Templates

Prompt templates are stored as org files under =docs/prompts/= for easier
editing and hot-reloading. Changes to template files take effect immediately
without restarting Emacs or reloading code.

Directory structure:
#+begin_example
docs/prompts/
├── system/          # System prompts (loaded in sorted order)
│   ├── 00-base.org  # Core org-mode instructions
│   └── 10-links.org # Link resolution prompt
├── tags/            # Tag-based behaviors (one file per tag)
│   ├── explore.org, plan.org, code.org, test.org, review.org, commit.org
│   └── strict.org, security.org, no_edit.org, parallel.org
└── headers/         # Header argument behaviors
    ├── phase/       # Enum-style (subdirectory with value files)
    └── *.org        # Template files (tests.org, coverage.org, etc.)
#+end_example

*** Prompts Directory Configuration

#+NAME: custom-prompts-directory
#+BEGIN_SRC elisp
(defcustom claude-org-prompts-directory
  (expand-file-name "docs/prompts"
                    (file-name-directory (or load-file-name
                                             (locate-library "claude-org")
                                             buffer-file-name
                                             default-directory)))
  "Directory containing prompt template files.
Templates are loaded at runtime, so changes take effect immediately.

Structure:
  system/  - System prompts loaded in sorted order
  tags/    - Tag behavior prompts (TAG.org)
  headers/ - Header argument prompts (HEADER.org or HEADER/VALUE.org)"
  :type 'directory
  :group 'claude-org)
#+END_SRC

*** Prompt File Loader

#+NAME: prompt-file-loader
#+BEGIN_SRC elisp
(defun claude-org--load-prompt-file (file)
  "Load prompt content from FILE.
Returns file content as trimmed string, or nil if file doesn't exist."
  (when (file-readable-p file)
    (with-temp-buffer
      (insert-file-contents file)
      (string-trim (buffer-string)))))

(defun claude-org--load-system-prompts ()
  "Load all system prompts from system/ directory.
Files are loaded in sorted order (use numeric prefix for ordering).
Returns list of prompt strings."
  (let ((dir (expand-file-name "system" claude-org-prompts-directory)))
    (when (file-directory-p dir)
      (let ((files (directory-files dir t "\\.org\\'" t)))
        (delq nil (mapcar #'claude-org--load-prompt-file (sort files #'string<)))))))
#+END_SRC

** Property Name Constants

These constants define the org property names used for session and permission
configuration. Using constants ensures consistency across the codebase.

| Property | Purpose |
|----------+---------|
| =CLAUDE_PERMISSION_MODE= | Tool permission level (readonly/accept-edits/plan/bypass) |
| =CLAUDE_SDK_UUID= | Session identifier for =--resume= |
| =CLAUDE_SETTING_SOURCES= | Comma-separated list of setting sources |

#+NAME: custom-property-constants
#+BEGIN_SRC elisp
(defconst claude-org-permission-property "CLAUDE_PERMISSION_MODE"
  "Org property name for permission mode.")

(defconst claude-org-sdk-uuid-property "CLAUDE_SDK_UUID"
  "Org property name for SDK session UUID (used for --resume).")

(defconst claude-org-setting-sources-property "CLAUDE_SETTING_SOURCES"
  "Org property name for setting sources (comma-separated list).")

(defconst claude-org-env-properties
  '("ANTHROPIC_MODEL" "ANTHROPIC_BASE_URL" "ANTHROPIC_AUTH_TOKEN")
  "List of environment variable org properties to pass to Claude CLI.
These can be set as org properties (file-level or section-level) and will
be passed as environment variables when starting the Claude process.")

(defconst claude-org--permission-mode-map
  '(("readonly"      . (:cli "default"            :short "RO"))
    ("accept-edits"  . (:cli "acceptEdits"        :short "ED"))
    ("plan"          . (:cli "plan"               :short "PL"))
    ("bypass"        . (:cli "bypassPermissions"  :short "BP")))
  "Map permission preset names to CLI values and short display names.
Each entry is (PRESET . (:cli CLI-VALUE :short SHORT-NAME)).")
#+END_SRC

* Session Management

Session identity is determined by file path + optional CLAUDE_SESSION_ID property.

** Helper Functions

File-level properties (=#+ PROPERTY:=) require different lookup logic than
section properties. This function searches only the file header area (before
the first heading) to avoid matching properties inside headings.

#+NAME: session-file-level-property
#+BEGIN_SRC elisp
(defun claude-org--get-file-level-property (property)
  "Get PROPERTY value from file-level #+PROPERTY keyword.
Only searches in the file header area (before first heading).
Returns nil if not found."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      ;; Limit search to before first heading (file header area)
      (let ((limit (save-excursion
                     (if (re-search-forward "^\\*+ " nil t)
                         (line-beginning-position)
                       (point-max)))))
        (when (re-search-forward
               (format "^#\\+PROPERTY:[ \t]+%s[ \t]+\\(.+\\)$"
                       (regexp-quote property))
               limit t)
          (string-trim (match-string-no-properties 1)))))))
#+END_SRC

** Session ID Functions

These functions retrieve and interpret the =CLAUDE_SESSION_ID= property.
Session IDs enable multiple independent conversations within a single org file.

#+NAME: session-id-functions
#+BEGIN_SRC elisp
(defun claude-org--get-session-id ()
  "Get user-defined CLAUDE_SESSION_ID from org properties.
Searches section property drawer first, then file-level #+PROPERTY.
Returns nil if no session ID is defined (file path will be used alone)."
  (save-excursion
    ;; org-entry-get with t enables inheritance up the heading tree
    (org-entry-get nil "CLAUDE_SESSION_ID" t)))

(defun claude-org--get-session-scope ()
  "Determine the scope of the current CLAUDE_SESSION_ID.
Returns `section' if defined in a property drawer, `file' if defined
at file level, or nil if no session ID is defined."
  (save-excursion
    (let ((local-session (org-entry-get nil "CLAUDE_SESSION_ID" nil))
          (inherited-session (org-entry-get nil "CLAUDE_SESSION_ID" t)))
      (cond
       (local-session 'section)
       (inherited-session 'file)
       (t nil)))))

(defun claude-org--current-session-key ()
  "Get the session key for the current context.
Combines file path with optional CLAUDE_SESSION_ID property.
Uses claude-agent session key format for consistency."
  (let ((custom-id (claude-org--get-session-id)))
    (claude-agent--make-session-key buffer-file-name custom-id)))
#+END_SRC

** Session Scope Detection

Session scope determines how conversation context is shared. The =:claude_session:=
tag creates a section-scoped session (isolated subtree). Without it, the whole
file shares one conversation context.

#+NAME: session-scope-detection
#+BEGIN_SRC elisp
(defun claude-org--has-session-tag-p ()
  "Check if current section has the session tag.
Returns non-nil if current heading has :claude_session: tag."
  (save-excursion
    (when (org-at-heading-p)
      (let ((tags (org-get-tags nil t)))
        (member claude-org-session-tag tags)))))

(defun claude-org--find-session-scope-heading ()
  "Find the heading that defines the session scope.
Walks up the heading tree looking for :claude_session: tag or CLAUDE_SESSION_ID.
Checks current heading first, then walks upward.
Returns the heading position or nil if at file scope."
  (save-excursion
    (catch 'found
      ;; First check current heading (if at one)
      (when (org-at-heading-p)
        (when (or (claude-org--has-session-tag-p)
                  (org-entry-get nil "CLAUDE_SESSION_ID" nil))
          (throw 'found (point))))
      ;; Then walk up the tree
      (while (org-up-heading-safe)
        (when (or (claude-org--has-session-tag-p)
                  (org-entry-get nil "CLAUDE_SESSION_ID" nil))
          (throw 'found (point))))
      nil)))
#+END_SRC

** SDK UUID Management

The SDK UUID is the session identifier returned by Claude Code CLI. It's stored
as an org property to enable session resumption across Emacs restarts.

#+BEGIN_SRC elisp
(defun claude-org--get-sdk-uuid ()
  "Get SDK UUID from org properties for current session.
Only retrieves UUID from the same scope where CLAUDE_SESSION_ID is defined:
- If session ID is in a heading, gets UUID from that heading's property drawer
- If no session ID in headings, gets UUID from file-level #+PROPERTY
Returns nil if not set."
  (let ((session-heading (claude-org--find-session-scope-heading)))
    (if session-heading
        ;; Section-level: get UUID from the heading that defines the session
        (save-excursion
          (goto-char session-heading)
          (org-entry-get nil claude-org-sdk-uuid-property nil))  ;; nil = no inheritance
      ;; File-level: get from #+PROPERTY keyword
      (claude-org--get-file-level-property claude-org-sdk-uuid-property))))

(defun claude-org--set-sdk-uuid (uuid)
  "Set SDK UUID in org property.
Stores at the appropriate scope based on where CLAUDE_SESSION_ID is defined:
- If session ID is in a heading (current or parent), stores in that heading's property drawer
- Otherwise stores at file level."
  (let ((session-heading (claude-org--find-session-scope-heading)))
    (if session-heading
        ;; Section-level: set in the heading that defines the session
        (save-excursion
          (goto-char session-heading)
          (org-set-property claude-org-sdk-uuid-property uuid))
      ;; File-level: use #+PROPERTY keyword
      (save-excursion
        (goto-char (point-min))
        (if (re-search-forward
             (format "^#\\+PROPERTY:[ \t]+%s[ \t]+.+$" claude-org-sdk-uuid-property)
             nil t)
            ;; Update existing
            (replace-match (format "#+PROPERTY: %s %s"
                                   claude-org-sdk-uuid-property uuid))
          ;; Insert new after other properties
          (goto-char (point-min))
          (if (re-search-forward "^#\\+PROPERTY:" nil t)
              (progn
                (end-of-line)
                (insert (format "\n#+PROPERTY: %s %s"
                                claude-org-sdk-uuid-property uuid)))
            ;; No properties, insert after title or at beginning
            (if (re-search-forward "^#\\+TITLE:" nil t)
                (progn
                  (end-of-line)
                  (insert (format "\n#+PROPERTY: %s %s"
                                  claude-org-sdk-uuid-property uuid)))
              (insert (format "#+PROPERTY: %s %s\n" claude-org-sdk-uuid-property uuid)))))))))

(defun claude-org--clear-sdk-uuid ()
  "Clear SDK UUID from org properties.
Removes the property from the appropriate scope based on where CLAUDE_SESSION_ID is defined."
  (let ((session-heading (claude-org--find-session-scope-heading)))
    (if session-heading
        ;; Section-level: remove from property drawer
        (save-excursion
          (goto-char session-heading)
          (org-delete-property claude-org-sdk-uuid-property))
      ;; File-level: remove #+PROPERTY line
      (save-excursion
        (goto-char (point-min))
        (when (re-search-forward
               (format "^#\\+PROPERTY:[ \t]+%s[ \t]+.+\n?"
                       claude-org-sdk-uuid-property)
               nil t)
          (replace-match ""))))))
#+END_SRC

** Session Recovery

#+BEGIN_SRC elisp
(defun claude-org--section-has-archive-tag-p ()
  "Check if current heading has :ARCHIVE: tag.
Point must be at a heading."
  (when (org-at-heading-p)
    (member "ARCHIVE" (org-get-tags nil t))))

(defun claude-org--collect-ai-blocks-in-section ()
  "Collect AI blocks in current section (not including subsections).
Returns list of (question . response) pairs.
Point must be at a heading, or before first heading for top-level content."
  (let ((conversations '())
        (section-start (if (org-at-heading-p)
                           ;; Start after the heading line
                           (save-excursion
                             (forward-line 1)
                             (point))
                         ;; Before first heading: start from current point
                         (point)))
        (section-end (save-excursion
                       (if (org-at-heading-p)
                           ;; End is before next same-level heading
                           (progn
                             (org-end-of-subtree t t)
                             (point))
                         ;; Before first heading: search until first heading
                         (if (re-search-forward "^\\*+ " nil t)
                             (line-beginning-position)
                           (point-max))))))
    (save-excursion
      (save-restriction
        (narrow-to-region section-start section-end)
        ;; Find all ai blocks in this section only (not subsections)
        (goto-char (point-min))
        (while (re-search-forward "^[ \t]*#\\+begin_src[ \t]+ai" nil t)
          ;; Make sure we're not in a subsection
          (let ((block-pos (point)))
            (save-excursion
              (beginning-of-line)
              ;; Check if there's a heading between section start and block
              (goto-char (point-min))
              (unless (re-search-forward "^\\*+ " block-pos t)
                ;; No heading found, this block is in current section
                (goto-char block-pos)
                (let* ((q-start (progn (forward-line 1) (point)))
                       (q-end (progn (re-search-forward "^[ \t]*#\\+end_src" nil t)
                                     (line-beginning-position)))
                       (question (string-trim (buffer-substring-no-properties q-start q-end)))
                       ;; Response is content after #+end_src until next heading or ai block
                       (r-start (progn (forward-line 1) (point)))
                       (r-end (save-excursion
                                (if (re-search-forward "^\\(\\*+ \\|[ \t]*#\\+begin_src\\)" nil t)
                                    (line-beginning-position)
                                  (point-max))))
                       (response (string-trim (buffer-substring-no-properties r-start r-end))))
                  (when (not (string-empty-p question))
                    (push (cons question response) conversations)))))))))
    (nreverse conversations)))

(defun claude-org--collect-session-context ()
  "Collect conversation history from current session scope.
If CLAUDE_SESSION_ID is defined in a section, narrows to that subtree.
Otherwise, collects from the entire file.
Skips sections tagged with :ARCHIVE: for better performance with large files.
Returns list of (question . response) pairs for recovery."
  (let ((conversations '())
        (scope (claude-org--get-session-scope)))
    (save-excursion
      (save-restriction
        ;; Narrow to section scope if session ID is defined locally
        (when (eq scope 'section)
          (unless (org-at-heading-p)
            (org-back-to-heading t))
          (org-narrow-to-subtree))

        ;; Collect blocks from before first heading
        (goto-char (point-min))
        (unless (org-at-heading-p)
          (setq conversations (append conversations (claude-org--collect-ai-blocks-in-section))))

        ;; Iterate through top-level sections, skipping archived ones
        (goto-char (point-min))
        (when (re-search-forward "^\\*+ " nil t)
          (beginning-of-line)
          (while (not (eobp))
            (if (claude-org--section-has-archive-tag-p)
                ;; Skip entire archived subtree
                (org-end-of-subtree t t)
              ;; Collect blocks from this section
              (setq conversations (append conversations (claude-org--collect-ai-blocks-in-section)))
              ;; Move to next same-level heading
              (org-end-of-subtree t t))
            ;; Move to next top-level heading
            (unless (re-search-forward "^\\*+ " nil t)
              (goto-char (point-max)))
            (beginning-of-line)))))
    conversations))

(defun claude-org--build-recovery-prompt (context original-prompt)
  "Build recovery prompt with CONTEXT history and ORIGINAL-PROMPT."
  (let ((scope (claude-org--get-session-scope)))
    (concat
     "<session_recovery>\n"
     "The previous session expired. Here is the conversation history from this "
     (if (eq scope 'section) "section" "file")
     ":\n\n"
     (mapconcat
      (lambda (pair)
        (format "**User:** %s\n\n**Assistant:** %s\n\n---\n"
                (car pair) (cdr pair)))
      context "")
     "</session_recovery>\n\n"
     "Please continue the conversation. The user's current question is:\n\n"
     original-prompt)))

(defun claude-org--recover-session (session-key &optional reason)
  "Recover session for SESSION-KEY by collecting context and retrying.
REASON can be 'context-limit or 'expired (default)."
  (claude-org--session-put session-key :recovering t)
  ;; Notify user with appropriate message
  (let ((marker (claude-org--session-get session-key :marker))
        (msg (pcase reason
               ('context-limit "/Context limit reached, recovering with history.../")
               (_ "/Session expired, recovering with context.../"))))
    (when marker
      (with-current-buffer (marker-buffer marker)
        (save-excursion
          (goto-char marker)
          (insert (format "\n%s\n\n" msg))
          (set-marker marker (point)))
        ;; Clear old session UUID from org property
        (claude-org--clear-sdk-uuid))))
  ;; Collect context and retry
  (let* ((context (claude-org--collect-session-context))
         (original-prompt (claude-org--session-get session-key :original-prompt))
         (recovery-prompt (claude-org--build-recovery-prompt context original-prompt)))
    ;; Retry with recovery prompt
    (claude-org--send-request recovery-prompt)))
#+END_SRC

* Environment Variable Loading

Load environment variables from `.env` files with variable substitution support.

** ENV File Loading

#+BEGIN_SRC elisp
(defun claude-org--parse-env-file (file-path)
  "Parse .env FILE-PATH and return alist of (VAR . VALUE).
Supports standard .env syntax:
  KEY=value
  KEY=\"value with spaces\"
  # Comments
  export KEY=value (export prefix ignored)

Performs tilde expansion on file-path."
  (let ((expanded-path (expand-file-name file-path))
        (env-alist '()))
    (when (file-exists-p expanded-path)
      (with-temp-buffer
        (insert-file-contents expanded-path)
        (goto-char (point-min))
        (while (not (eobp))
          (let ((line (string-trim (buffer-substring-no-properties
                                    (line-beginning-position)
                                    (line-end-position)))))
            ;; Skip empty lines and comments
            (unless (or (string-empty-p line)
                        (string-prefix-p "#" line))
              ;; Remove optional "export " prefix
              (when (string-match "^export[ \t]+" line)
                (setq line (substring line (match-end 0))))
              ;; Parse KEY=VALUE
              (when (string-match "^\\([A-Za-z_][A-Za-z0-9_]*\\)=\\(.*\\)$" line)
                (let* ((key (match-string 1 line))
                       (value (match-string 2 line))
                       ;; Remove surrounding quotes if present
                       (unquoted-value (if (and (>= (length value) 2)
                                                (or (and (string-prefix-p "\"" value)
                                                         (string-suffix-p "\"" value))
                                                    (and (string-prefix-p "'" value)
                                                         (string-suffix-p "'" value))))
                                           (substring value 1 -1)
                                         value)))
                  (push (cons key unquoted-value) env-alist)))))
          (forward-line 1))))
    (nreverse env-alist)))

(defun claude-org--get-env-file-path ()
  "Get ENV_FILE path from org properties.
Returns nil if not set. Supports tilde expansion."
  (when-let ((env-file (claude-org--get-org-property "ENV_FILE" t))) ; no-expand=t
    (expand-file-name env-file)))

(defun claude-org--load-env-file ()
  "Load environment variables from ENV_FILE property.
Returns alist of (VAR . VALUE), or nil if no ENV_FILE is set."
  (when-let ((env-file-path (claude-org--get-env-file-path)))
    (if (file-exists-p env-file-path)
        (claude-org--parse-env-file env-file-path)
      (message "Warning: ENV_FILE not found: %s" env-file-path)
      nil)))
#+END_SRC

** Variable Substitution

#+BEGIN_SRC elisp
(defun claude-org--expand-env-vars (value env-alist)
  "Expand ${VAR} references in VALUE using ENV-ALIST.
ENV-ALIST is an alist of (VAR-NAME . VAR-VALUE).
Also expands environment variables from process-environment.

Examples:
  \"${HOME}/projects\"     -> \"/Users/user/projects\"
  \"token=${API_TOKEN}\"   -> \"token=sk-abc123\"
  \"${VAR:-default}\"      -> Uses default if VAR not set (bash syntax)"
  (when value
    (let ((result value))
      ;; Replace ${VAR} with values from env-alist or process-environment
      (while (string-match "\\${\\([A-Za-z_][A-Za-z0-9_]*\\)\\(:-\\([^}]*\\)\\)?}" result)
        (let* ((var-name (match-string 1 result))
               (default-value (match-string 3 result))
               ;; Look up in env-alist first, then process-environment
               (var-value (or (cdr (assoc var-name env-alist))
                              (getenv var-name)
                              default-value
                              "")))
          (setq result (replace-match var-value t t result))))
      result)))
#+END_SRC

* Permission Mode

Permission mode can be stored as org property `CLAUDE_PERMISSION_MODE`.
- File-level: =#+PROPERTY: CLAUDE_PERMISSION_MODE accept-edits=
- Section-level: =:CLAUDE_PERMISSION_MODE: bypass= in property drawer

** Permission Mode Functions

#+BEGIN_SRC elisp
(defun claude-org--get-permission-mode-property ()
  "Get CLAUDE_PERMISSION_MODE from org properties.
Checks section property drawer first, then file-level #+PROPERTY.
Returns nil if not set."
  (or
   ;; Section-level property (with inheritance)
   (org-entry-get nil claude-org-permission-property t)
   ;; File-level property via keyword
   (claude-org--get-file-level-property claude-org-permission-property)))

(defun claude-org--get-permission-mode ()
  "Get effective permission mode for current session.
Priority: org property > global preset > 'readonly'.
Returns CLI permission-mode value."
  (let* ((preset (or (claude-org--get-permission-mode-property)
                     claude-agent-permission-preset
                     "readonly"))
         (mode-info (cdr (assoc preset claude-org--permission-mode-map))))
    (if mode-info
        (plist-get mode-info :cli)
      "default")))

(defun claude-org--get-permission-mode-display ()
  "Get current permission mode name for display."
  (or (claude-org--get-permission-mode-property)
      claude-agent-permission-preset
      "readonly"))

(defun claude-org--permission-mode-short ()
  "Get short permission mode string for header-line display."
  (let* ((preset (claude-org--get-permission-mode-display))
         (mode-info (cdr (assoc preset claude-org--permission-mode-map))))
    (if mode-info
        (plist-get mode-info :short)
      "??")))

(defun claude-org--get-setting-sources ()
  "Get setting sources for Claude CLI.
Checks CLAUDE_SETTING_SOURCES org property first, then uses default.
Returns list of strings like (\"user\" \"project\")."
  (let ((prop-value
         (or
          ;; Section-level property (with inheritance)
          (org-entry-get nil claude-org-setting-sources-property t)
          ;; File-level property via keyword
          (claude-org--get-file-level-property claude-org-setting-sources-property))))
    (if prop-value
        ;; Parse comma-separated string from property
        (mapcar #'string-trim (split-string prop-value ","))
      ;; Use default
      claude-org-setting-sources)))

(defun claude-org--get-org-property (property &optional no-expand)
  "Get PROPERTY value from org properties with variable expansion.
Checks section property drawer first (with inheritance), then file-level #+PROPERTY.
Returns nil if not set.

By default, expands ${VAR} references using ENV_FILE variables and process environment.
Set NO-EXPAND to t to disable variable expansion."
  (let ((raw-value
         (or
          ;; Section-level property (with inheritance)
          (org-entry-get nil property t)
          ;; File-level property via keyword
          (claude-org--get-file-level-property property))))
    ;; Apply variable expansion unless disabled
    (if (or no-expand (not raw-value))
        raw-value
      (let ((env-alist (claude-org--load-env-file)))
        (claude-org--expand-env-vars raw-value env-alist)))))

(defun claude-org--get-env-vars ()
  "Collect environment variables from org properties.
Returns an alist of (VAR-NAME . VALUE) for all properties in
`claude-org-env-properties' that have values set."
  (let (env-vars)
    (dolist (prop claude-org-env-properties)
      (let ((value (claude-org--get-org-property prop)))
        (when (and value (not (string-empty-p value)))
          (push (cons prop value) env-vars))))
    (nreverse env-vars)))
#+END_SRC

** Permission Mode Setter

#+BEGIN_SRC elisp
(defun claude-org--set-permission-mode (mode)
  "Set permission MODE in org property.
Sets at the appropriate scope based on where CLAUDE_SESSION_ID is defined:
- If session ID is in a heading (current or parent), sets in that heading's property drawer
- Otherwise sets at file level."
  (let ((session-heading (claude-org--find-session-scope-heading)))
    (if session-heading
        ;; Section-level: set property in the heading that defines the session
        (save-excursion
          (goto-char session-heading)
          (org-set-property claude-org-permission-property mode))
      ;; File-level: use #+PROPERTY keyword
      (save-excursion
        (goto-char (point-min))
        (if (re-search-forward
             (format "^#\\+PROPERTY:[ \t]+%s[ \t]+.+$" claude-org-permission-property)
             nil t)
            ;; Update existing
            (replace-match (format "#+PROPERTY: %s %s"
                                   claude-org-permission-property mode))
          ;; Insert new after other properties
          (if (re-search-forward "^#\\+PROPERTY:" nil t)
              (progn
                (end-of-line)
                (insert (format "\n#+PROPERTY: %s %s"
                                claude-org-permission-property mode)))
            ;; No properties, insert at beginning
            (insert (format "#+PROPERTY: %s %s\n" claude-org-permission-property mode))))))
    ;; Clear org's keyword property cache so org-entry-get reads fresh values
    ;; Without this, org-entry-get with inheritance returns stale cached values
    (setq-local org-keyword-properties nil)))

(defun claude-org-switch-permission-mode ()
  "Show current permission mode and switch to another.
Sets the CLAUDE_PERMISSION_MODE property at the appropriate scope."
  (interactive)
  (let* ((current (claude-org--get-permission-mode-display))
         (presets '(("readonly - Require approval for all tools" . "readonly")
                    ("accept-edits - Accept file edits without prompts" . "accept-edits")
                    ("plan - Suggests changes, requires approval for edits" . "plan")
                    ("bypass - All tools auto-approved" . "bypass")))
         (choices (mapcar (lambda (p)
                            (if (string= (cdr p) current)
                                (cons (concat (car p) " [current]") (cdr p))
                              p))
                          presets))
         (selection (completing-read
                     (format "Permission mode [%s]: " current)
                     (mapcar #'car choices)
                     nil t))
         (mode (cdr (assoc (replace-regexp-in-string " \\[current\\]$" "" selection)
                           choices))))
    (when mode
      (claude-org--set-permission-mode mode)
      (claude-org--refresh-header-line)
      (message "Permission mode set to: %s" mode))))
#+END_SRC

** MCP Server Integration

Automatically start MCP server and pass configuration to Claude CLI.

#+BEGIN_SRC elisp
(defun claude-org--ensure-mcp-server ()
  "Ensure MCP server is running if auto-start is enabled.
Starts the MCP server on `emacs-mcp-server-default-port' if not already running.
Raises an error if `emacs-mcp-server' module is not loaded."
  (when claude-org-auto-start-mcp-server
    (unless (fboundp 'emacs-mcp-server-running-p)
      (error "emacs-mcp-server module not loaded. Please load emacs-mcp-server.org first:
  (literate-elisp-load \"/path/to/emacs-mcp-server.org\")
Or set `claude-org-auto-start-mcp-server' to nil to disable auto-start"))
    (unless (emacs-mcp-server-running-p)
      (emacs-mcp-server-start))))

(defun claude-org--get-mcp-config ()
  "Get MCP config JSON string if server is running.
Returns nil if MCP server is not available or not running."
  (when (and (fboundp 'emacs-mcp-server-running-p)
             (emacs-mcp-server-running-p))
    (let ((port (emacs-mcp-server-port)))
      (json-encode
       `((mcpServers . ((emacs . ((type . "http")
                                  (url . ,(format "http://localhost:%d/mcp" port)))))))))))
#+END_SRC

* Project Configuration

Project configuration for cwd and system prompts.

** PROJECT_ROOT

#+BEGIN_SRC elisp
(defun claude-org--get-project-root ()
  "Get project root from org properties with inheritance.
Checks section-level property drawer first, then inherits from parent headings,
finally falls back to file-level #+PROPERTY.
Returns nil if not set (will use default-directory).

Usage in org file:
  File-level: #+PROPERTY: PROJECT_ROOT /path/to/project
  Section-level (property drawer):
    * My Section
    :PROPERTIES:
    :PROJECT_ROOT: /other/path
    :END:"
  (org-entry-get nil "PROJECT_ROOT" t))
#+END_SRC

** System Prompts

#+BEGIN_SRC elisp
(defun claude-org--collect-system-prompts ()
  "Collect content from all org sections tagged :system_prompt:.
Returns concatenated string of heading + body for each section, or nil if none.

Usage in org file:
  * Project Guidelines :system_prompt:
  This project uses Python 3.11 with Django.
  Always use absolute imports."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      (let ((prompts '())
            (heading-re "^\\(\\*+\\) +\\(.*\\):system_prompt:"))
        ;; Use regex search instead of org-map-entries to avoid cache issues
        (while (re-search-forward heading-re nil t)
          (let* ((stars (match-string 1))
                 (heading-text (match-string 2))
                 (heading (string-trim (replace-regexp-in-string ":.*$" "" heading-text)))
                 (beg (save-excursion
                        (forward-line 1)
                        ;; Skip property drawers and planning lines
                        (while (and (not (eobp))
                                    (looking-at "^[ \t]*\\(:\\|DEADLINE:\\|SCHEDULED:\\|CLOSED:\\)"))
                          (forward-line 1))
                        (point)))
                 (end (save-excursion
                        (beginning-of-line)
                        (org-end-of-subtree t t)
                        (point)))
                 (body (when (< beg end)
                         (string-trim (buffer-substring-no-properties beg end)))))
            (when (and heading (not (string-empty-p heading)))
              (push (concat "* " heading
                            (when (and body (not (string-empty-p body)))
                              (concat "\n" body)))
                    prompts))))
        (when prompts
          (mapconcat #'identity (nreverse prompts) "\n\n"))))))

(defun claude-org--build-system-prompt ()
  "Build complete system prompt from file-based templates and org sections.
Combines:
1. System prompts from docs/prompts/system/*.org (loaded in sorted order)
2. :system_prompt: tagged org sections in the current file
3. Behavior prompts from tags and header arguments
4. Line width instruction based on `claude-org-line-width'"
  (let ((file-prompts (claude-org--load-system-prompts))
        (org-prompts (claude-org--collect-system-prompts))
        (behavior-prompt (claude-org--build-behavior-prompt))
        (line-width-hint (when (and claude-org-line-width (> claude-org-line-width 0))
                           (format "Keep output lines under %d characters, break long lines naturally."
                                   claude-org-line-width))))
    ;; Combine all parts: file prompts + org-prompts + behaviors + line-width
    (let ((parts (append file-prompts
                         (delq nil (list org-prompts behavior-prompt line-width-hint)))))
      (when parts
        (string-join parts "\n\n")))))
#+END_SRC

* Process Management

Multi-session process management allowing concurrent queries.

** State Variables

#+BEGIN_SRC elisp
(defvar-local claude-org--sessions nil
  "Hash table mapping session-key -> session state plist.
Each session state contains:
  :process-state - claude-agent process state
  :marker        - insertion marker
  :busy          - boolean busy state
  :spinner       - spinner frame index (0-3)
  :start-time    - request start time (float-time)
  :original-prompt - for session recovery
  :recovering    - non-nil during recovery
  :section-level - heading level for response adjustment

Initialized to a new hash table when `claude-org-mode' is enabled.")

(defvar-local claude-org--fontlock-timer nil
  "Timer for debounced font-lock during streaming.")
#+END_SRC

** Session State Accessors

#+BEGIN_SRC elisp
(defun claude-org--get-session (session-key)
  "Get or create session state for SESSION-KEY."
  ;; Ensure hash table exists (lazy initialization per buffer)
  ;; Must use setq-local to create buffer-local binding
  (unless (local-variable-p 'claude-org--sessions)
    (setq-local claude-org--sessions (make-hash-table :test 'equal)))
  (or (gethash session-key claude-org--sessions)
      (let ((state (list :process-state nil
                         :marker nil
                         :busy nil
                         :spinner 0
                         :start-time nil
                         :original-prompt nil
                         :recovering nil
                         :section-level 0
                         :current-line-length 0)))  ; Track line length for auto-breaking
        (puthash session-key state claude-org--sessions)
        state)))

(defun claude-org--session-put (session-key prop value)
  "Set PROP to VALUE in session SESSION-KEY."
  (let ((state (claude-org--get-session session-key)))
    (plist-put state prop value)
    (puthash session-key state claude-org--sessions)))

(defun claude-org--session-get (session-key prop)
  "Get PROP from session SESSION-KEY."
  (plist-get (claude-org--get-session session-key) prop))

(defun claude-org--active-session-count ()
  "Return count of sessions with :busy t."
  (let ((count 0))
    (when (hash-table-p claude-org--sessions)
      (maphash (lambda (_id state)
                 (when (plist-get state :busy)
                   (cl-incf count)))
               claude-org--sessions))
    count))

(defun claude-org--session-display-name (session-key)
  "Extract display name from SESSION-KEY.
Returns just the custom part after :: or a shortened file path."
  (if (string-match "::\\(.+\\)$" session-key)
      (match-string 1 session-key)
    ;; No custom ID, show abbreviated file name
    (file-name-nondirectory session-key)))

(defun claude-org--format-elapsed (start-time)
  "Format elapsed time since START-TIME as human-readable string.
Uses verbose format for header-line display."
  (claude-agent-format-elapsed-time start-time 'verbose))
#+END_SRC

* Behavior Prompts

Tag and header argument based behavior injection system.
Prompts are loaded from =docs/prompts/= directory at runtime.

** Tag Prompt Lookup

Tag-based prompt generation using =cl-defgeneric= / =cl-defmethod=.
This allows specialized behavior per tag (e.g., SDD injects dynamic links).

*** Generic Function

#+BEGIN_SRC elisp
(cl-defgeneric claude-org-tag-prompt (tag context)
  "Generate prompt content for TAG with CONTEXT.
TAG is a symbol (e.g., 'sdd, 'research).
CONTEXT is a plist with keys:
  :file-path   - Absolute path to the org file
  :sdd-root    - SDD root section name (e.g., \"Feature Name\") or nil
  :current-tags - List of all inherited tags
Returns a prompt string or nil.")
#+END_SRC

*** Default Method (File-Based Loading)

#+BEGIN_SRC elisp
(cl-defmethod claude-org-tag-prompt (tag _context)
  "Default: load prompt from docs/prompts/tags/TAG.org."
  (claude-org--load-prompt-file
   (expand-file-name (format "tags/%s.org" (symbol-name tag))
                     claude-org-prompts-directory)))
#+END_SRC

*** Legacy Wrapper

Backward-compatible wrapper for existing callers.

#+BEGIN_SRC elisp
(defun claude-org--tag-prompt (tag)
  "Get behavior prompt for TAG symbol.
Legacy wrapper - calls `claude-org-tag-prompt' with minimal context."
  (claude-org-tag-prompt tag nil))
#+END_SRC

*** SDD Root Detection

#+BEGIN_SRC elisp
(defun claude-org--find-sdd-root ()
  "Find the root section name for current SDD.
Returns the heading text (e.g., \"Feature Name\") of the parent section
that contains the :sdd: tagged Workflow section, or nil if not in SDD."
  (save-excursion
    (when (member "sdd" (claude-org--get-current-tags))
      ;; Walk up to find section with :sdd: tag
      (while (and (org-up-heading-safe)
                  (not (member "sdd" (org-get-tags nil t)))))
      ;; Now at the :sdd: section (Workflow), go up one more to get parent
      (when (org-up-heading-safe)
        (org-get-heading t t t t)))))
#+END_SRC

*** CUSTOM_ID Generation

#+BEGIN_SRC elisp
(defun claude-org--generate-custom-id (session-id section-name &optional file-base)
  "Generate a CUSTOM_ID for SDD sections.
SESSION-ID is the session identifier (e.g., \"sdd-20251227-180147\").
SECTION-NAME is the heading text (e.g., \"Research Output\").
FILE-BASE is optional file name without extension for cross-file uniqueness.
Returns a slug like \"claude-agent-dev-research-output-sdd-20251227-180147\"."
  (when (and session-id section-name)
    (let ((slug (downcase (replace-regexp-in-string "[^[:alnum:]]+" "-" section-name))))
      ;; Remove leading/trailing hyphens
      (setq slug (replace-regexp-in-string "^-+\\|-+$" "" slug))
      (if file-base
          (format "%s-%s-%s" file-base slug session-id)
        (format "%s-%s" session-id slug)))))
#+END_SRC

*** SDD Link Generation

#+BEGIN_SRC elisp
(defun claude-org--generate-sdd-links (file-path sdd-root &optional session-id)
  "Generate org links to SDD sibling sections.
FILE-PATH is the absolute path to the org file.
SDD-ROOT is the parent section name (e.g., \"Feature Name\").
SESSION-ID is optional; if provided, uses #custom-id format for stable links.
Returns a formatted string with links to Research Output, Spec, Features."
  (when (and file-path sdd-root)
    (let ((sections '(("Research Output" . "research_output")
                      ("Spec" . "spec")
                      ("Features" . "features")))
          (file-base (when file-path (file-name-base file-path))))
      (concat
       "** SDD Section Links\n\n"
       "Use these links to navigate and update SDD sections:\n\n"
       (mapconcat
        (lambda (sec)
          (let* ((name (car sec))
                 (link (if session-id
                           ;; Use stable #custom-id format with file-base for uniqueness
                           (org-link-make-string
                            (format "file:%s::#%s" file-path
                                    (claude-org--generate-custom-id session-id name file-base))
                            name)
                         ;; Fallback to *heading format for legacy SDDs without session-id
                         (org-link-make-string
                          (format "file:%s::*%s" file-path name)
                          name))))
            (format "- *%s*: %s" name link)))
        sections "\n")))))
#+END_SRC

*** SDD-Specific Method

#+BEGIN_SRC elisp
(cl-defmethod claude-org-tag-prompt ((tag (eql 'sdd)) context)
  "SDD tag: combine static prompt with dynamic section links."
  (let* ((file-path (plist-get context :file-path))
         (sdd-root (plist-get context :sdd-root))
         (session-id (plist-get context :session-id))
         (static-prompt (claude-org--load-prompt-file
                         (expand-file-name "tags/sdd.org"
                                           claude-org-prompts-directory)))
         (links (claude-org--generate-sdd-links file-path sdd-root session-id)))
    (if links
        (concat static-prompt "\n\n" links)
      static-prompt)))
#+END_SRC

** Header Prompt Lookup

Loads prompt from =docs/prompts/headers/=. Supports:
- Enum-style: =headers/phase/code.org= for =:phase code=
- Template-style: =headers/coverage.org= with =%s= placeholder

#+BEGIN_SRC elisp
(defun claude-org--header-prompt (header value)
  "Get behavior prompt for HEADER keyword with VALUE.
Loads from docs/prompts/headers/ at runtime.

Supports two patterns:
- Enum: headers/HEADER/VALUE.org (e.g., headers/phase/code.org)
- Template: headers/HEADER.org with %s placeholder"
  (when value
    (let* ((name (substring (symbol-name header) 1))  ; strip leading :
           (dir (expand-file-name "headers" claude-org-prompts-directory))
           ;; Try enum-style first: headers/phase/code.org
           (enum-file (expand-file-name (format "%s/%s.org" name value) dir))
           ;; Fallback to template: headers/coverage.org
           (template-file (expand-file-name (format "%s.org" name) dir)))
      (cond
       ;; Enum-style: subdirectory with value files
       ((file-readable-p enum-file)
        (claude-org--load-prompt-file enum-file))
       ;; Template-style: single file with %s placeholder
       ((file-readable-p template-file)
        (let ((tpl (claude-org--load-prompt-file template-file)))
          (if (and tpl (string-match-p "%s" tpl))
              (format tpl value)
            tpl)))))))
#+END_SRC

** Collect Current Context

#+BEGIN_SRC elisp
(defun claude-org--get-current-tags ()
  "Get list of tag strings for current section (inherited).
Uses org-get-tags with LOCAL=nil to include inherited tags from ancestors."
  (when-let* ((tags (org-get-tags nil nil)))  ; nil = include inherited tags
    (mapcar #'downcase tags)))

(defun claude-org--get-block-header-args ()
  "Get header arguments from current ai block.
Returns plist of header arguments, e.g. (:phase \"code\" :tests t)."
  (save-excursion
    (let ((case-fold-search t))
      (when (re-search-backward "^[ \t]*#\\+begin_src[ \t]+ai\\b" nil t)
        (let ((line (buffer-substring-no-properties (point) (line-end-position))))
          (when (string-match "#\\+begin_src[ \t]+ai\\b[ \t]*\\(.*\\)" line)
            (let ((args-str (match-string 1 line))
                  (result nil))
              (when (and args-str (not (string-empty-p args-str)))
                ;; Parse header args: :key value :key2 value2
                (with-temp-buffer
                  (insert args-str)
                  (goto-char (point-min))
                  (while (re-search-forward ":\\([a-zA-Z_-]+\\)\\(?:[ \t]+\\([^ \t\n:]+\\)\\)?" nil t)
                    (let ((key (intern (concat ":" (match-string 1))))
                          (val (match-string 2)))
                      ;; Build plist: push value first, then key (reversed later)
                      (push key result)
                      (push (or val t) result)))))
              ;; Result is (val2 key2 val1 key1), reverse to get (key1 val1 key2 val2)
              (nreverse result))))))))
#+END_SRC

** Build Behavior Prompt

#+BEGIN_SRC elisp
(defun claude-org--collect-behavior-config ()
  "Collect current behavior configuration.
Returns plist with :tags and :header-args."
  (list :tags (claude-org--get-current-tags)
        :header-args (claude-org--get-block-header-args)))

(defun claude-org--sdd-tag-priority (tag)
  "Return priority for TAG in SDD workflow (lower = first).
Container tags come before phase tags."
  (pcase tag
    ("sdd" 0)        ; Container first
    ("spec" 1)       ; Documentation sections
    ("features" 2)
    ("research" 10)  ; Phases in order
    ("design" 11)
    ("planning" 12)
    ("implementation" 13)
    (_ 50)))          ; Other tags last

(defun claude-org--build-behavior-context ()
  "Build context plist for tag prompt generation.
Returns plist with :file-path, :sdd-root, :session-id, :current-tags."
  (list :file-path (buffer-file-name)
        :sdd-root (claude-org--find-sdd-root)
        :session-id (claude-org--get-session-id)
        :current-tags (claude-org--get-current-tags)))

(defun claude-org--build-behavior-prompt ()
  "Build behavior prompt from current tags and header arguments.
Returns combined prompt string or nil if no behaviors active.

For SDD workflow, tags are ordered: container (sdd) first, then phase tags.
This ensures the workflow context is established before phase-specific behavior.
Context is passed to tag methods for dynamic prompt generation (e.g., SDD links)."
  (let* ((config (claude-org--collect-behavior-config))
         (tags (plist-get config :tags))
         (header-args (plist-get config :header-args))
         (context (claude-org--build-behavior-context))
         (parts '()))
    ;; Collect tag prompts (ordered by SDD priority for proper context)
    (dolist (tag-str (sort (copy-sequence tags)
                           (lambda (a b)
                             (< (claude-org--sdd-tag-priority a)
                                (claude-org--sdd-tag-priority b)))))
      (when-let ((prompt (claude-org-tag-prompt (intern tag-str) context)))
        (push prompt parts)))
    ;; Collect header argument prompts
    (cl-loop for (header value) on header-args by #'cddr
             when (keywordp header)
             do (when-let ((prompt (claude-org--header-prompt header value)))
                  (push prompt parts)))
    ;; Combine (reverse to maintain order: tags first, then headers)
    (when parts
      (string-join (nreverse parts) "\n\n"))))
#+END_SRC

* Block Detection

Block detection answers the fundamental question: "Where am I in the document?"
These functions determine the execution context for AI blocks by examining:

1. *Section hierarchy* - What level heading contains the cursor?
2. *Block boundaries* - Is point inside a =#+begin_src ai= block?
3. *Output sections* - Is this an AI response area (tagged with =:ai_output:=)?
4. *Instruction numbering* - Which instruction number does this belong to?

The detection logic supports both complete blocks (with =#+end_src=) and incomplete
blocks (still being edited), allowing execution during composition.

** Section Level Detection
#+NAME: block-detect-section-level
#+BEGIN_SRC elisp
(defun claude-org--get-section-level ()
  "Get the current org section level (number of stars).
Returns 0 if not inside any heading, otherwise returns the heading level."
  (save-excursion
    (if (org-before-first-heading-p)
        0
      (org-back-to-heading t)
      (org-current-level))))

#+END_SRC

** AI Block Boundary Detection

These functions detect whether point is inside an AI block and extract its boundaries.
The key insight: an incomplete block (no =#+end_src= yet) is valid for execution,
enabling users to run queries while still composing them.

#+NAME: block-detect-boundaries
#+BEGIN_SRC elisp
(defun claude-org--in-ai-block-p ()
  "Return t if point is inside a #+begin_src ai block."
  (save-excursion
    (let ((case-fold-search t)
          (pos (point)))
      (when (re-search-backward "^[ \t]*#\\+begin_src[ \t]+ai\\b" nil t)
        (let ((block-start (point)))
          ;; If we find end_src, check we're between begin and end
          ;; If no end_src found, assume we're still inside the block (incomplete block)
          (if (re-search-forward "^[ \t]*#\\+end_src" nil t)
              (and (>= pos block-start)
                   (<= pos (point)))
            ;; No end found, we're in an incomplete block - that's OK
            (>= pos block-start)))))))

(defun claude-org--get-block-content ()
  "Get content of the ai block at point."
  (save-excursion
    (let ((case-fold-search t))
      (when (re-search-backward "^[ \t]*#\\+begin_src[ \t]+ai\\b" nil t)
        (forward-line 1)
        (let ((start (point)))
          (when (re-search-forward "^[ \t]*#\\+end_src" nil t)
            (forward-line 0)
            (string-trim (buffer-substring-no-properties start (point)))))))))

(defun claude-org--find-block-end ()
  "Find position at end of #+end_src line."
  (save-excursion
    (let ((case-fold-search t))
      (when (re-search-forward "^[ \t]*#\\+end_src" nil t)
        (line-end-position)))))

#+END_SRC

** Output Section and Instruction Detection

Output sections (tagged =:ai_output:=) contain Claude's responses.
Instruction detection finds which numbered instruction contains the cursor,
used for maintaining conversation context and navigation.

#+NAME: block-detect-output-instruction
#+BEGIN_SRC elisp
(defun claude-org--in-output-section-p ()
  "Check if cursor is inside an :ai_output: tagged section.
Returns non-nil if current heading or any parent heading has the output tag."
  (save-excursion
    (let ((tags (org-get-tags nil t)))
      (member claude-org-output-tag tags))))

(defun claude-org--find-instruction-number ()
  "Extract instruction number from current or parent heading.
Returns nil if not in an Instruction heading."
  (save-excursion
    (when (ignore-errors (org-back-to-heading t))
      (when (looking-at "^\\*+ Instruction \\([0-9]+\\)")
        (string-to-number (match-string 1))))))

(defun claude-org--skip-to-after-output-section ()
  "Skip to after the current :ai_output: section.
Moves point to after the output section's subtree, ready to insert sibling."
  (when (claude-org--in-output-section-p)
    (org-back-to-heading t)
    ;; Move to the end of this subtree
    (org-end-of-subtree t t)))

(defun claude-org--heading-matches-auto-title-pattern-p ()
  "Check if current heading matches the auto-title pattern.
Returns the heading text (without stars and tags) if it matches, nil otherwise."
  (save-excursion
    (when (ignore-errors (org-back-to-heading t))
      (let ((heading (org-get-heading t t t t)))  ; no tags, no todo, no priority, no comment
        (when (and heading
                   (string-match-p claude-org-auto-title-heading-pattern heading))
          heading)))))

(defun claude-org--replace-heading-at-marker (marker new-title)
  "Replace heading text at MARKER with NEW-TITLE.
Preserves heading level (stars), tags, and properties."
  (when (and marker (marker-buffer marker) (buffer-live-p (marker-buffer marker)))
    (with-current-buffer (marker-buffer marker)
      (save-excursion
        (goto-char marker)
        (when (ignore-errors (org-back-to-heading t))
          (let* ((tags (org-get-tags nil t))
                 (level (org-current-level))
                 (stars (make-string level ?*))
                 ;; Build tag string manually
                 (tag-str (if tags
                              (concat " :" (mapconcat #'identity tags ":") ":")
                            "")))
            ;; Delete the current heading line (including newline)
            (beginning-of-line)
            (let ((line-start (point)))
              (forward-line 1)
              (delete-region line-start (point)))
            ;; Insert new heading with title and tags on same line
            (insert stars " " new-title tag-str "\n")))))))

(defun claude-org--maybe-auto-generate-title (query heading-marker)
  "Generate title for QUERY and update heading at HEADING-MARKER.
Only runs if `claude-org-auto-generate-title' is non-nil."
  (when claude-org-auto-generate-title
    (lexical-let ((marker heading-marker))
      (claude-agent-generate-title
       `((user . ,query))
       :on-title (lambda (title)
                   (claude-org--replace-heading-at-marker marker title))
       :on-error (lambda (err)
                   (message "Auto-title generation failed: %s" err))))))
#+END_SRC

* Block Insertion

Block insertion creates new AI query blocks with proper structure and numbering.
The insertion logic is "smart" - it understands the document's flat pattern where
Instruction N and Response N are siblings, not parent-child.

** Instruction Numbering

Each instruction gets a unique sequential number. This function scans all existing
instruction headings and returns the next available number, ensuring no duplicates.

#+NAME: block-insert-numbering
#+BEGIN_SRC elisp
(defun claude-org--next-instruction-number ()
  "Find the next available instruction number."
  (save-excursion
    (goto-char (point-min))
    (let ((max-num 0))
      (while (re-search-forward "^\\*+ Instruction \\([0-9]+\\)" nil t)
        (setq max-num (max max-num (string-to-number (match-string 1)))))
      (1+ max-num))))
#+END_SRC

** Standard Block Insertion

The primary insertion command. Key behaviors:
- Skips past output sections to maintain the flat Instruction/Response pattern
- Matches heading level of existing instructions (or uses current level)
- Auto-generates the next instruction number
- Optionally prompts for workflow tags via transient menu

*** Tag Selection State

#+NAME: block-insert-tag-state
#+BEGIN_SRC elisp
(defvar claude-org--selected-tags nil
  "Currently selected workflow tags for block insertion.")

(defconst claude-org--workflow-tags
  '(("r" "research" "Research - codebase exploration")
    ("d" "design" "Design - architecture/API design")
    ("p" "planning" "Planning - implementation steps")
    ("i" "implementation" "Implementation - writing code"))
  "Available workflow tags: (key tag description).")
#+END_SRC

*** Tag Toggle Functions

#+NAME: block-insert-tag-toggle
#+BEGIN_SRC elisp
(defun claude-org--toggle-tag (tag)
  "Toggle TAG in selected tags list."
  (if (member tag claude-org--selected-tags)
      (setq claude-org--selected-tags (delete tag claude-org--selected-tags))
    (push tag claude-org--selected-tags)))

(defun claude-org--tag-selected-p (tag)
  "Return non-nil if TAG is currently selected."
  (member tag claude-org--selected-tags))

(defun claude-org--toggle-research ()
  "Toggle research tag." (interactive)
  (claude-org--toggle-tag "research"))

(defun claude-org--toggle-design ()
  "Toggle design tag." (interactive)
  (claude-org--toggle-tag "design"))

(defun claude-org--toggle-planning ()
  "Toggle planning tag." (interactive)
  (claude-org--toggle-tag "planning"))

(defun claude-org--toggle-implementation ()
  "Toggle implementation tag." (interactive)
  (claude-org--toggle-tag "implementation"))
#+END_SRC

*** Transient Tag Selection Menu

#+NAME: block-insert-transient-menu
#+BEGIN_SRC elisp
(require 'transient)

(transient-define-prefix claude-org-insert-block-menu ()
  "Select workflow tags for new AI block."
  :value (lambda () claude-org--selected-tags)
  ["Workflow Tags (toggle to select)"
   ("r" claude-org--toggle-research
    :transient t
    :description (lambda ()
                   (concat (if (claude-org--tag-selected-p "research") "[X] " "[ ] ")
                           "Research - codebase exploration")))
   ("d" claude-org--toggle-design
    :transient t
    :description (lambda ()
                   (concat (if (claude-org--tag-selected-p "design") "[X] " "[ ] ")
                           "Design - architecture/API design")))
   ("p" claude-org--toggle-planning
    :transient t
    :description (lambda ()
                   (concat (if (claude-org--tag-selected-p "planning") "[X] " "[ ] ")
                           "Planning - implementation steps")))
   ("i" claude-org--toggle-implementation
    :transient t
    :description (lambda ()
                   (concat (if (claude-org--tag-selected-p "implementation") "[X] " "[ ] ")
                           "Implementation - writing code")))]
  ["Actions"
   ("RET" "Create block with tags" claude-org--insert-block-with-tags)
   ("n" "Create block (no tags)" claude-org--insert-block-no-tags)
   ("q" "Cancel" transient-quit-one)])

(defun claude-org--insert-block-with-tags ()
  "Insert block with currently selected tags, then clear selection."
  (interactive)
  (let ((tags claude-org--selected-tags))
    (setq claude-org--selected-tags nil)
    (claude-org--do-insert-block tags)))

(defun claude-org--insert-block-no-tags ()
  "Insert block without any workflow tags."
  (interactive)
  (setq claude-org--selected-tags nil)
  (claude-org--do-insert-block nil))
#+END_SRC

*** Core Block Insertion

**** Finding Previous Chat Level

To insert a new AI block at the correct level, we need to find the most recent
chat section - any heading with =:claude_chat:= tag.

#+NAME: block-find-chat-level
#+BEGIN_SRC elisp
(defun claude-org--find-previous-chat-level ()
  "Find the level of the most recent :claude_chat: section before point.
Searches backwards for any heading with :claude_chat: tag.
Returns the level (integer) or nil if not found."
  (save-excursion
    (save-restriction
      (widen)
      (let ((found-level nil)
            (chat-tag-pattern (format ":%s:" claude-org-heading-tag)))
        ;; Search backwards through all headings
        (while (and (not found-level)
                    (re-search-backward "^\\(\\*+\\) " nil t))
          (let* ((level (length (match-string 1)))
                 (line (buffer-substring-no-properties
                        (point) (line-end-position))))
            ;; Check for :claude_chat: tag only
            (when (string-match-p chat-tag-pattern line)
              (setq found-level level))))
        found-level))))
#+END_SRC

**** Inserting the Block

#+NAME: block-insert-standard
#+BEGIN_SRC elisp
(defun claude-org--do-insert-block (workflow-tags)
  "Insert an AI block with optional WORKFLOW-TAGS.
WORKFLOW-TAGS is a list of tag strings like (\"research\" \"design\").
Automatically generates a CUSTOM_ID for stable navigation."
  ;; If inside an output section, skip to after it
  (claude-org--skip-to-after-output-section)
  ;; Find the level by looking for the last chat section (heading with :claude_chat: tag)
  (let* ((level (or (claude-org--find-previous-chat-level)
                    (org-current-level)
                    1))
         (stars (make-string level ?*))
         (num (claude-org--next-instruction-number))
         ;; Build tag string: workflow tags + claude-org-heading-tag
         ;; Org format is :tag1:tag2:tag3: - single colons between tags
         (all-tags (append workflow-tags (list claude-org-heading-tag)))
         (tag-str (concat ":" (mapconcat #'identity all-tags ":") ":"))
         ;; Generate CUSTOM_ID for stable navigation
         (file-base (when buffer-file-name (file-name-base buffer-file-name)))
         ;; Wrap session-id lookup to handle edge cases in batch testing
         (session-id (ignore-errors (claude-org--get-session-id)))
         (custom-id (claude-org--generate-instruction-custom-id file-base num session-id)))
    (insert stars " Instruction " (number-to-string num) " " tag-str "\n")
    ;; Add PROPERTIES drawer with CUSTOM_ID
    (when custom-id
      (insert ":PROPERTIES:\n")
      (insert ":CUSTOM_ID: " custom-id "\n")
      (insert ":END:\n"))
    (insert "\n#+begin_src ai\n\n#+end_src\n")
    (forward-line -2)))

(defun claude-org--generate-instruction-custom-id (file-base num session-id)
  "Generate a CUSTOM_ID for an instruction block.
FILE-BASE is the org file name without extension.
NUM is the instruction number.
SESSION-ID is the parent section's CLAUDE_SESSION_ID (can be nil).
Returns a string like \"file-instruction-N-session-id\" or \"file-instruction-N\"."
  (when file-base
    (if session-id
        (format "%s-instruction-%d-%s" file-base num session-id)
      (format "%s-instruction-%d" file-base num))))

(defun claude-org-insert-block ()
  "Insert an AI query block with optional workflow tags.
Shows a transient menu to select tags (research, design, planning, implementation).
Press RET to create with selected tags, or 'n' for no tags."
  (interactive)
  (setq claude-org--selected-tags nil)
  (claude-org-insert-block-menu))
#+END_SRC

** Session and Story Blocks

These create blocks with isolated conversation context. Session blocks use the
=:claude_session:= tag for section-scoped isolation. Story blocks use
=CLAUDE_SESSION_ID= property for named, persistent sessions.

| Command | Keybinding | Level Behavior |
|---------+------------+----------------|
| =claude-org-insert-session-block= | | Uses current section level |
| =claude-org-insert-story= | =C-c C-s= | Aligns with previous story, or top level if none |

Story level alignment: When inserting a new story, the function searches backwards
for an existing story section (heading with =CLAUDE_SESSION_ID= starting with "story-").
If found, the new story uses the same level. If no previous story exists, it defaults
to top level (=*=), keeping stories at a consistent hierarchy.

#+NAME: block-insert-session-story
#+BEGIN_SRC elisp
(defun claude-org-insert-session-block ()
  "Insert an AI query block with independent section-scoped session.
The :claude_session: tag creates a new conversation context for this subtree."
  (interactive)
  (let* ((level (or (org-current-level) 1))
         (stars (make-string level ?*))
         (num (claude-org--next-instruction-number)))
    (insert stars " Session " (number-to-string num) " :" claude-org-session-tag ":\n\n")
    (insert "#+begin_src ai\n\n#+end_src")
    (forward-line -1)))

(defun claude-org--find-previous-story-level ()
  "Find the level of the most recent story section before point.
Searches backwards from current position for a heading with CLAUDE_SESSION_ID
property starting with 'story-'. Returns the level (integer) or nil if not found."
  (save-excursion
    (save-restriction
      (widen)
      (let ((start-pos (point))
            (found-level nil))
        ;; Search backwards through all headings
        (while (and (not found-level)
                    (re-search-backward "^\\*+ " nil t))
          (when (string-prefix-p "story-" (or (org-entry-get nil "CLAUDE_SESSION_ID") ""))
            (setq found-level (org-current-level))))
        ;; If not found before point, search from beginning (for stories after point)
        (unless found-level
          (goto-char (point-min))
          (while (and (not found-level)
                      (re-search-forward "^\\*+ " start-pos t))
            (when (string-prefix-p "story-" (or (org-entry-get nil "CLAUDE_SESSION_ID") ""))
              (setq found-level (org-current-level)))))
        found-level))))

(defun claude-org-insert-story ()
  "Insert a new story section with unique CLAUDE_SESSION_ID.
Prompts for story title and creates a section with session property.
The story has its own isolated conversation context.
Aligns section level with previous story if any exists, otherwise uses top level."
  (interactive)
  (let* ((title (read-string "Story title: "))
         (session-id (format "story-%s" (format-time-string "%Y%m%d-%H%M%S")))
         ;; Align with previous story level, or use top level (1) if no story exists
         (level (or (claude-org--find-previous-story-level) 1))
         (stars (make-string level ?*)))
    ;; Insert heading
    (insert stars " " title "\n")
    ;; Insert property drawer with session ID
    (insert ":PROPERTIES:\n")
    (insert ":CLAUDE_SESSION_ID: " session-id "\n")
    (insert ":END:\n\n")
    ;; Position cursor for content
    (message "Created story '%s' with session ID: %s" title session-id)))

(defun claude-org--find-previous-sdd-level ()
  "Find the level of the most recent SDD section before point.
Searches backwards from current position for a heading with CLAUDE_SESSION_ID
property starting with 'sdd-'. Returns the level (integer) or nil if not found."
  (save-excursion
    (save-restriction
      (widen)
      (let ((start-pos (point))
            (found-level nil))
        ;; Search backwards through all headings
        (while (and (not found-level)
                    (re-search-backward "^\\*+ " nil t))
          (when (string-prefix-p "sdd-" (or (org-entry-get nil "CLAUDE_SESSION_ID") ""))
            (setq found-level (org-current-level))))
        ;; If not found before point, search from beginning (for SDDs after point)
        (unless found-level
          (goto-char (point-min))
          (while (and (not found-level)
                      (re-search-forward "^\\*+ " start-pos t))
            (when (string-prefix-p "sdd-" (or (org-entry-get nil "CLAUDE_SESSION_ID") ""))
              (setq found-level (org-current-level)))))
        found-level))))

(defun claude-org-insert-sdd ()
  "Insert an SDD (Spec-Driven Development) structure.
Creates four sections in order:
1. Workflow :sdd: with a single AI block (user adds phase tags manually)
2. Research Output :research_output: with Patterns/Files/External subsections
3. Spec :spec: with Goals/Non-Goals/Proposed Solution/Technical Design
4. Features :features: with ORDERED property for TODO tracking

The structure follows the Atomic workflow pattern:
- Workflow: AI interaction happens here (user selects phase tags per block)
- Research Output: Synthesized findings from exploration
- Spec: Living RFC document that evolves with the project
- Features: Atomic TODO items, each small enough to complete in one session

Each section gets a CUSTOM_ID property for stable cross-file linking.
Format: file-base-section-slug-session-id (e.g., claude-agent-dev-research-output-sdd-20251227-180147)

Prompts for feature name and sets up unique CLAUDE_SESSION_ID.
Aligns section level with previous SDD if any exists, otherwise uses top level."
  (interactive)
  (let* ((name (read-string "Feature name: "))
         (session-id (format "sdd-%s" (format-time-string "%Y%m%d-%H%M%S")))
         (file-base (when buffer-file-name (file-name-base buffer-file-name)))
         ;; Align with previous SDD level, or use top level (1) if none exists
         (level (or (claude-org--find-previous-sdd-level) 1))
         (stars (make-string level ?*))
         (stars2 (make-string (1+ level) ?*))
         (stars3 (make-string (+ 2 level) ?*)))
    ;; Insert top-level heading with session
    (insert stars " " name "\n")
    (insert ":PROPERTIES:\n")
    (insert ":CLAUDE_SESSION_ID: " session-id "\n")
    (insert ":END:\n\n")

    ;; 1. Insert Workflow section with single AI block (no phase tags)
    (insert stars2 " Workflow :sdd:\n")
    (insert ":PROPERTIES:\n")
    (insert ":CUSTOM_ID: " (claude-org--generate-custom-id session-id "Workflow" file-base) "\n")
    (insert ":END:\n\n")
    ;; Insert Instruction 1 with CUSTOM_ID for stable navigation
    (insert stars3 " Instruction 1 :research:" claude-org-heading-tag ":\n")
    (insert ":PROPERTIES:\n")
    (insert ":CUSTOM_ID: " (claude-org--generate-instruction-custom-id file-base 1 session-id) "\n")
    (insert ":END:\n\n")
    (insert "#+begin_src ai\n\n#+end_src\n\n")

    ;; 2. Insert Research Output section for findings
    (insert stars2 " Research Output :research_output:\n")
    (insert ":PROPERTIES:\n")
    (insert ":CUSTOM_ID: " (claude-org--generate-custom-id session-id "Research Output" file-base) "\n")
    (insert ":END:\n\n")
    (dolist (section '("Codebase Patterns" "Relevant Files" "External References"))
      (insert stars3 " " section "\n\n"))

    ;; 3. Insert Spec section with subsections
    (insert stars2 " Spec :spec:\n")
    (insert ":PROPERTIES:\n")
    (insert ":CUSTOM_ID: " (claude-org--generate-custom-id session-id "Spec" file-base) "\n")
    (insert ":END:\n\n")
    (dolist (section '("Goals" "Non-Goals" "Proposed Solution" "Technical Design"))
      (insert stars3 " " section "\n\n"))

    ;; 4. Insert Features section with ORDERED property and CUSTOM_ID
    (insert stars2 " Features :features:\n")
    (insert ":PROPERTIES:\n")
    (insert ":CUSTOM_ID: " (claude-org--generate-custom-id session-id "Features" file-base) "\n")
    (insert ":ORDERED: t\n")
    (insert ":END:\n\n")

    ;; Position cursor inside the AI block
    (re-search-backward "^#\\+begin_src ai")
    (forward-line 1)
    (message "Created SDD '%s' with session ID: %s" name session-id)))
#+END_SRC

** Session Info Display

Diagnostic command showing current session identity - useful for understanding
which conversation context will be used for the next query.

#+NAME: block-insert-session-info
#+BEGIN_SRC elisp
(defun claude-org-show-session-info ()
  "Display current session information.
Shows the session identity which is file_path + optional CLAUDE_SESSION_ID."
  (interactive)
  (let* ((session-id (claude-org--get-session-id))
         (scope (claude-org--get-session-scope))
         (file-path (or buffer-file-name "unsaved")))
    (if session-id
        (message "Session: %s::%s (scope: %s)" file-path session-id scope)
      (message "Session: %s (file path only, no CLAUDE_SESSION_ID property)" file-path))))
#+END_SRC

* Slash Command Completion

Auto-completion for Claude Code slash commands in AI blocks.

** Command Discovery

#+BEGIN_SRC elisp
(defun claude-org--scan-command-dir (dir)
  "Scan DIR for .md files and return list of slash commands.
Subdirectories create namespaced commands with : separator.
Example: dir/custom/test.md becomes /custom:test"
  (when (file-directory-p dir)
    (let ((commands nil))
      (dolist (file (directory-files-recursively dir "\\.md$"))
        (let* ((relative (file-relative-name file dir))
               (parts (split-string relative "/"))
               (name (file-name-sans-extension (car (last parts))))
               (namespace (butlast parts)))
          (push (if namespace
                    (concat "/" (mapconcat #'identity namespace ":") ":" name)
                  (concat "/" name))
                commands)))
      commands)))

(defun claude-org--scan-plugin-commands ()
  "Scan plugin commands from ~/.claude/plugins/marketplaces/*/plugins/*/commands/*.md.
Returns list of slash commands with plugin namespace.
Example: /plugin-name:command"
  (let ((commands nil)
        (plugins-dir (expand-file-name "~/.claude/plugins")))
    (when (file-directory-p plugins-dir)
      ;; Scan both direct plugins and marketplace plugins
      (dolist (search-pattern (list (expand-file-name "*/commands" plugins-dir)
                                     (expand-file-name "marketplaces/*/plugins/*/commands" plugins-dir)))
        (dolist (commands-dir (file-expand-wildcards search-pattern))
          (when (file-directory-p commands-dir)
            (let* ((plugin-dir (file-name-directory (directory-file-name commands-dir)))
                   (plugin-name (file-name-nondirectory (directory-file-name plugin-dir))))
              ;; Only scan root of commands/ (flat, no recursion)
              (dolist (file (directory-files commands-dir nil "\\.md$"))
                (let ((cmd-name (file-name-sans-extension file)))
                  (push (concat "/" plugin-name ":" cmd-name) commands))))))))
    commands))

(defun claude-org--discover-slash-commands ()
  "Discover all available slash commands from user, project, and plugins.
Returns list of command strings with / prefix."
  (let ((commands (copy-sequence claude-org-builtin-slash-commands))
        (user-dir (expand-file-name "~/.claude/commands"))
        (project-root (claude-org--get-project-root)))
    ;; Add user commands
    (setq commands (append commands (claude-org--scan-command-dir user-dir)))
    ;; Add project commands if PROJECT_ROOT is set
    (when project-root
      (let ((project-dir (expand-file-name ".claude/commands" project-root)))
        (setq commands (append commands (claude-org--scan-command-dir project-dir)))))
    ;; Add plugin commands
    (setq commands (append commands (claude-org--scan-plugin-commands)))
    ;; Remove duplicates (first match wins)
    (delete-dups commands)
    commands))
#+END_SRC

** Company Backend

#+BEGIN_SRC elisp
(defun claude-org--at-line-start-p ()
  "Check if point is at the start of a line (ignoring whitespace)."
  (save-excursion
    (skip-chars-backward " \t")
    (bolp)))

(defun claude-org-company-slash-commands (command &optional arg &rest ignored)
  "Company backend for Claude slash commands in AI blocks.
Only triggers when / is at the start of a line."
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'claude-org-company-slash-commands))
    (prefix (when (claude-org--in-ai-block-p)
              (if (and (save-excursion
                         ;; Skip back over the partial command and whitespace
                         (skip-chars-backward "/a-z:_- \t")
                         (bolp))
                       (looking-back "/[a-z:_-]*" (line-beginning-position)))
                  ;; Return prefix with :length 1 to trigger on just "/"
                  ;; This overrides company-minimum-prefix-length
                  (let ((prefix (match-string-no-properties 0)))
                    (cons prefix (length prefix)))
                ;; In AI block but not a slash command - don't interfere
                nil)))
    (candidates (let ((commands (claude-org--discover-slash-commands)))
                  (cl-remove-if-not
                   (lambda (c) (string-prefix-p arg c t))  ;; case-insensitive
                   commands)))
    (sorted t)))
#+END_SRC

* Response Handling

Response handling for streaming tokens.

** Debounced Font-Lock

#+BEGIN_SRC elisp
(defun claude-org--schedule-fontlock ()
  "Schedule a debounced font-lock refresh.
Batches rapid updates during streaming for better performance."
  (when claude-org--fontlock-timer
    (cancel-timer claude-org--fontlock-timer))
  (setq claude-org--fontlock-timer
        (run-with-timer claude-org-fontlock-delay nil
                        (lambda ()
                          (when (and (buffer-live-p (current-buffer))
                                     (derived-mode-p 'org-mode))
                            (font-lock-flush)
                            (redisplay))))))
#+END_SRC

** Header Normalization

Normalize org headers in Claude's output to fit the document hierarchy.
Headers are adjusted so Claude's top-level (=*=) becomes the target level.

Uses simple regex replacement - no buffering needed since =^= matches
both start of string and start of line (after newline).

#+BEGIN_SRC elisp
(defun claude-org--normalize-headers-in-text (text target-level)
  "Normalize org headers in TEXT to start at TARGET-LEVEL.
Headers at line start are adjusted: Claude's level N becomes target-level + (N-1).
Only lines starting with asterisks followed by space are treated as headers.
Also normalizes line endings: \\r\\n (DOS) and \\r (old Mac) become \\n.
No buffering - processes each token independently using regex."
  ;; Normalize line endings: \r\n -> \n, then \r -> \n
  (let ((clean-text (replace-regexp-in-string "\r\n?" "\n" text)))
    (if (not claude-org-normalize-headers)
        clean-text
      (let ((offset (1- target-level)))
        (replace-regexp-in-string
         "^\\(\\*+\\) "
         (lambda (match)
           (let* ((stars (match-string 1 match))
                  (new-level (+ (length stars) offset)))
             (concat (make-string (max 1 new-level) ?*) " ")))
         clean-text)))))

(defun claude-org--auto-break-lines (text current-line-length)
  "Auto-break long lines in TEXT after sentence-ending punctuation.
CURRENT-LINE-LENGTH is the length of the current line before this text.
Returns (NEW-TEXT . NEW-LINE-LENGTH) cons cell.
Only active when `claude-org-auto-break-line-length' is positive."
  (if (< claude-org-auto-break-line-length 1)
      ;; Disabled - return text unchanged, update line length
      (let ((last-newline (string-match-p "\n[^\n]*\\'" text)))
        (cons text
              (if last-newline
                  (- (length text) last-newline 1)
                (+ current-line-length (length text)))))
    ;; Enabled - process text for line breaks
    (let ((result "")
          (line-len current-line-length)
          (threshold claude-org-auto-break-line-length)
          (i 0)
          (len (length text)))
      (while (< i len)
        (let ((char (aref text i)))
          ;; Always add char to result and increment line length first
          (setq result (concat result (char-to-string char)))
          (setq line-len (1+ line-len))
          (cond
           ;; Newline resets counter
           ((= char ?\n)
            (setq line-len 0))
           ;; Check for sentence-ending punctuation followed by space
           ;; Break if line length exceeds threshold
           ((and (>= line-len threshold)
                 (memq char '(?. ?! ?\?))
                 (< (1+ i) len)
                 (= (aref text (1+ i)) ?\s))
            ;; Insert newline after the punctuation
            (setq result (concat result "\n"))
            (setq line-len 0))))
        (setq i (1+ i)))
      (cons result line-len))))
#+END_SRC

** Token Handling

#+BEGIN_SRC elisp
(defun claude-org--handle-token (session-key text)
  "Handle incoming TEXT token for SESSION-KEY.
Normalizes org headers, auto-breaks long lines, and inserts text at the session's marker."
  (let ((marker (claude-org--session-get session-key :marker)))
    (when (and marker (marker-buffer marker))
      (with-current-buffer (marker-buffer marker)
        (let* ((target-level (1+ (or (claude-org--session-get session-key :section-level) 0)))
               (normalized-text (claude-org--normalize-headers-in-text text target-level))
               ;; Auto-break long lines
               (current-line-len (or (claude-org--session-get session-key :current-line-length) 0))
               (break-result (claude-org--auto-break-lines normalized-text current-line-len))
               (final-text (car break-result))
               (new-line-len (cdr break-result)))
          ;; Update line length state
          (claude-org--session-put session-key :current-line-length new-line-len)
          ;; Insert processed text
          (when (> (length final-text) 0)
            (save-excursion
              (goto-char marker)
              (insert final-text)
              (set-marker marker (point)))))
        (claude-org--schedule-fontlock)))))
#+END_SRC

** Message Handling

#+BEGIN_SRC elisp
(defun claude-org--format-todo-item (todo)
  "Format a single TODO item as org checkbox.
TODO is a plist with :content, :status, and :activeForm.
When status is in_progress, show activeForm instead of content
since activeForm is the present continuous form of the same task."
  (let* ((content (plist-get todo :content))
         (status (plist-get todo :status))
         (active-form (plist-get todo :activeForm))
         (checkbox (pcase status
                     ("completed" "[X]")
                     ("in_progress" "[-]")
                     (_ "[ ]")))
         ;; Use activeForm for in_progress, content otherwise
         (display-text (if (and (string= status "in_progress") active-form)
                           active-form
                         content)))
    (format "- %s %s" checkbox display-text)))

(defun claude-org--format-todos (todos)
  "Format TODOS list as org checkbox list.
TODOS is a list of plists with :content, :status, :activeForm."
  (when todos
    (concat "\n*Todos:*\n"
            (mapconcat #'claude-org--format-todo-item todos "\n")
            "\n")))

(defun claude-org--handle-tool-use (session-key tool-name tool-input)
  "Handle special TOOL-NAME with TOOL-INPUT for SESSION-KEY.
Returns formatted string to insert, or nil if not a special tool."
  (pcase tool-name
    ("TodoWrite"
     (let ((todos (plist-get tool-input :todos)))
       (claude-org--format-todos todos)))
    (_ nil)))

(defun claude-org--handle-message (session-key msg)
  "Handle incoming MSG for SESSION-KEY.
Extracts session ID from result messages and stores it."
  ;; Store SDK UUID to org property when we get a result message
  (when (claude-agent-result-message-p msg)
    (let ((sdk-uuid (claude-agent-result-message-session-id msg))
          (marker (claude-org--session-get session-key :marker)))
      (when (and sdk-uuid marker (marker-buffer marker))
        (with-current-buffer (marker-buffer marker)
          (save-excursion
            (goto-char marker)
            (claude-org--set-sdk-uuid sdk-uuid))))))
  ;; Handle special tool uses in assistant messages
  (when (claude-agent-assistant-message-p msg)
    (let ((marker (claude-org--session-get session-key :marker)))
      (when (and marker (marker-buffer marker))
        (dolist (block (claude-agent-assistant-message-content msg))
          (when (claude-agent-tool-use-block-p block)
            (let* ((tool-name (claude-agent-tool-use-block-name block))
                   (tool-input (claude-agent-tool-use-block-input block))
                   (formatted (claude-org--handle-tool-use session-key tool-name tool-input)))
              (when formatted
                (with-current-buffer (marker-buffer marker)
                  (save-excursion
                    (goto-char marker)
                    (insert formatted)
                    (set-marker marker (point)))))))))))
  ;; Display system messages if enabled
  (when (and claude-org-show-system-messages
             (claude-agent-system-message-p msg))
    (let ((marker (claude-org--session-get session-key :marker)))
      (when (and marker (marker-buffer marker))
        (with-current-buffer (marker-buffer marker)
          (save-excursion
            (goto-char marker)
            (insert (format "\n[System: %s]\n"
                            (claude-agent-system-message-subtype msg)))
            (set-marker marker (point))))))))

(defun claude-org--handle-complete (session-key result)
  "Handle query completion for SESSION-KEY with RESULT."
  (claude-org--session-put session-key :busy nil)
  (claude-org--session-put session-key :recovering nil)
  (claude-org--stop-spinner session-key)
  ;; Add newlines after response
  (let ((marker (claude-org--session-get session-key :marker)))
    (when (and marker (marker-buffer marker))
      (with-current-buffer (marker-buffer marker)
        (save-excursion
          (goto-char marker)
          (insert "\n")))))
  ;; Update header line
  (claude-org--refresh-header-line)
  ;; Run completion hook
  (run-hook-with-args 'claude-org-complete-hook session-key result 'completed))
#+END_SRC

** Error Handling

#+BEGIN_SRC elisp
(defun claude-org--extract-error-message (error)
  "Extract human-readable message from ERROR.
ERROR can be (symbol :message ...) plist, a string, or other."
  (cond
   ;; CLI error: (claude-agent-cli-error :message "..." ...) - plist starts at cdr
   ((and (listp error) (symbolp (car error)) (plist-get (cdr error) :message))
    (plist-get (cdr error) :message))
   ;; Plain plist with :message
   ((and (listp error) (plist-get error :message))
    (plist-get error :message))
   ;; String error
   ((stringp error) error)
   ;; Fallback: convert to string
   (t (format "%s" error))))

(defun claude-org--handle-error (session-key error)
  "Handle error ERROR for SESSION-KEY.
Attempts session recovery if error indicates expired session or context too long."
  (let ((error-msg (claude-org--extract-error-message error)))
    (cond
     ;; Context too long - clear UUID and recover with conversation history
     ((and (claude-agent--context-too-long-p error-msg)
           (not (claude-org--session-get session-key :recovering)))
      (message "Claude context limit reached, starting fresh session with history...")
      (claude-org--recover-session session-key 'context-limit))
     ;; Session expired - clear UUID and recover
     ((and (claude-agent--session-expired-p error-msg)
           (not (claude-org--session-get session-key :recovering)))
      (message "Claude session expired, starting new session...")
      (claude-org--recover-session session-key 'expired))
     ;; Other error - display it
     (t
      (claude-org--insert-error session-key error-msg)))))

(defun claude-org--insert-error (session-key error-msg)
  "Insert ERROR-MSG at SESSION-KEY's marker and clean up."
  (claude-org--session-put session-key :busy nil)
  (claude-org--stop-spinner session-key)
  (let ((marker (claude-org--session-get session-key :marker)))
    (when (and marker (marker-buffer marker))
      (with-current-buffer (marker-buffer marker)
        (save-excursion
          (goto-char marker)
          (insert (format "\n[Error: %s]\n" error-msg))
          (set-marker marker (point))))))
  (claude-org--refresh-header-line)
  ;; Run completion hook with error status
  (run-hook-with-args 'claude-org-complete-hook session-key error-msg 'error))
#+END_SRC

* Block History

Functions for tracking and navigating executed AI blocks. History persists
to disk so it survives Emacs restarts.

** Persistence Functions

#+NAME: history-persistence
#+BEGIN_SRC elisp
(defun claude-org--history-file-path ()
  "Return path to history file for current buffer.
Uses format: <basename>--<short-hash>.el for readability."
  (let* ((org-path (buffer-file-name))
         (basename (file-name-sans-extension
                    (file-name-nondirectory org-path)))
         (hash (substring (md5 org-path) 0 8))
         (dir claude-org-history-directory))
    (expand-file-name (format "%s--%s.el" basename hash) dir)))

(defun claude-org--ensure-history-directory ()
  "Ensure the history directory exists."
  (unless (file-directory-p claude-org-history-directory)
    (make-directory claude-org-history-directory t)))

(defun claude-org--load-history ()
  "Load history from disk for current buffer."
  (when (and (buffer-file-name)
             (not claude-org--history-loaded))
    (let ((history-file (claude-org--history-file-path)))
      (when (file-exists-p history-file)
        (condition-case err
            (with-temp-buffer
              (insert-file-contents history-file)
              (let ((data (read (current-buffer))))
                (when (and (plist-get data :blocks)
                           (string= (plist-get data :org-file)
                                    (buffer-file-name)))
                  (setq claude-org--block-history
                        (plist-get data :blocks)))))
          (error
           (message "claude-org: Failed to load history: %s" err)))))
    (setq claude-org--history-loaded t)))

(defun claude-org--save-history ()
  "Save history to disk for current buffer (debounced)."
  (when (buffer-file-name)
    ;; Cancel existing timer
    (when claude-org--history-save-timer
      (cancel-timer claude-org--history-save-timer))
    ;; Schedule save
    (setq claude-org--history-save-timer
          (run-with-timer
           claude-org--history-save-delay nil
           (lambda (buf)
             (when (buffer-live-p buf)
               (with-current-buffer buf
                 (claude-org--save-history-now))))
           (current-buffer)))))

(defun claude-org--save-history-now ()
  "Immediately save history to disk."
  (when (and (buffer-file-name) claude-org--block-history)
    (claude-org--ensure-history-directory)
    (let ((history-file (claude-org--history-file-path))
          (data `(:version 2  ; Version 2: Added :custom-id for stable navigation
                  :org-file ,(buffer-file-name)
                  :updated ,(float-time)
                  :blocks ,(claude-org--prepare-history-for-save))))
      (with-temp-file history-file
        (insert ";; -*- mode: lisp-data -*-\n")
        (insert ";; Claude-org block history - do not edit\n")
        (pp data (current-buffer))))))

(defun claude-org--prepare-history-for-save ()
  "Prepare history for saving by removing transient data.
Keeps only the most recent `claude-org-history-max-entries' entries.
Includes :title for display and :custom-id for navigation."
  (let ((entries (mapcar
                  (lambda (entry)
                    (let ((id (car entry))
                          (plist (cdr entry)))
                      ;; Remove :marker (not persistent), keep title and custom-id
                      (cons id (cl-list* :timestamp (plist-get plist :timestamp)
                                         :status (plist-get plist :status)
                                         :title (plist-get plist :title)
                                         :custom-id (plist-get plist :custom-id)
                                         :line (plist-get plist :line)
                                         nil))))
                  claude-org--block-history)))
    ;; Sort by timestamp, keep most recent
    (setq entries (sort entries
                        (lambda (a b)
                          (> (or (plist-get (cdr a) :timestamp) 0)
                             (or (plist-get (cdr b) :timestamp) 0)))))
    (seq-take entries claude-org-history-max-entries)))

(defun claude-org--ensure-history-loaded ()
  "Ensure history is loaded from disk."
  (unless claude-org--history-loaded
    (claude-org--load-history)))
#+END_SRC

** Hook Functions

Default hook functions for block history tracking.

#+NAME: history-hooks
#+BEGIN_SRC elisp
(defun claude-org--find-instruction-info ()
  "Find the instruction heading info containing point.
Searches backward for a heading with :claude_chat: tag.
Returns plist with :custom-id and :title, or nil if not found."
  (save-excursion
    (let ((found nil))
      ;; First try walking up headings
      (while (and (not found) (org-up-heading-safe))
        (when (member "claude_chat" (org-get-tags nil t))
          (setq found (list :custom-id (org-entry-get nil "CUSTOM_ID")
                            :title (substring-no-properties (org-get-heading t t t t))))))
      ;; If not found, search backward for :claude_chat: heading
      (unless found
        (when (re-search-backward "^\\*+.*:claude_chat:" nil t)
          (setq found (list :custom-id (org-entry-get nil "CUSTOM_ID")
                            :title (substring-no-properties (org-get-heading t t t t))))))
      found)))

(defun claude-org--record-block-execution (session-key query marker)
  "Record block execution start.
SESSION-KEY identifies the session, QUERY is the prompt text,
MARKER points to the AI block.
Stores instruction heading title and CUSTOM_ID for display and navigation."
  (claude-org--ensure-history-loaded)
  (let* ((block-id (format "block-%d-%s"
                           (line-number-at-pos (marker-position marker))
                           (format-time-string "%H%M%S")))
         ;; Find instruction heading info (title and CUSTOM_ID)
         (instruction-info (save-excursion
                             (goto-char (marker-position marker))
                             (claude-org--find-instruction-info)))
         (entry `(:timestamp ,(float-time)
                  :status in-progress
                  :title ,(plist-get instruction-info :title)
                  :custom-id ,(plist-get instruction-info :custom-id)
                  :line ,(line-number-at-pos (marker-position marker))
                  :marker ,marker
                  :session-key ,session-key)))
    ;; Add to history (at front for recent-first ordering)
    (push (cons block-id entry) claude-org--block-history)
    ;; Store block-id in session for later status update
    (claude-org--session-put session-key :block-id block-id)
    ;; Trigger debounced save
    (claude-org--save-history)))

(defun claude-org--update-block-status (session-key _result status)
  "Update block status on completion.
SESSION-KEY identifies the session, STATUS is `completed' or `error'."
  (let ((block-id (claude-org--session-get session-key :block-id)))
    (when block-id
      (let ((entry (assoc block-id claude-org--block-history)))
        (when entry
          (plist-put (cdr entry) :status status)
          (claude-org--save-history))))))

;; Register default hooks
(add-hook 'claude-org-execute-after-hook #'claude-org--record-block-execution)
(add-hook 'claude-org-complete-hook #'claude-org--update-block-status)
#+END_SRC

** Navigation Functions

Functions for collecting and navigating to recent blocks.

#+NAME: history-navigation
#+BEGIN_SRC elisp
(defun claude-org--format-time-ago (timestamp)
  "Format TIMESTAMP as relative time string."
  (let* ((now (float-time))
         (diff (- now timestamp))
         (minutes (floor (/ diff 60)))
         (hours (floor (/ diff 3600)))
         (days (floor (/ diff 86400))))
    (cond
     ((< diff 60) "just now")
     ((< minutes 60) (format "%dm ago" minutes))
     ((< hours 24) (format "%dh ago" hours))
     (t (format "%dd ago" days)))))

(defun claude-org--build-block-title-from-custom-id (custom-id)
  "Build a meaningful title by navigating to CUSTOM_ID heading.
Returns \"Instruction Title (Story Name)\" format when possible.
CUSTOM_ID should point to the instruction heading with :claude_chat: tag."
  (when custom-id
    (save-excursion
      (save-restriction
        (widen)
        (condition-case nil
            (progn
              ;; Navigate to the heading with CUSTOM_ID
              (org-link-search (format "#%s" custom-id))
              ;; Get the instruction title (current heading)
              (let ((instruction (substring-no-properties (org-get-heading t t t t)))
                    (story nil))
                ;; Walk up to find story context (level 1-2, skip Workflow)
                (save-excursion
                  (while (and (not story) (org-up-heading-safe))
                    (let ((heading (substring-no-properties (org-get-heading t t t t)))
                          (level (org-current-level)))
                      (when (and (<= level 2)
                                 (not (string= heading "Workflow")))
                        (setq story heading)))))
                ;; Build the combined title
                (cond
                 ((and story (not (string= story instruction)))
                  (format "%s (%s)" instruction story))
                 (t instruction))))
          (error nil))))))

(defun claude-org--format-block-candidate (entry)
  "Format ENTRY for display in completing-read.
ENTRY is (BLOCK-ID . PLIST).
Uses stored instruction title from when block was executed."
  (let* ((plist (cdr entry))
         (status (plist-get plist :status))
         ;; Use stored title (captured at execution time)
         (title (or (plist-get plist :title) "Untitled"))
         (timestamp (plist-get plist :timestamp))
         (status-icon (pcase status
                        ('completed "✓")
                        ('in-progress "⋯")
                        ('error "✗")
                        (_ "?")))
         (time-str (if timestamp
                       (claude-org--format-time-ago timestamp)
                     "unknown")))
    (format "[%s] %s (%s)"
            status-icon
            (truncate-string-to-width title 100 nil nil "…")
            time-str)))

(defun claude-org--collect-recent-blocks ()
  "Collect recent blocks for completing-read.
Returns alist of (DISPLAY-STRING . ENTRY)."
  (claude-org--ensure-history-loaded)
  (mapcar (lambda (entry)
            (cons (claude-org--format-block-candidate entry) entry))
          claude-org--block-history))

(defun claude-org--goto-block-by-line (line)
  "Navigate to AI block at LINE, searching nearby if exact match fails."
  (goto-char (point-min))
  (forward-line (1- line))
  ;; Verify we're at an AI block, search nearby if not
  (unless (claude-org--in-ai-block-p)
    (let ((found nil)
          (orig-point (point))
          (search-range 10))
      ;; Search forward
      (save-excursion
        (dotimes (_ search-range)
          (when (and (not found)
                     (re-search-forward "#\\+begin_src ai" nil t))
            (setq found (match-beginning 0)))))
      ;; If not found forward, try backward
      (unless found
        (save-excursion
          (goto-char orig-point)
          (when (re-search-backward "#\\+begin_src ai" nil t)
            (setq found (match-beginning 0)))))
      (when found
        (goto-char found)))))

(defun claude-org--goto-block-by-custom-id (custom-id)
  "Navigate to AI block via CUSTOM_ID using org-link-search.
Returns t if navigation succeeded, nil otherwise."
  (condition-case nil
      (progn
        (org-link-search (format "#%s" custom-id))
        t)
    (error nil)))

(defun claude-org-jump-to-ai-block ()
  "Jump to a recent AI block.
Shows a list of recently executed blocks with status and timing.
Uses CUSTOM_ID for stable navigation (survives file edits),
falling back to line number for legacy blocks.
After navigation, unfolds the target section to make the block visible."
  (interactive)
  (claude-org--ensure-history-loaded)
  (let ((candidates (claude-org--collect-recent-blocks)))
    (if (null candidates)
        (message "No AI block history found")
      (let* ((selection (completing-read "Jump to: " candidates nil t))
             (entry (cdr (assoc selection candidates)))
             (plist (cdr entry))
             (marker (plist-get plist :marker))
             (custom-id (plist-get plist :custom-id))
             (line (plist-get plist :line))
             (navigated nil))
        (cond
         ;; Use marker if still valid (same session)
         ((and marker (marker-buffer marker) (buffer-live-p (marker-buffer marker)))
          (switch-to-buffer (marker-buffer marker))
          (goto-char (marker-position marker))
          (setq navigated t))
         ;; Try CUSTOM_ID for stable navigation (works across file edits)
         ((and custom-id (claude-org--goto-block-by-custom-id custom-id))
          (setq navigated t))
         ;; Fall back to line number
         (line
          (claude-org--goto-block-by-line line)
          (setq navigated t))
         (t
          (message "Cannot navigate to block - no position info")))
        ;; Unfold the target section to make the block visible
        (when navigated
          (org-reveal t)
          (recenter))))))
#+END_SRC

* Execution

Execution and request handling.

** Execute Command

#+BEGIN_SRC elisp
(defun claude-org-execute ()
  "Execute the AI query at point.
Must be called when point is inside a #+begin_src ai block.
Sends the query to Claude and streams the response below the block.
When `claude-org-auto-create-response-section' is non-nil, creates a Response
section with :ai_output: tag for flat pattern organization.
When `claude-org-auto-generate-title' is non-nil, generates a title for
headings matching `claude-org-auto-title-heading-pattern' using Haiku."
  (interactive)
  (unless (claude-org--in-ai-block-p)
    (user-error "Not inside an ai block. Use #+begin_src ai ... #+end_src"))
  (let* ((content (claude-org--get-block-content))
         (session-key (claude-org--current-session-key))
         ;; Check for auto-title BEFORE any buffer modifications
         (should-auto-title (and claude-org-auto-generate-title
                                 (claude-org--heading-matches-auto-title-pattern-p)))
         ;; Create marker at heading position for title update
         (heading-marker (when should-auto-title
                           (save-excursion
                             (org-back-to-heading t)
                             (copy-marker (point))))))
    (unless content
      (user-error "Empty ai block"))
    (when (claude-org--session-get session-key :busy)
      (user-error "Session is busy. Use C-c C-k to cancel or wait for completion"))
    ;; Find insertion point (after #+end_src)
    (let ((insert-point (claude-org--find-block-end))
          (instr-num (claude-org--find-instruction-number)))
      (unless insert-point
        (user-error "Cannot find block end"))
      ;; Set up marker at insertion point
      (save-excursion
        (goto-char insert-point)
        (insert "\n\n")
        ;; Create Response section if enabled and we found an instruction number
        (when (and claude-org-auto-create-response-section instr-num)
          (let* ((level (claude-org--get-section-level))
                 (stars (make-string level ?*)))
            (insert stars " Response " (number-to-string instr-num)
                    " :" claude-org-output-tag ":\n\n")))
        (let ((marker (point-marker)))
          (claude-org--session-put session-key :marker marker)
          (claude-org--session-put session-key :original-prompt content)
          (claude-org--session-put session-key :section-level (claude-org--get-section-level))
          (claude-org--session-put session-key :start-time (float-time))
          (claude-org--session-put session-key :busy t)
          ;; Run pre-execution hook
          (run-hook-with-args 'claude-org-execute-hook session-key content marker)))
      ;; Start spinner and send request
      (claude-org--start-spinner session-key)
      ;; Auto-generate title in parallel (using Haiku, separate session)
      (when heading-marker
        (claude-org--maybe-auto-generate-title content heading-marker))
      ;; Pass instruction number for session manager display
      (claude-org--send-request content instr-num)
      ;; Run post-execution hook (after query sent)
      (let ((marker (claude-org--session-get session-key :marker)))
        (run-hook-with-args 'claude-org-execute-after-hook session-key content marker)))))

(defun org-babel-execute:ai (body _params)
  "Execute an AI block via claude-org.
BODY is the query text, PARAMS are org-babel header arguments.
This integrates with org-babel's C-c C-c execution mechanism."
  (claude-org-execute)
  ;; Return nil - output is streamed directly into buffer
  nil)

;; Suppress #+RESULTS: section for ai blocks (output streams directly into buffer)
(setq org-babel-default-header-args:ai '((:results . "none")))
#+END_SRC

** Send Request Helpers

#+BEGIN_SRC elisp
(defun claude-org--build-ide-context-reminder (project-root)
  "Build IDE context system reminder for PROJECT-ROOT.
Returns nil if IDE context is disabled or unavailable."
  (when claude-org-include-ide-context
    (let ((ide-context (claude-agent-collect-ide-context
                        (or project-root default-directory)))
          ;; Hint for org header normalization
          (org-hint (when claude-org-normalize-headers
                      "When outputting org-mode headers, always use level 1 (*) as top-level. Headers will be auto-adjusted to fit the document hierarchy.")))
      (when ide-context
        (claude-agent-build-system-reminder
         :current-file (plist-get ide-context :current-file)
         :open-files (plist-get ide-context :open-files)
         :selection (plist-get ide-context :selection)
         :file-path buffer-file-name
         :cwd (plist-get ide-context :cwd)
         :extra-lines (when org-hint (list org-hint)))))))

(defun claude-org--build-query-options (project-root system-prompt sdk-uuid)
  "Build options plist for claude-agent query.
PROJECT-ROOT: Working directory
SYSTEM-PROMPT: System prompt text
SDK-UUID: Session UUID for resume"
  (claude-agent-options
   :cwd (or project-root default-directory)
   :system-prompt system-prompt
   :resume sdk-uuid
   :permission-mode (claude-org--get-permission-mode)
   :allowed-tools claude-org-allowed-tools
   :mcp-config (claude-org--get-mcp-config)
   :setting-sources (claude-org--get-setting-sources)
   :env (claude-org--get-env-vars)))
#+END_SRC

** Send Request

#+BEGIN_SRC elisp
(defun claude-org--send-request (prompt &optional instr-num)
  "Send PROMPT to Claude via claude-agent.
INSTR-NUM is the instruction number for display in session manager (optional)."
  (let* ((session-key (claude-org--current-session-key))
         (sdk-uuid (claude-org--get-sdk-uuid))
         (project-root (claude-org--get-project-root))
         (system-prompt (claude-org--build-system-prompt))
         ;; Build IDE context reminder and query options using helpers
         (system-reminder (claude-org--build-ide-context-reminder project-root))
         (options (claude-org--build-query-options project-root system-prompt sdk-uuid))
         ;; Build full prompt with system reminder
         (full-prompt (if (and system-reminder
                               (not (string-empty-p system-reminder)))
                          (concat system-reminder "\n" prompt)
                        prompt))
         ;; Capture source context for session manager display
         (source-buf (current-buffer))
         (source-label (when instr-num (number-to-string instr-num))))
    ;; Use lexical-let to properly capture variables for callbacks
    (lexical-let ((buf source-buf)
                  (session-key session-key))
      ;; Send query via claude-agent
      (let ((state (claude-agent-query
                    full-prompt
                    :options options
                    :session-key session-key
                    :source-buffer source-buf
                    :source-label source-label
                    :on-token (lambda (text)
                                (when (buffer-live-p buf)
                                  (with-current-buffer buf
                                    (claude-org--handle-token session-key text))))
                    :on-message (lambda (msg)
                                  (when (buffer-live-p buf)
                                    (with-current-buffer buf
                                      (claude-org--handle-message session-key msg))))
                    :on-error (lambda (err)
                                (when (buffer-live-p buf)
                                  (with-current-buffer buf
                                    (claude-org--handle-error session-key err))))
                    :on-complete (lambda (result)
                                   (when (buffer-live-p buf)
                                     (with-current-buffer buf
                                       (claude-org--handle-complete session-key result)))))))
        ;; Store process state for cancellation
        (claude-org--session-put session-key :process-state state)))))
#+END_SRC

* Header Line

Dynamic header line showing session status, IDE context, and thinking state.

** State Variables

#+BEGIN_SRC elisp
(defvar-local claude-org--original-header-line nil
  "Original header-line-format before enabling claude-org-mode.")

(defvar-local claude-org--original-truncate-lines nil
  "Original truncate-lines value before enabling claude-org-mode.")

(defconst claude-org--spinner-frames '("|" "/" "-" "\\")
  "Frames for the busy spinner animation.")

(defvar claude-org--header-timer nil
  "Timer for refreshing header line across all claude-org buffers.")

(defvar claude-org--session-badge-map
  (let ((map (make-sparse-keymap)))
    (define-key map [header-line mouse-1] #'claude-org-list-sessions)
    map)
  "Keymap for clicking on the session badge in the header line.")
#+END_SRC

** Spinner Control

#+BEGIN_SRC elisp
(defun claude-org--start-spinner (session-key)
  "Start spinner animation for SESSION-KEY."
  (claude-org--session-put session-key :spinner 0)
  (claude-org--ensure-header-timer))

(defun claude-org--stop-spinner (session-key)
  "Stop spinner animation for SESSION-KEY."
  (claude-org--session-put session-key :spinner nil))
#+END_SRC

** Timer Management

#+BEGIN_SRC elisp
(defun claude-org--ensure-header-timer ()
  "Ensure header refresh timer is running."
  (unless (and claude-org--header-timer
               (timerp claude-org--header-timer))
    (setq claude-org--header-timer
          (run-at-time 0.2 0.2 #'claude-org--refresh-all-headers))))

(defun claude-org--stop-header-timer ()
  "Stop header refresh timer if no active sessions."
  (when (and claude-org--header-timer
             (zerop (claude-org--active-session-count)))
    (cancel-timer claude-org--header-timer)
    (setq claude-org--header-timer nil)))

(defun claude-org--refresh-all-headers ()
  "Refresh header line in all claude-org buffers."
  (dolist (buf (buffer-list))
    (when (buffer-live-p buf)
      (with-current-buffer buf
        (when (bound-and-true-p claude-org-mode)
          (claude-org--refresh-header-line)
          ;; Advance spinner for busy sessions (guard against nil hash table)
          (when (hash-table-p claude-org--sessions)
            (maphash (lambda (key state)
                       (when (plist-get state :busy)
                         (let* ((frame (or (plist-get state :spinner) 0))
                                (next-frame (mod (1+ frame) 4)))
                           (plist-put state :spinner next-frame))))
                     claude-org--sessions)))))))

(defun claude-org--refresh-header-line ()
  "Refresh the header line with current session status."
  (setq header-line-format (claude-org--header-line))
  (force-mode-line-update))
#+END_SRC

** Tooltip Formatting

#+BEGIN_SRC elisp
(defun claude-org--format-session-tooltip ()
  "Format tooltip showing all active sessions."
  (let ((lines (list "Active Sessions" "───────────────────")))
    (maphash
     (lambda (id state)
       (when (plist-get state :busy)
         (let* ((spinner-idx (or (plist-get state :spinner) 0))
                (spinner-char (nth spinner-idx claude-org--spinner-frames))
                (display-name (claude-org--session-display-name id))
                (elapsed (claude-org--format-elapsed (plist-get state :start-time))))
           (push (format "● %s  [%s %s]" display-name spinner-char elapsed)
                 lines))))
     claude-org--sessions)
    (if (= (length lines) 2)
        "No active sessions\n\nClick to open session manager"
      (concat (string-join (nreverse lines) "\n")
              "\n\nClick to open session manager"))))
#+END_SRC

** Header Line Generation

#+BEGIN_SRC elisp
(defun claude-org--header-line ()
  "Generate the header line content for Claude Org buffer."
  (let* ((file-name (if buffer-file-name
                        (file-name-nondirectory buffer-file-name)
                      "untitled"))
         ;; Show user-defined session ID if present
         (session-id (claude-org--get-session-id))
         (session-scope (claude-org--get-session-scope))
         ;; Display: [sec:mysession] or [file:mysession] or [file-only]
         (session-str (if session-id
                          (propertize (format " [%s:%s...]"
                                              (if (eq session-scope 'section) "sec" "file")
                                              (substring session-id 0 (min 12 (length session-id))))
                                      'face (if (eq session-scope 'section)
                                                'font-lock-constant-face
                                              'font-lock-type-face))
                        (propertize " [file-only]" 'face 'font-lock-comment-face)))
         ;; Permission mode indicator
         (perm-str (propertize (format " [%s]" (claude-org--permission-mode-short))
                               'face 'font-lock-warning-face
                               'help-echo (format "Permission: %s (C-c C-p to change)"
                                                  (claude-org--get-permission-mode-display))))
         ;; Active session count badge with thinking indicator
         (active-count (claude-org--active-session-count))
         (active-str (if (> active-count 0)
                         (propertize (format " [%d thinking...]" active-count)
                                     'face '(:foreground "orange" :weight bold)
                                     'help-echo (claude-org--format-session-tooltip)
                                     'mouse-face 'mode-line-highlight
                                     'local-map claude-org--session-badge-map)
                       ""))
         ;; Project root
         (project-root (claude-org--get-project-root))
         (project-str (if project-root
                          (propertize (format " [%s]"
                                              (file-name-nondirectory
                                               (directory-file-name project-root)))
                                      'face 'font-lock-keyword-face)
                        ""))
         ;; Current open file (from IDE context)
         (ide-context (claude-agent-collect-ide-context))
         (current-file (plist-get ide-context :current-file))
         (file-str (if current-file
                       (propertize (format " | %s%s"
                                           (or (plist-get current-file :name) "?")
                                           (if (plist-get current-file :modified) "*" ""))
                                   'face 'font-lock-string-face)
                     ""))
         ;; Selection info
         (selection (plist-get ide-context :selection))
         (sel-str (if (and selection (plist-get selection :text))
                      (let* ((start-line (plist-get selection :start-line))
                             (end-line (plist-get selection :end-line))
                             (text-len (length (plist-get selection :text))))
                        (propertize (format " | sel:%d-%d (%d)" start-line end-line text-len)
                                    'face 'font-lock-comment-face))
                    "")))
    (concat " Claude Org: "
            (propertize file-name 'face 'font-lock-function-name-face)
            session-str perm-str active-str project-str file-str sel-str)))
#+END_SRC

* Cancel Support

#+BEGIN_SRC elisp
(defun claude-org-cancel ()
  "Cancel the current session's active query."
  (interactive)
  (let* ((session-key (claude-org--current-session-key))
         (process-state (claude-org--session-get session-key :process-state)))
    (if (and process-state (claude-org--session-get session-key :busy))
        (progn
          (claude-agent-query-interrupt process-state)
          (claude-org--session-put session-key :busy nil)
          (claude-org--stop-spinner session-key)
          (let ((marker (claude-org--session-get session-key :marker)))
            (when (and marker (marker-buffer marker))
              (with-current-buffer (marker-buffer marker)
                (save-excursion
                  (goto-char marker)
                  (insert "\n[Cancelled]\n")))))
          (claude-org--refresh-header-line)
          (message "Query cancelled"))
      (message "No active query to cancel"))))

(defun claude-org-cancel-all ()
  "Cancel all active queries in this buffer."
  (interactive)
  (let ((cancelled 0))
    (maphash (lambda (key state)
               (when (plist-get state :busy)
                 (let ((process-state (plist-get state :process-state)))
                   (when process-state
                     (claude-agent-query-interrupt process-state)
                     (plist-put state :busy nil)
                     (cl-incf cancelled)))))
             claude-org--sessions)
    (claude-org--refresh-header-line)
    (message "Cancelled %d queries" cancelled)))
#+END_SRC

* Verbose Output

#+BEGIN_SRC elisp
(defun claude-org-show-verbose ()
  "Show verbose output buffer for current session."
  (interactive)
  (let ((session-key (claude-org--current-session-key)))
    (if-let ((buf (gethash session-key claude-agent--session-verbose-buffers)))
        (if (buffer-live-p buf)
            (display-buffer buf)
          (message "Verbose buffer no longer exists"))
      (message "No verbose buffer for session: %s" session-key))))
#+END_SRC

* Session Manager UI

#+BEGIN_SRC elisp
(defun claude-org-list-sessions ()
  "Display a list of all sessions in this buffer."
  (interactive)
  (let ((sessions '()))
    (maphash (lambda (key state)
               (push (list key
                           (if (plist-get state :busy) "busy" "idle")
                           (claude-org--format-elapsed (plist-get state :start-time)))
                     sessions))
             claude-org--sessions)
    (if sessions
        (with-output-to-temp-buffer "*Claude Org Sessions*"
          (princ "Claude Org Sessions\n")
          (princ "==================\n\n")
          (dolist (session (nreverse sessions))
            (princ (format "%-40s  %-6s  %s\n"
                           (claude-org--session-display-name (nth 0 session))
                           (nth 1 session)
                           (nth 2 session)))))
      (message "No sessions in this buffer"))))
#+END_SRC

* Mode Definition

** Transient Menu System

Transient provides a visual command menu with temporary keybindings.
Built into Emacs since v28, or install via =M-x package-install RET transient RET=.

*** Transient Prefix

#+BEGIN_SRC elisp
(require 'transient)

(transient-define-prefix claude-org-menu ()
  "Claude Org-mode command menu."
  ["Claude Org"
   ["Execute"
    ("c" "Execute (C-c C-c)" claude-org-execute)
    ("k" "Cancel query" claude-org-cancel)
    ("v" "Verbose output" claude-org-show-verbose)]
   ["Insert"
    ("i" "New AI block" claude-org-insert-block)
    ("s" "Story section" claude-org-insert-story)
    ("d" "SDD structure" claude-org-insert-sdd)]
   ["Navigate"
    ("j" "Jump to AI block" claude-org-jump-to-ai-block)]
   ["Session"
    ("n" "Session info" claude-org-show-session-info)
    ("l" "List sessions" claude-org-list-sessions)
    ("p" "Permission mode" claude-org-switch-permission-mode)]
   ["" ("q" "Quit" transient-quit-one)]])
#+END_SRC

*** Keymap

The keymap binds a single key to open the transient menu.
Per Emacs convention, =C-c= followed by non-letter is reserved for minor modes.

#+BEGIN_SRC elisp
(defvar claude-org-mode-map
  (let ((map (make-sparse-keymap)))
    ;; Primary: Transient menu (C-c C-/ is safe for minor modes per Emacs convention)
    (define-key map (kbd "C-c C-/") #'claude-org-menu)
    ;; Note: C-c C-c is handled by org-babel, not bound here
    ;; Direct keybindings for frequently used commands
    (define-key map (kbd "C-c C-k") #'claude-org-cancel)
    map)
  "Keymap for `claude-org-mode'.
Use \\[claude-org-menu] to open the transient command menu.")
#+END_SRC

** Minor Mode

#+BEGIN_SRC elisp
(defun claude-org--register-exclusion ()
  "Register claude-org buffers as excluded from IDE context."
  (add-to-list 'claude-agent-ide-context-exclude-predicates
               (lambda (buf)
                 (with-current-buffer buf
                   (bound-and-true-p claude-org-mode)))))

;;;###autoload
(define-minor-mode claude-org-mode
  "Minor mode for streaming Claude AI queries in org-mode.

Use #+begin_src ai blocks to query Claude. Use org-babel's C-c C-c
to execute the block and stream the response.

Key bindings:
  \\[claude-org-menu]     Open transient command menu
  \\[claude-org-cancel]   Cancel active query

\\{claude-org-mode-map}"
  :lighter " ClaudeOrg"
  :keymap claude-org-mode-map
  :group 'claude-org
  (if claude-org-mode
      (progn
        ;; Save original header line
        (setq claude-org--original-header-line header-line-format)
        ;; Save and disable line truncation (so long lines wrap)
        (setq claude-org--original-truncate-lines truncate-lines)
        (setq truncate-lines nil)
        ;; Set up header line
        (claude-org--refresh-header-line)
        ;; Register exclusion
        (claude-org--register-exclusion)
        ;; Auto-start MCP server
        (claude-org--ensure-mcp-server)
        ;; Install org file protection hook (prevents Edit/Write on .org files)
        (claude-org--install-protection)
        ;; Add company backend for slash commands (buffer-local, high priority)
        (when (boundp 'company-backends)
          (set (make-local-variable 'company-backends)
               (cons 'claude-org-company-slash-commands
                     (if (listp company-backends)
                         company-backends
                       (list company-backends))))))
    ;; Restore original header line
    (setq header-line-format claude-org--original-header-line)
    ;; Restore original truncate-lines
    (setq truncate-lines claude-org--original-truncate-lines)
    ;; Cancel any active queries
    (claude-org-cancel-all)
    ;; Remove org file protection hook
    (claude-org--remove-protection)
    ;; Stop header timer if no more claude-org buffers
    (claude-org--stop-header-timer)
    ;; Company backends will be cleaned up automatically (buffer-local)
    ))

;;;###autoload
(defun claude-org-cleanup ()
  "Clean up claude-org resources."
  (interactive)
  (claude-org-cancel-all)
  (clrhash claude-org--sessions))
#+END_SRC

* Tests

#+BEGIN_SRC elisp :load test
(require 'ert)

(ert-deftest claude-org-test-session-key-creation ()
  "Test session key creation from file path and session ID."
  (let ((buffer-file-name "/path/to/file.org"))
    ;; Without custom session ID
    (cl-letf (((symbol-function 'claude-org--get-session-id) (lambda () nil)))
      (should (equal "/path/to/file.org" (claude-org--current-session-key))))
    ;; With custom session ID
    (cl-letf (((symbol-function 'claude-org--get-session-id) (lambda () "my-session")))
      (should (equal "/path/to/file.org::my-session" (claude-org--current-session-key))))))

(ert-deftest claude-org-test-session-display-name ()
  "Test session display name extraction."
  (should (equal "my-session"
                 (claude-org--session-display-name "/path/to/file.org::my-session")))
  (should (equal "file.org"
                 (claude-org--session-display-name "/path/to/file.org"))))

(ert-deftest claude-org-test-session-state-accessors ()
  "Test session state put/get operations."
  (let ((claude-org--sessions (make-hash-table :test 'equal)))
    (claude-org--session-put "test-key" :foo "bar")
    (should (equal "bar" (claude-org--session-get "test-key" :foo)))
    (claude-org--session-put "test-key" :busy t)
    (should (equal t (claude-org--session-get "test-key" :busy)))))

(ert-deftest claude-org-test-active-session-count ()
  "Test active session counting."
  (let ((claude-org--sessions (make-hash-table :test 'equal)))
    (should (= 0 (claude-org--active-session-count)))
    (claude-org--session-put "session-1" :busy t)
    (should (= 1 (claude-org--active-session-count)))
    (claude-org--session-put "session-2" :busy t)
    (should (= 2 (claude-org--active-session-count)))
    (claude-org--session-put "session-1" :busy nil)
    (should (= 1 (claude-org--active-session-count)))))

(ert-deftest claude-org-test-format-elapsed ()
  "Test elapsed time formatting."
  (should (equal "unknown" (claude-org--format-elapsed nil)))
  (should (string-match-p "started [0-9]+ seconds ago"
                          (claude-org--format-elapsed (- (float-time) 30))))
  (should (string-match-p "started [0-9]+ minutes ago"
                          (claude-org--format-elapsed (- (float-time) 120)))))

(ert-deftest claude-org-test-normalize-headers-in-text ()
  "Test org header normalization with regex replacement."
  (let ((claude-org-normalize-headers t))
    ;; Simple case: single header
    (should (equal "**** Top\n" (claude-org--normalize-headers-in-text "* Top\n" 4)))
    ;; Multiple headers
    (should (equal "**** Top\n***** Sub\n"
                   (claude-org--normalize-headers-in-text "* Top\n** Sub\n" 4)))
    ;; Mixed content
    (should (equal "Hello\n**** Head\nText\n"
                   (claude-org--normalize-headers-in-text "Hello\n* Head\nText\n" 4)))
    ;; Non-headers unchanged
    (should (equal "  * not at start\n"
                   (claude-org--normalize-headers-in-text "  * not at start\n" 4)))
    (should (equal "*no space after\n"
                   (claude-org--normalize-headers-in-text "*no space after\n" 4)))
    ;; Empty string
    (should (equal "" (claude-org--normalize-headers-in-text "" 4)))
    ;; No newline - still works
    (should (equal "**** Header" (claude-org--normalize-headers-in-text "* Header" 4)))
    ;; DOS line endings (\r\n) become \n
    (should (equal "**** Header\nText\n"
                   (claude-org--normalize-headers-in-text "* Header\r\nText\r\n" 4)))
    (should (equal "Line1\nLine2\n"
                   (claude-org--normalize-headers-in-text "Line1\r\nLine2\r\n" 4)))
    ;; Old Mac line endings (\r) become \n
    (should (equal "Line1\nLine2\n"
                   (claude-org--normalize-headers-in-text "Line1\rLine2\r" 4)))))

(ert-deftest claude-org-test-normalize-headers-disabled ()
  "Test that normalization can be disabled but line endings still normalized."
  (let ((claude-org-normalize-headers nil))
    ;; Headers not normalized
    (should (equal "* Top\n" (claude-org--normalize-headers-in-text "* Top\n" 4)))
    ;; But line endings are still normalized
    (should (equal "* Top\n" (claude-org--normalize-headers-in-text "* Top\r\n" 4)))
    (should (equal "* Top\n" (claude-org--normalize-headers-in-text "* Top\r" 4)))))

(ert-deftest claude-org-test-normalize-headers-streaming ()
  "Test header normalization with streaming tokens."
  (let ((claude-org-normalize-headers t)
        (output ""))
    ;; Simulate streaming - each token is processed independently
    (dolist (token '("Here is " "the ans" "wer:\n" "* Sum" "mary\n" "Text\n"))
      (setq output (concat output (claude-org--normalize-headers-in-text token 4))))
    (should (equal "Here is the answer:\n**** Summary\nText\n" output))))

(ert-deftest claude-org-test-auto-break-lines-disabled ()
  "Test that auto-break is disabled when threshold is -1."
  (let ((claude-org-auto-break-line-length -1))
    ;; Long line should not be broken
    (let* ((text "This is a very long line that exceeds any reasonable threshold. It should not be broken.")
           (result (claude-org--auto-break-lines text 0)))
      (should (equal text (car result)))
      (should (= (length text) (cdr result))))))

(ert-deftest claude-org-test-auto-break-lines-enabled ()
  "Test auto-break when threshold is positive."
  (let ((claude-org-auto-break-line-length 50))
    ;; Line exceeding threshold with sentence-ending punctuation
    (let* ((text "This is a long sentence that goes over fifty chars. Next sentence here.")
           (result (claude-org--auto-break-lines text 0)))
      ;; Should break after the period+space when line > 50
      (should (string-match-p "\n" (car result))))))

(ert-deftest claude-org-test-auto-break-lines-streaming ()
  "Test auto-break with streaming tokens across multiple calls."
  (let ((claude-org-auto-break-line-length 30)
        (line-len 0)
        (output ""))
    ;; Simulate streaming - track line length across tokens
    (dolist (token '("Hello world. " "This is " "a test. " "More text here. " "End."))
      (let ((result (claude-org--auto-break-lines token line-len)))
        (setq output (concat output (car result)))
        (setq line-len (cdr result))))
    ;; Should have inserted breaks after sentences when line > 30
    (should (> (length (split-string output "\n")) 1))))

(ert-deftest claude-org-test-auto-break-lines-newline-reset ()
  "Test that newlines in text reset the line length counter."
  (let ((claude-org-auto-break-line-length 50))
    ;; Text with embedded newline
    (let* ((result (claude-org--auto-break-lines "First line\nSecond line" 40)))
      ;; Line length should be length of "Second line" (11), not 40+22
      (should (= 11 (cdr result))))))

;; Block History Tests

(ert-deftest claude-org-test-history-file-path ()
  "Test history file path generation with readable naming."
  (let ((buffer-file-name "/Users/test/notes/dev.org")
        (claude-org-history-directory "/tmp/claude-org-test"))
    (let ((path (claude-org--history-file-path)))
      ;; Should contain basename
      (should (string-match-p "dev--" path))
      ;; Should end with .el
      (should (string-suffix-p ".el" path))
      ;; Should be in history directory
      (should (string-prefix-p "/tmp/claude-org-test/" path)))))

(ert-deftest claude-org-test-format-time-ago ()
  "Test relative time formatting."
  (let ((now (float-time)))
    ;; Just now
    (should (equal "just now" (claude-org--format-time-ago now)))
    ;; Minutes ago
    (should (equal "5m ago" (claude-org--format-time-ago (- now 300))))
    ;; Hours ago
    (should (equal "2h ago" (claude-org--format-time-ago (- now 7200))))
    ;; Days ago
    (should (equal "3d ago" (claude-org--format-time-ago (- now 259200))))))

(ert-deftest claude-org-test-format-block-candidate ()
  "Test block candidate formatting for completing-read."
  ;; Completed block
  (let ((entry '("block-1" :timestamp 1735312800.0
                           :status completed
                           :title "Test query")))
    (let ((formatted (claude-org--format-block-candidate entry)))
      (should (string-prefix-p "[✓]" formatted))
      (should (string-match-p "Test query" formatted))))
  ;; In-progress block
  (let ((entry '("block-2" :timestamp 1735312800.0
                           :status in-progress
                           :title "Running query")))
    (let ((formatted (claude-org--format-block-candidate entry)))
      (should (string-prefix-p "[⋯]" formatted))))
  ;; Error block
  (let ((entry '("block-3" :timestamp 1735312800.0
                           :status error
                           :title "Failed query")))
    (let ((formatted (claude-org--format-block-candidate entry)))
      (should (string-prefix-p "[✗]" formatted)))))

(ert-deftest claude-org-test-hooks-defined ()
  "Test that execution hooks are properly defined."
  (should (boundp 'claude-org-execute-hook))
  (should (boundp 'claude-org-execute-after-hook))
  (should (boundp 'claude-org-complete-hook)))

(ert-deftest claude-org-test-default-hooks-registered ()
  "Test that default hook functions are registered."
  (should (member 'claude-org--record-block-execution
                  claude-org-execute-after-hook))
  (should (member 'claude-org--update-block-status
                  claude-org-complete-hook)))

(ert-deftest claude-org-test-prepare-history-for-save ()
  "Test history preparation removes transient data."
  (let ((claude-org--block-history
         '(("block-1" :timestamp 1000.0 :status completed
                      :title "Test" :line 10 :marker nil)
           ("block-2" :timestamp 2000.0 :status in-progress
                      :title "Test2" :line 20 :marker nil)))
        (claude-org-history-max-entries 10))
    (let ((prepared (claude-org--prepare-history-for-save)))
      ;; Should be sorted by timestamp (most recent first)
      (should (equal "block-2" (car (car prepared))))
      ;; Should have required fields
      (let ((entry (cdr (car prepared))))
        (should (plist-get entry :timestamp))
        (should (plist-get entry :status))
        (should (plist-get entry :title))
        (should (plist-get entry :line))))))

(ert-deftest claude-org-test-collect-recent-blocks ()
  "Test recent blocks collection for completing-read."
  (let ((claude-org--block-history
         '(("block-1" :timestamp 1000.0 :status completed :title "First")))
        (claude-org--history-loaded t))
    (let ((candidates (claude-org--collect-recent-blocks)))
      (should (= 1 (length candidates)))
      (should (stringp (car (car candidates)))))))
#+END_SRC

* Org File Protection Hook

*NOTE: This hook does NOT work as intended.* It is kept for documentation purposes
and potential future use if Claude Code CLI changes its architecture.

** How Permission Functions Work

When Claude Code CLI is in =acceptEdits= mode, it sends =can_use_tool= control
requests to Emacs before executing Edit/Write tools. The
=claude-agent-permission-functions= hook processes these requests:

| Permission Mode | Edit/Write Flow | Protection? |
|-----------------+-----------------+-------------|
| bypassPermissions | CLI auto-approves | ❌ No prompts |
| acceptEdits | CLI → can_use_tool → Emacs | ✅ Permission functions run |
| default | CLI prompts user | ⚠️ CLI UI (not Emacs) |

To protect org files, add =claude-org-permission-protect-org= to
=claude-agent-permission-functions=. This only works in =acceptEdits= mode.

** Org File Protection (Permission Function)

This permission function denies Edit/Write on .org files, suggesting MCP tools.
Add it to =claude-agent-permission-functions= to enable protection.

#+NAME: org-protect-permission
#+BEGIN_SRC elisp
(defun claude-org-permission-protect-org (tool-name tool-input _context)
  "Permission function to protect .org files from Edit/Write.

TOOL-NAME: string like \"Edit\", \"Write\"
TOOL-INPUT: plist with :file_path and other parameters
CONTEXT: plist with :session-id, :org-section

Returns nil to pass through, or permission result to deny.
Should be added to `claude-agent-permission-functions'."
  (let ((file-path (plist-get tool-input :file_path)))
    (when (and (member tool-name '("Edit" "Write"))
               file-path
               (string-match-p "\\.org$" file-path))
      (list :behavior "deny"
            :message
            (concat "🚫 Cannot use " tool-name " on .org files.\n\n"
                    "Use Emacs MCP tools instead:\n"
                    "- mcp__emacs__org_read_section - Read section by path\n"
                    "- mcp__emacs__org_update_section - Update section content\n"
                    "- mcp__emacs__org_create_section - Create new subsection\n"
                    "- mcp__emacs__org_delete_section - Delete section\n"
                    "- mcp__emacs__org_set_property - Set property value\n"
                    "- mcp__emacs__org_set_tags - Set section tags\n\n"
                    "These tools preserve org structure and work with Emacs directly.")))))
#+END_SRC

** Protection Installation

Install/remove org protection in the permission hook.

#+NAME: org-protect-install
#+BEGIN_SRC elisp
(defun claude-org--install-protection ()
  "Install org file protection in permission functions.
The protection must be global because it runs in process filter context."
  (add-hook 'claude-agent-permission-functions
            #'claude-org-permission-protect-org))

(defun claude-org--remove-protection ()
  "Remove org file protection if no claude-org buffers remain."
  (unless (cl-some (lambda (buf)
                     (and (not (eq buf (current-buffer)))
                          (buffer-live-p buf)
                          (with-current-buffer buf
                            claude-org-mode)))
                   (buffer-list))
    (setq claude-agent-permission-functions
          (delq #'claude-org-permission-protect-org
                claude-agent-permission-functions))))
#+END_SRC

* Package Footer

#+BEGIN_SRC elisp
(provide 'claude-org)
;;; claude-org.el ends here
#+END_SRC
