# -*- encoding:utf-8 Mode: POLY-ORG; org-src-preserve-indentation: t; -*-
#+TITLE: Claude Agent SDK for Emacs
#+SUBTITLE: Emacs client for Claude Code CLI
#+AUTHOR: Jingtao Xu
#+OPTIONS: toc:2
#+Startup: noindent
#+PROPERTY: header-args :results silent
#+PROPERTY: literate-lang elisp
#+PROPERTY: literate-load yes

* Table of Contents                                            :TOC:noexport:
- [[#introduction][Introduction]]
- [[#dependencies-and-requirements][Dependencies and Requirements]]
  - [[#package-header][Package Header]]
  - [[#required-libraries][Required Libraries]]
- [[#customization-variables][Customization Variables]]
- [[#error-handling][Error Handling]]
- [[#data-structures][Data Structures]]
  - [[#options][Options]]
  - [[#content-block-types][Content Block Types]]
  - [[#message-types][Message Types]]
  - [[#hook-types][Hook Types]]
- [[#process-management][Process Management]]
  - [[#cli-discovery][CLI Discovery]]
  - [[#argument-builder][Argument Builder]]
  - [[#process-state][Process State]]
  - [[#process-filter][Process Filter]]
  - [[#process-sentinel][Process Sentinel]]
  - [[#process-creation][Process Creation]]
- [[#json-protocol][JSON Protocol]]
  - [[#content-block-parsing][Content Block Parsing]]
  - [[#message-parsing][Message Parsing]]
- [[#core-api][Core API]]
  - [[#query-function][Query Function]]
  - [[#helper-functions][Helper Functions]]
- [[#client-api][Client API]]
  - [[#client-structure][Client Structure]]
  - [[#client-creation][Client Creation]]
  - [[#client-methods][Client Methods]]
- [[#hook-system][Hook System]]
  - [[#hook-input-structures][Hook Input Structures]]
  - [[#hook-invocation][Hook Invocation]]
- [[#session-management][Session Management]]
- [[#query-cancellation][Query Cancellation]]
- [[#activity-mode-line][Activity Mode-Line]]
- [[#usage-mode-line][Usage Mode-Line]]
- [[#interactive-chat-mode][Interactive Chat Mode]]
- [[#tests][Tests]]
  - [[#unit-tests][Unit Tests]]
- [[#package-footer][Package Footer]]
- [[#release][Release]]

* Introduction

This is an Emacs client library for the [[https://claude.ai/code][Claude Code CLI]]. It provides a
literate programming implementation of the Claude Agent SDK, allowing
Emacs users to interact with Claude programmatically.

The library mirrors the Python Claude Agent SDK API, providing:
- ~claude-agent-query~ for one-shot queries
- ~claude-agent-client~ for bidirectional interactive conversations
- Streaming response support via callbacks
- Basic hook support (PreToolUse, PostToolUse, Stop)
- Session management (continue, resume)
- Activity mode-line indicator with spinning animation
- Usage mode-line showing API utilization percentages

** Usage Example

#+BEGIN_SRC elisp :load no
;; One-shot query
(claude-agent-query
 "What is 2+2?"
 :on-message (lambda (msg)
               (when (claude-agent-assistant-message-p msg)
                 (message "Response: %s"
                          (claude-agent-extract-text msg))))
 :on-complete (lambda (_) (message "Done!")))

;; Interactive client
(let ((client (claude-agent-client-create
               :options (claude-agent-options
                         :model "claude-sonnet-4-5"
                         :permission-mode 'accept-edits))))
  (claude-agent-client-connect client)
  (claude-agent-client-send
   client "Hello, Claude!"
   :on-response (lambda (msg) (message "Got: %s" msg))))
#+END_SRC

* Dependencies and Requirements

** Package Header

#+BEGIN_SRC elisp
;;; claude-agent.el --- Emacs client for Claude Code CLI -*- lexical-binding: t; -*-

;; Copyright (C) 2024 Jingtao Xu

;; Author: Jingtao Xu
;; Version: 0.1.0
;; Package-Requires: ((emacs "27.1"))
;; Keywords: tools, processes, ai
;; URL: https://github.com/user/claude-agent

;; This file is not part of GNU Emacs.

;;; Commentary:

;; Claude Agent SDK for Emacs - A client library for the Claude Code CLI.
;; This package provides async subprocess communication with Claude,
;; streaming responses, and hook support.

;;; Code:
#+END_SRC

** Required Libraries

#+BEGIN_SRC elisp
(require 'cl-lib)
(require 'json)
(require 'subr-x)
#+END_SRC

* Customization Variables

#+BEGIN_SRC elisp
(defgroup claude-agent nil
  "Claude Agent SDK for Emacs."
  :group 'tools
  :prefix "claude-agent-")

(defcustom claude-agent-cli-path nil
  "Path to the Claude Code CLI binary.
If nil, the CLI will be searched in PATH and common locations."
  :type '(choice (const nil :tag "Auto-detect")
                 (file :tag "Explicit path"))
  :group 'claude-agent)

(defcustom claude-agent-cli-search-paths
  '("~/.npm-global/bin/claude"
    "/usr/local/bin/claude"
    "~/.local/bin/claude"
    "~/node_modules/.bin/claude"
    "~/.yarn/bin/claude"
    "~/.claude/local/claude")
  "List of paths to search for the Claude Code CLI."
  :type '(repeat string)
  :group 'claude-agent)

(defcustom claude-agent-default-model nil
  "Default model to use for queries.
If nil, uses the CLI default."
  :type '(choice (const nil :tag "CLI default")
                 (string :tag "Model name"))
  :group 'claude-agent)

(defcustom claude-agent-debug nil
  "When non-nil, enable debug logging."
  :type 'boolean
  :group 'claude-agent)
#+END_SRC

* Error Handling

Define error conditions for the SDK.

#+BEGIN_SRC elisp
(define-error 'claude-agent-error
  "Claude Agent SDK error")

(define-error 'claude-agent-cli-not-found-error
  "Claude Code CLI not found"
  'claude-agent-error)

(define-error 'claude-agent-cli-connection-error
  "Cannot connect to Claude CLI"
  'claude-agent-error)

(define-error 'claude-agent-process-error
  "Claude CLI process error"
  'claude-agent-error)

(define-error 'claude-agent-json-decode-error
  "JSON decode error"
  'claude-agent-error)

(define-error 'claude-agent-message-parse-error
  "Message parse error"
  'claude-agent-error)
#+END_SRC

* Data Structures

** Options

The options plist mirrors the Python ~ClaudeAgentOptions~ dataclass.

#+BEGIN_SRC elisp
(defun claude-agent-options (&rest args)
  "Create a Claude Agent options plist.

Supported keyword arguments:
  :system-prompt      - System prompt string
  :allowed-tools      - List of allowed tool names
  :disallowed-tools   - List of disallowed tool names
  :max-turns          - Maximum conversation turns (integer)
  :max-budget-usd     - Maximum budget in USD (number)
  :model              - Model name string
  :permission-mode    - One of: default, accept-edits, plan, bypass-permissions
  :continue-conversation - Boolean to continue previous conversation
  :resume             - Session ID string to resume
  :cwd                - Working directory for CLI
  :cli-path           - Path to Claude CLI binary
  :hooks              - Alist of (event . matchers)
  :env                - Alist of environment variables
  :setting-sources    - List of setting sources (\"user\" \"project\" \"local\")

Returns a plist suitable for passing to `claude-agent-query' or
`claude-agent-client-create'."
  ;; Use `list' instead of quoted literal to avoid destructive modification
  (let ((defaults (list :system-prompt nil
                        :allowed-tools nil
                        :disallowed-tools nil
                        :max-turns nil
                        :max-budget-usd nil
                        :model nil
                        :permission-mode nil
                        :continue-conversation nil
                        :resume nil
                        :cwd nil
                        :cli-path nil
                        :hooks nil
                        :env nil
                        :setting-sources nil)))
    (cl-loop for (key val) on args by #'cddr
             do (setq defaults (plist-put defaults key val)))
    defaults))

(defun claude-agent-options-get (options key &optional default)
  "Get KEY from OPTIONS plist, returning DEFAULT if not found."
  (let ((val (plist-get options key)))
    (if val val default)))
#+END_SRC

** Content Block Types

Content blocks represent different types of content in messages.

#+BEGIN_SRC elisp
(cl-defstruct (claude-agent-text-block
               (:constructor claude-agent-make-text-block)
               (:copier nil))
  "Text content block."
  text)

(cl-defstruct (claude-agent-thinking-block
               (:constructor claude-agent-make-thinking-block)
               (:copier nil))
  "Thinking content block (extended thinking)."
  thinking
  signature)

(cl-defstruct (claude-agent-tool-use-block
               (:constructor claude-agent-make-tool-use-block)
               (:copier nil))
  "Tool use content block."
  id
  name
  input)

(cl-defstruct (claude-agent-tool-result-block
               (:constructor claude-agent-make-tool-result-block)
               (:copier nil))
  "Tool result content block."
  tool-use-id
  content
  is-error)
#+END_SRC

** Message Types

Message types mirror the Python SDK discriminated union.

#+BEGIN_SRC elisp
(cl-defstruct (claude-agent-user-message
               (:constructor claude-agent-make-user-message)
               (:copier nil))
  "User message."
  content
  parent-tool-use-id)

(cl-defstruct (claude-agent-assistant-message
               (:constructor claude-agent-make-assistant-message)
               (:copier nil))
  "Assistant message with content blocks."
  content      ; List of content blocks
  model
  parent-tool-use-id
  error)       ; Error info if present

(cl-defstruct (claude-agent-system-message
               (:constructor claude-agent-make-system-message)
               (:copier nil))
  "System message with metadata."
  subtype
  data)

(cl-defstruct (claude-agent-result-message
               (:constructor claude-agent-make-result-message)
               (:copier nil))
  "Result message with cost and usage information."
  subtype
  duration-ms
  duration-api-ms
  is-error
  num-turns
  session-id
  total-cost-usd
  usage
  result)
#+END_SRC

** Hook Types

#+BEGIN_SRC elisp
(cl-defstruct (claude-agent-hook-matcher
               (:constructor claude-agent-make-hook-matcher)
               (:copier nil))
  "Hook matcher configuration."
  matcher      ; String pattern (tool name) or nil for all
  callbacks    ; List of callback functions
  (timeout 60.0)) ; Timeout in seconds

(defconst claude-agent-hook-events
  '(PreToolUse PostToolUse UserPromptSubmit Stop SubagentStop)
  "List of supported hook event types.")
#+END_SRC

* Process Management

** CLI Discovery

#+BEGIN_SRC elisp
(defun claude-agent--find-cli ()
  "Find the Claude Code CLI binary.
Returns the path to the CLI or signals an error if not found."
  (or claude-agent-cli-path
      (executable-find "claude")
      (cl-find-if #'file-executable-p
                  (mapcar #'expand-file-name
                          claude-agent-cli-search-paths))
      (signal 'claude-agent-cli-not-found-error
              (list "Claude Code CLI not found. Install with: npm install -g @anthropic-ai/claude-code"))))

(defun claude-agent--cli-version ()
  "Get the Claude Code CLI version.
Returns version string or nil if unable to determine."
  (condition-case nil
      (let ((output (shell-command-to-string
                     (format "%s -v" (claude-agent--find-cli)))))
        (when (string-match "\\([0-9]+\\.[0-9]+\\.[0-9]+\\)" output)
          (match-string 1 output)))
    (error nil)))
#+END_SRC

** Argument Builder

Build CLI arguments from options plist.

#+BEGIN_SRC elisp
(defun claude-agent--permission-mode-to-string (mode)
  "Convert permission MODE symbol to CLI string."
  (pcase mode
    ('default "default")
    ('accept-edits "acceptEdits")
    ('plan "plan")
    ('bypass-permissions "bypassPermissions")
    ((pred stringp) mode)
    (_ nil)))

(defun claude-agent--build-args (options &optional streaming-p)
  "Build CLI arguments from OPTIONS plist.
If STREAMING-P is non-nil, use streaming input mode."
  (let ((args (list "--output-format" "stream-json" "--verbose")))
    ;; System prompt
    (let ((system-prompt (plist-get options :system-prompt)))
      (when system-prompt
        (setq args (append args (list "--system-prompt" system-prompt)))))
    ;; Model
    (let ((model (or (plist-get options :model) claude-agent-default-model)))
      (when model
        (setq args (append args (list "--model" model)))))
    ;; Max turns
    (let ((max-turns (plist-get options :max-turns)))
      (when max-turns
        (setq args (append args (list "--max-turns" (number-to-string max-turns))))))
    ;; Max budget
    (let ((max-budget (plist-get options :max-budget-usd)))
      (when max-budget
        (setq args (append args (list "--max-budget-usd" (number-to-string max-budget))))))
    ;; Permission mode
    (let ((perm-mode (plist-get options :permission-mode)))
      (when perm-mode
        (let ((mode-str (claude-agent--permission-mode-to-string perm-mode)))
          (when mode-str
            (setq args (append args (list "--permission-mode" mode-str)))))))
    ;; Allowed tools
    (let ((allowed-tools (plist-get options :allowed-tools)))
      (when allowed-tools
        (setq args (append args (list "--allowedTools"
                                      (string-join allowed-tools ","))))))
    ;; Disallowed tools
    (let ((disallowed-tools (plist-get options :disallowed-tools)))
      (when disallowed-tools
        (setq args (append args (list "--disallowedTools"
                                      (string-join disallowed-tools ","))))))
    ;; MCP config
    (let ((mcp-config (plist-get options :mcp-config)))
      (when mcp-config
        (setq args (append args (list "--mcp-config" mcp-config)))))
    ;; Continue conversation
    (when (plist-get options :continue-conversation)
      (setq args (append args (list "--continue"))))
    ;; Resume session
    (let ((resume (plist-get options :resume)))
      (when resume
        (setq args (append args (list "--resume" resume)))))
    ;; Setting sources (for loading skills from ~/.claude/skills/)
    (let ((setting-sources (plist-get options :setting-sources)))
      (when setting-sources
        (setq args (append args (list "--setting-sources"
                                      (string-join setting-sources ","))))))
    ;; Streaming input mode
    (if streaming-p
        (setq args (append args (list "--input-format" "stream-json")))
      ;; Non-streaming: --print flag will be added with prompt
      (setq args (append args (list "--print"))))
    args))
#+END_SRC

** Process State

Internal state structure for managing async process communication.

#+BEGIN_SRC elisp
(cl-defstruct (claude-agent--process-state
               (:constructor claude-agent--make-process-state)
               (:copier nil))
  "Internal process state for async operations."
  process           ; Emacs process object
  buffer            ; Output buffer
  json-buffer       ; Accumulated partial JSON string
  callback          ; Message callback function
  token-callback    ; Token callback for streaming text
  error-callback    ; Error callback function
  complete-callback ; Completion callback function
  options           ; Original options plist
  request-id        ; Unique request ID for cancellation
  start-time        ; Query start time (float-time)
  session-key       ; Session key for verbose buffer grouping
  (ready nil)       ; Boolean ready state
  (closed nil))     ; Boolean closed state

(defvar claude-agent--active-states nil
  "List of active process states for cleanup.")
#+END_SRC

** Process Filter

The process filter accumulates JSON data and parses complete messages.

#+BEGIN_SRC elisp
(defun claude-agent--debug-log (format-string &rest args)
  "Log debug message if `claude-agent-debug' is non-nil."
  (when claude-agent-debug
    (apply #'message (concat "[claude-agent] " format-string) args)))

(defun claude-agent--extract-tokens (json callback)
  "Extract text tokens from JSON and call CALLBACK with each.
Handles assistant messages by extracting text from content blocks."
  (let ((type (plist-get json :type)))
    (when (string= type "assistant")
      (let* ((message (plist-get json :message))
             (content (plist-get message :content)))
        (when content
          (dolist (block content)
            (when (string= (plist-get block :type) "text")
              (let ((text (plist-get block :text)))
                (when (and text (not (string-empty-p text)))
                  (funcall callback text))))))))))

(defun claude-agent--process-json-buffer (process)
  "Process accumulated JSON for PROCESS.
PROCESS has state stored via `process-get'.
Parses complete newline-delimited JSON and invokes callbacks."
  (let* ((state (process-get process 'claude-agent-state))
         (buf (claude-agent--process-state-json-buffer state))
         (callback (claude-agent--process-state-callback state))
         (token-callback (claude-agent--process-state-token-callback state))
         (error-callback (claude-agent--process-state-error-callback state)))
    (while (string-match "^\\([^\n]+\\)\n" buf)
      (let* ((line (match-string 1 buf))
             (rest (substring buf (match-end 0))))
        (setf (claude-agent--process-state-json-buffer state) rest)
        (setq buf rest)
        (when (and line (not (string-empty-p (string-trim line))))
          (condition-case err
              (let* ((json-object-type 'plist)
                     (json-array-type 'list)
                     (json-key-type 'keyword)
                     (parsed (json-read-from-string line)))
                (claude-agent--debug-log "Parsed JSON: %S" (plist-get parsed :type))
                ;; Extract text for token callback (streaming)
                (when token-callback
                  (claude-agent--extract-tokens parsed token-callback))
                ;; Call message callback with parsed message
                (let ((message (claude-agent--parse-message parsed)))
                  (when message
                    ;; Write to verbose buffer if session-key is set
                    (claude-agent--verbose-write-message
                     (claude-agent--process-state-session-key state) message)
                    ;; Call user callback
                    (when callback
                      (funcall callback message)))))
            ((json-parse-error json-readtable-error json-end-of-file)
             ;; Line is not valid JSON - could be plain text error from CLI
             (claude-agent--debug-log "Non-JSON output: %s" line)
             (when error-callback
               ;; Pass the plain text as error message for session recovery handling
               (funcall error-callback
                        (list 'claude-agent-cli-error
                              :message line
                              :original-error err))))))))))

(defun claude-agent--process-filter (process output)
  "Process filter function for PROCESS.
OUTPUT is the data received from the process.
Uses `process-get' to retrieve state instead of closures (for dynamic binding compat)."
  (let ((state (process-get process 'claude-agent-state)))
    (when (and state (claude-agent--process-state-ready state))
      (let ((json-buf (or (claude-agent--process-state-json-buffer state) "")))
        (setf (claude-agent--process-state-json-buffer state)
              (concat json-buf output))
        (claude-agent--process-json-buffer process)))))
#+END_SRC

** Process Sentinel

The sentinel handles process completion and cleanup.

#+BEGIN_SRC elisp
(defun claude-agent--process-sentinel (process event)
  "Process sentinel function for PROCESS.
EVENT is the process event string.
Uses `process-get' to retrieve state instead of closures (for dynamic binding compat)."
  (let ((state (process-get process 'claude-agent-state)))
    (claude-agent--debug-log "Process event: %s" (string-trim event))
    (when state
      (setf (claude-agent--process-state-closed state) t)
      (setf (claude-agent--process-state-ready state) nil)
      ;; Process any remaining JSON in buffer
      (claude-agent--process-json-buffer process)
      ;; Call completion callback
      (let ((complete-cb (claude-agent--process-state-complete-callback state)))
        (cond
         ((string-match-p "finished" event)
          (when complete-cb
            (funcall complete-cb nil)))
         ((string-match-p "exited abnormally" event)
          (let ((exit-code (when (string-match "code \\([0-9]+\\)" event)
                             (string-to-number (match-string 1 event)))))
            (when complete-cb
              (funcall complete-cb
                       (list 'claude-agent-process-error
                             :message "Process exited abnormally"
                             :exit-code exit-code)))))
         (t
          (when complete-cb
            (funcall complete-cb
                     (list 'claude-agent-process-error
                           :message (format "Process event: %s" event)))))))
      ;; Cleanup
      (setq claude-agent--active-states
            (delq state claude-agent--active-states))
      ;; Unregister from active queries
      (when-let ((req-id (claude-agent--process-state-request-id state)))
        (claude-agent--unregister-query req-id))
      (when-let ((buf (claude-agent--process-state-buffer state)))
        (when (buffer-live-p buf)
          (kill-buffer buf))))))
#+END_SRC

** Process Creation

#+BEGIN_SRC elisp
(defun claude-agent--start-process (prompt options callback error-callback complete-callback
                                          &optional token-callback request-id session-key)
  "Start Claude CLI process with PROMPT and OPTIONS.

CALLBACK is called with each parsed message.
ERROR-CALLBACK is called on errors.
COMPLETE-CALLBACK is called when process completes.
TOKEN-CALLBACK is called with each text token for streaming (optional).
REQUEST-ID is a unique identifier for this request (optional).
SESSION-KEY identifies the session for verbose output grouping (optional).

Returns a process state object."
  (let* ((cli-path (or (plist-get options :cli-path)
                       (claude-agent--find-cli)))
         (args (claude-agent--build-args options nil))
         (cwd (plist-get options :cwd))
         (env-vars (plist-get options :env))
         (req-id (or request-id (claude-agent--generate-request-id)))
         (state (claude-agent--make-process-state
                 :options options
                 :json-buffer ""
                 :callback callback
                 :token-callback token-callback
                 :error-callback error-callback
                 :complete-callback complete-callback
                 :request-id req-id
                 :start-time (float-time)
                 :session-key session-key
                 :ready nil
                 :closed nil))
         ;; Note: We use :connection-type 'pipe in make-process below
         (default-directory (or cwd default-directory))
         (process-environment (append
                               (mapcar (lambda (pair)
                                         (format "%s=%s" (car pair) (cdr pair)))
                                       env-vars)
                               process-environment)))
    ;; Add prompt to args
    (setq args (append args (list "--" prompt)))
    (claude-agent--debug-log "Starting CLI: %s %s" cli-path args)
    (let ((process (make-process
                    :name "claude-agent"
                    :command (cons cli-path args)
                    :buffer (generate-new-buffer " *claude-agent*")
                    :connection-type 'pipe  ;; Use pipe, not PTY
                    :filter #'claude-agent--process-filter
                    :sentinel #'claude-agent--process-sentinel
                    :coding 'utf-8-unix
                    :noquery t)))
      ;; Store state on process for filter/sentinel to access
      ;; (avoids closure issues with dynamic binding)
      (process-put process 'claude-agent-state state)
      (setf (claude-agent--process-state-process state) process)
      (setf (claude-agent--process-state-buffer state) (process-buffer process))
      (setf (claude-agent--process-state-ready state) t)
      ;; Register query for cancellation tracking
      (claude-agent--register-query req-id state)
      ;; Initialize verbose buffer for session if session-key provided
      (when session-key
        (claude-agent--get-session-verbose-buffer session-key)
        (claude-agent--verbose-insert-query-header session-key prompt cli-path args default-directory))
      ;; KEY: Close stdin immediately for non-interactive --print mode
      ;; This signals EOF to the CLI, allowing it to proceed
      (process-send-eof process)
      (push state claude-agent--active-states)
      state)))
#+END_SRC

* JSON Protocol

** Content Block Parsing

#+BEGIN_SRC elisp
(defun claude-agent--parse-content-block (block)
  "Parse a content BLOCK plist into appropriate struct."
  (let ((type (plist-get block :type)))
    (pcase type
      ("text"
       (claude-agent-make-text-block
        :text (plist-get block :text)))
      ("thinking"
       (claude-agent-make-thinking-block
        :thinking (plist-get block :thinking)
        :signature (plist-get block :signature)))
      ("tool_use"
       (claude-agent-make-tool-use-block
        :id (plist-get block :id)
        :name (plist-get block :name)
        :input (plist-get block :input)))
      ("tool_result"
       (claude-agent-make-tool-result-block
        :tool-use-id (plist-get block :tool_use_id)
        :content (plist-get block :content)
        :is-error (plist-get block :is_error)))
      (_ block)))) ; Return raw block for unknown types
#+END_SRC

** Message Parsing

#+BEGIN_SRC elisp
(defun claude-agent--parse-content-blocks (blocks)
  "Parse a list of content BLOCKS."
  (when blocks
    (mapcar #'claude-agent--parse-content-block blocks)))

(defun claude-agent--parse-message (json)
  "Parse a JSON plist into appropriate message struct."
  (let ((type (plist-get json :type)))
    (pcase type
      ("user"
       (let ((message (plist-get json :message)))
         (claude-agent-make-user-message
          :content (plist-get message :content)
          :parent-tool-use-id (plist-get message :parent_tool_use_id))))
      ("assistant"
       (let ((message (plist-get json :message)))
         (claude-agent-make-assistant-message
          :content (claude-agent--parse-content-blocks
                    (plist-get message :content))
          :model (plist-get message :model)
          :parent-tool-use-id (plist-get message :parent_tool_use_id)
          :error (plist-get message :error))))
      ("system"
       (claude-agent-make-system-message
        :subtype (plist-get json :subtype)
        :data json))
      ("result"
       (claude-agent-make-result-message
        :subtype (plist-get json :subtype)
        :duration-ms (plist-get json :duration_ms)
        :duration-api-ms (plist-get json :duration_api_ms)
        :is-error (plist-get json :is_error)
        :num-turns (plist-get json :num_turns)
        :session-id (plist-get json :session_id)
        :total-cost-usd (plist-get json :total_cost_usd)
        :usage (plist-get json :usage)
        :result (plist-get json :result)))
      ;; Handle other message types as raw plists
      (_ json))))
#+END_SRC

* Core API

** Query Function

#+BEGIN_SRC elisp
(cl-defun claude-agent-query (prompt &key options on-message on-token on-error on-complete session-key)
  "Send a one-shot query to Claude.

PROMPT is the query string to send.

OPTIONS is an optional plist created with `claude-agent-options'.

ON-MESSAGE is called with each message as it arrives.
  Function signature: (lambda (message) ...)
  where MESSAGE is one of:
    - `claude-agent-user-message'
    - `claude-agent-assistant-message'
    - `claude-agent-system-message'
    - `claude-agent-result-message'

ON-TOKEN is called with each text token for streaming display.
  Function signature: (lambda (text) ...)
  This is useful for real-time streaming UIs like claude-org mode.

ON-ERROR is called if an error occurs.
  Function signature: (lambda (error) ...)

ON-COMPLETE is called when the query finishes.
  Function signature: (lambda (result-or-error) ...)

SESSION-KEY identifies the session for verbose output grouping (optional).
  When provided, messages will be written to a per-session verbose buffer.

Returns the process state object for potential interruption.
The process state includes a request-id that can be used with
`claude-agent-cancel-query' for cancellation.

Example:
  (claude-agent-query
   \"What is 2+2?\"
   :on-message (lambda (msg)
                 (when (claude-agent-assistant-message-p msg)
                   (message \"Response: %s\"
                            (claude-agent-extract-text msg))))
   :on-token (lambda (text)
               (insert text))  ; For streaming display
   :on-complete (lambda (result)
                  (message \"Done!\"))
   :session-key \"my-session\")"
  (unless prompt
    (error "Prompt is required"))
  (let ((opts (or options (claude-agent-options))))
    (claude-agent--start-process
     prompt
     opts
     on-message
     on-error
     on-complete
     on-token
     nil  ; request-id (auto-generated)
     session-key)))

(defun claude-agent-query-interrupt (state)
  "Interrupt an ongoing query by STATE.
STATE is the process state returned by `claude-agent-query'."
  (when-let ((process (claude-agent--process-state-process state)))
    (when (process-live-p process)
      (interrupt-process process))))

(defun claude-agent-query-request-id (state)
  "Get the request ID from query STATE.
Returns the unique request-id that can be used with `claude-agent-cancel-query'."
  (claude-agent--process-state-request-id state))
#+END_SRC

** Helper Functions

#+BEGIN_SRC elisp
(defun claude-agent-extract-text (message)
  "Extract text content from an assistant MESSAGE.
Returns concatenated text from all text blocks, or nil if no text."
  (when (claude-agent-assistant-message-p message)
    (let ((texts nil))
      (dolist (block (claude-agent-assistant-message-content message))
        (when (claude-agent-text-block-p block)
          (push (claude-agent-text-block-text block) texts)))
      (when texts
        (string-join (nreverse texts) "")))))

(defun claude-agent-message-type (message)
  "Get the type symbol for MESSAGE.
Returns one of: user, assistant, system, result, or unknown."
  (cond
   ((claude-agent-user-message-p message) 'user)
   ((claude-agent-assistant-message-p message) 'assistant)
   ((claude-agent-system-message-p message) 'system)
   ((claude-agent-result-message-p message) 'result)
   (t 'unknown)))

(defun claude-agent-extract-tool-uses (message)
  "Extract tool use blocks from an assistant MESSAGE.
Returns a list of `claude-agent-tool-use-block' structs."
  (when (claude-agent-assistant-message-p message)
    (cl-remove-if-not #'claude-agent-tool-use-block-p
                      (claude-agent-assistant-message-content message))))

(defun claude-agent-extract-thinking (message)
  "Extract thinking content from an assistant MESSAGE.
Returns concatenated thinking text, or nil if none."
  (when (claude-agent-assistant-message-p message)
    (let ((thoughts nil))
      (dolist (block (claude-agent-assistant-message-content message))
        (when (claude-agent-thinking-block-p block)
          (push (claude-agent-thinking-block-thinking block) thoughts)))
      (when thoughts
        (string-join (nreverse thoughts) "\n")))))
#+END_SRC

* Client API

The client API provides bidirectional interactive conversations.

** Client Structure

#+BEGIN_SRC elisp
(cl-defstruct (claude-agent-client
               (:constructor claude-agent--make-client)
               (:copier nil))
  "Interactive Claude client for bidirectional conversations.

Use `claude-agent-client-create' to construct instances."
  state           ; Process state
  options         ; Options plist
  session-id      ; Current session ID
  (connected-p nil) ; Boolean connection state
  hooks           ; Alist of (event . matchers)
  message-queue   ; Queue of pending messages
  on-message      ; Default message callback
  on-error)       ; Default error callback
#+END_SRC

** Client Creation

#+BEGIN_SRC elisp
(cl-defun claude-agent-client-create (&key options on-message on-error)
  "Create a new Claude client.

OPTIONS is a plist created with `claude-agent-options'.
ON-MESSAGE is the default callback for received messages.
ON-ERROR is the default callback for errors.

Returns a `claude-agent-client' struct.

Example:
  (setq my-client
        (claude-agent-client-create
         :options (claude-agent-options
                   :model \"claude-sonnet-4-5\"
                   :permission-mode 'accept-edits)
         :on-message (lambda (msg) (message \"Got: %s\" msg))))"
  (claude-agent--make-client
   :options (or options (claude-agent-options))
   :hooks (plist-get options :hooks)
   :message-queue nil
   :on-message on-message
   :on-error on-error
   :connected-p nil))
#+END_SRC

** Client Methods

#+BEGIN_SRC elisp
(defun claude-agent-client-connect (client &optional initial-prompt)
  "Connect CLIENT to Claude with optional INITIAL-PROMPT.

Starts the CLI process in streaming mode."
  (when (claude-agent-client-connected-p client)
    (error "Client is already connected"))
  (let* ((options (claude-agent-client-options client))
         (prompt (or initial-prompt ""))
         (on-msg (claude-agent-client-on-message client))
         (on-err (claude-agent-client-on-error client)))
    (setf (claude-agent-client-state client)
          (claude-agent--start-process
           prompt
           options
           (lambda (msg)
             ;; Track session ID from result messages
             (when (claude-agent-result-message-p msg)
               (setf (claude-agent-client-session-id client)
                     (claude-agent-result-message-session-id msg)))
             ;; Call user callback
             (when on-msg
               (funcall on-msg msg)))
           on-err
           (lambda (result)
             (setf (claude-agent-client-connected-p client) nil)
             (when (and result on-err)
               (funcall on-err result)))))
    (setf (claude-agent-client-connected-p client) t)
    client))

(cl-defun claude-agent-client-send (client message &key on-response on-error)
  "Send MESSAGE through CLIENT.

MESSAGE is a string to send to Claude.
ON-RESPONSE is called with each response message.
ON-ERROR is called if an error occurs.

Note: This creates a new query process. For true bidirectional
streaming, use the streaming input mode (future feature)."
  (unless (claude-agent-client-connected-p client)
    (error "Client is not connected"))
  ;; For now, start a new process for each message
  ;; Future: implement true bidirectional streaming
  (let* ((options (claude-agent-client-options client))
         ;; Continue from previous session if we have one
         (session-id (claude-agent-client-session-id client))
         (new-options (if session-id
                          (plist-put (copy-sequence options) :resume session-id)
                        options)))
    (setf (claude-agent-client-state client)
          (claude-agent--start-process
           message
           new-options
           (or on-response (claude-agent-client-on-message client))
           (or on-error (claude-agent-client-on-error client))
           (lambda (result)
             (when (and result (claude-agent-client-on-error client))
               (funcall (claude-agent-client-on-error client) result)))))))

(defun claude-agent-client-disconnect (client)
  "Disconnect CLIENT from Claude.

Cleans up process and resources."
  (when (claude-agent-client-connected-p client)
    (when-let ((state (claude-agent-client-state client)))
      (when-let ((process (claude-agent--process-state-process state)))
        (when (process-live-p process)
          (delete-process process)))
      (when-let ((buf (claude-agent--process-state-buffer state)))
        (when (buffer-live-p buf)
          (kill-buffer buf))))
    (setf (claude-agent-client-connected-p client) nil)
    (setf (claude-agent-client-state client) nil)))

(defun claude-agent-client-interrupt (client)
  "Send interrupt signal through CLIENT."
  (when-let ((state (claude-agent-client-state client)))
    (when-let ((process (claude-agent--process-state-process state)))
      (when (process-live-p process)
        (interrupt-process process)))))
#+END_SRC

* Hook System

** Hook Input Structures

#+BEGIN_SRC elisp
(cl-defstruct (claude-agent-pre-tool-use-input
               (:constructor claude-agent-make-pre-tool-use-input)
               (:copier nil))
  "Input for PreToolUse hooks."
  session-id
  tool-name
  tool-input
  cwd
  permission-mode)

(cl-defstruct (claude-agent-post-tool-use-input
               (:constructor claude-agent-make-post-tool-use-input)
               (:copier nil))
  "Input for PostToolUse hooks."
  session-id
  tool-name
  tool-input
  tool-response
  cwd)

(cl-defstruct (claude-agent-stop-input
               (:constructor claude-agent-make-stop-input)
               (:copier nil))
  "Input for Stop hooks."
  session-id
  stop-hook-active)
#+END_SRC

** Hook Invocation

#+BEGIN_SRC elisp
(defun claude-agent-add-hook (client event matcher callback &optional timeout)
  "Add a hook to CLIENT for EVENT.

EVENT is one of `claude-agent-hook-events'.
MATCHER is a string pattern (tool name) or nil for all.
CALLBACK is called when the hook fires.
  For PreToolUse: (lambda (input) ...) where INPUT is `claude-agent-pre-tool-use-input'
    Return plist with :decision (allow, deny, ask)
  For PostToolUse: (lambda (input) ...) where INPUT is `claude-agent-post-tool-use-input'
    Return plist with :additional-context string
  For Stop: (lambda (input) ...) where INPUT is `claude-agent-stop-input'
    Return plist with :continue boolean
TIMEOUT is optional seconds before hook times out."
  (unless (memq event claude-agent-hook-events)
    (error "Unknown hook event: %s" event))
  (let* ((hooks (claude-agent-client-hooks client))
         (matchers (alist-get event hooks))
         (new-matcher (claude-agent-make-hook-matcher
                       :matcher matcher
                       :callbacks (list callback)
                       :timeout (or timeout 60.0))))
    (if matchers
        (setf (alist-get event hooks)
              (append matchers (list new-matcher)))
      (push (cons event (list new-matcher)) hooks))
    (setf (claude-agent-client-hooks client) hooks)))

(defun claude-agent--invoke-hooks (client event input)
  "Invoke hooks on CLIENT for EVENT with INPUT.
Returns combined hook output plist."
  (let ((hooks (claude-agent-client-hooks client))
        (results nil))
    (when-let ((matchers (alist-get event hooks)))
      (dolist (matcher matchers)
        (let ((pattern (claude-agent-hook-matcher-matcher matcher))
              (callbacks (claude-agent-hook-matcher-callbacks matcher))
              (tool-name (and (claude-agent-pre-tool-use-input-p input)
                              (claude-agent-pre-tool-use-input-tool-name input))))
          ;; Check if matcher applies
          (when (or (null pattern)
                    (and tool-name (string-match-p pattern tool-name)))
            (dolist (callback callbacks)
              (condition-case err
                  (let ((result (funcall callback input)))
                    (when result
                      (push result results)))
                (error
                 (claude-agent--debug-log "Hook error: %s" (error-message-string err)))))))))
    ;; Combine results (last result wins for conflicting keys)
    (apply #'append (nreverse results))))
#+END_SRC

* Session Management

#+BEGIN_SRC elisp
(defun claude-agent-continue-session (client)
  "Configure CLIENT to continue from the previous session.
Must be called before `claude-agent-client-connect'."
  (let ((options (claude-agent-client-options client)))
    (setf (claude-agent-client-options client)
          (plist-put options :continue-conversation t))))

(defun claude-agent-resume-session (client session-id)
  "Configure CLIENT to resume SESSION-ID.
Must be called before `claude-agent-client-connect'."
  (let ((options (claude-agent-client-options client)))
    (setf (claude-agent-client-options client)
          (plist-put options :resume session-id))))

(defun claude-agent-get-session-id (client)
  "Get the current session ID from CLIENT.
Returns nil if not yet available."
  (claude-agent-client-session-id client))
#+END_SRC

* Tests

** Unit Tests

#+BEGIN_SRC elisp :load test
(require 'ert)

(ert-deftest claude-agent-test-options-creation ()
  "Test options plist creation."
  (let ((opts (claude-agent-options
               :model "claude-sonnet-4-5"
               :max-turns 5)))
    (should (equal (plist-get opts :model) "claude-sonnet-4-5"))
    (should (equal (plist-get opts :max-turns) 5))
    (should (null (plist-get opts :system-prompt)))))

(ert-deftest claude-agent-test-options-defaults ()
  "Test options defaults."
  (let ((opts (claude-agent-options)))
    (should (null (plist-get opts :model)))
    (should (null (plist-get opts :max-turns)))
    (should (null (plist-get opts :permission-mode)))))

(ert-deftest claude-agent-test-permission-mode-conversion ()
  "Test permission mode symbol to string conversion."
  (should (equal (claude-agent--permission-mode-to-string 'default) "default"))
  (should (equal (claude-agent--permission-mode-to-string 'accept-edits) "acceptEdits"))
  (should (equal (claude-agent--permission-mode-to-string 'plan) "plan"))
  (should (equal (claude-agent--permission-mode-to-string 'bypass-permissions) "bypassPermissions"))
  (should (equal (claude-agent--permission-mode-to-string "custom") "custom"))
  (should (null (claude-agent--permission-mode-to-string nil))))

(ert-deftest claude-agent-test-build-args-basic ()
  "Test basic argument building."
  (let* ((opts (claude-agent-options :model "test-model" :max-turns 3))
         (args (claude-agent--build-args opts nil)))
    (should (member "--output-format" args))
    (should (member "stream-json" args))
    (should (member "--model" args))
    (should (member "test-model" args))
    (should (member "--max-turns" args))
    (should (member "3" args))
    (should (member "--print" args))))

(ert-deftest claude-agent-test-build-args-permission-mode ()
  "Test argument building with permission mode."
  (let* ((opts (claude-agent-options :permission-mode 'accept-edits))
         (args (claude-agent--build-args opts nil)))
    (should (member "--permission-mode" args))
    (should (member "acceptEdits" args))))

(ert-deftest claude-agent-test-build-args-tools ()
  "Test argument building with tools."
  (let* ((opts (claude-agent-options
                :allowed-tools '("Read" "Write")
                :disallowed-tools '("Bash")))
         (args (claude-agent--build-args opts nil)))
    (should (member "--allowedTools" args))
    (should (member "Read,Write" args))
    (should (member "--disallowedTools" args))
    (should (member "Bash" args))))

(ert-deftest claude-agent-test-parse-text-block ()
  "Test parsing text content block."
  (let ((block (claude-agent--parse-content-block
                '(:type "text" :text "Hello world"))))
    (should (claude-agent-text-block-p block))
    (should (equal (claude-agent-text-block-text block) "Hello world"))))

(ert-deftest claude-agent-test-parse-tool-use-block ()
  "Test parsing tool use content block."
  (let ((block (claude-agent--parse-content-block
                '(:type "tool_use"
                  :id "tool_123"
                  :name "Read"
                  :input (:path "/tmp/test.txt")))))
    (should (claude-agent-tool-use-block-p block))
    (should (equal (claude-agent-tool-use-block-id block) "tool_123"))
    (should (equal (claude-agent-tool-use-block-name block) "Read"))
    (should (equal (plist-get (claude-agent-tool-use-block-input block) :path)
                   "/tmp/test.txt"))))

(ert-deftest claude-agent-test-parse-assistant-message ()
  "Test parsing assistant message."
  (let ((msg (claude-agent--parse-message
              '(:type "assistant"
                :message (:content ((:type "text" :text "Hello"))
                          :model "claude-sonnet-4-5")))))
    (should (claude-agent-assistant-message-p msg))
    (should (equal (claude-agent-assistant-message-model msg) "claude-sonnet-4-5"))
    (should (= (length (claude-agent-assistant-message-content msg)) 1))
    (should (claude-agent-text-block-p
             (car (claude-agent-assistant-message-content msg))))))

(ert-deftest claude-agent-test-parse-result-message ()
  "Test parsing result message."
  (let ((msg (claude-agent--parse-message
              '(:type "result"
                :subtype "success"
                :session_id "sess_123"
                :total_cost_usd 0.01
                :num_turns 1))))
    (should (claude-agent-result-message-p msg))
    (should (equal (claude-agent-result-message-session-id msg) "sess_123"))
    (should (equal (claude-agent-result-message-total-cost-usd msg) 0.01))
    (should (equal (claude-agent-result-message-num-turns msg) 1))))

(ert-deftest claude-agent-test-extract-text ()
  "Test extracting text from assistant message."
  (let ((msg (claude-agent-make-assistant-message
              :content (list (claude-agent-make-text-block :text "Hello ")
                             (claude-agent-make-text-block :text "World"))
              :model "test")))
    (should (equal (claude-agent-extract-text msg) "Hello World"))))

(ert-deftest claude-agent-test-extract-text-no-text ()
  "Test extracting text when no text blocks."
  (let ((msg (claude-agent-make-assistant-message
              :content (list (claude-agent-make-tool-use-block
                              :id "1" :name "Test" :input nil))
              :model "test")))
    (should (null (claude-agent-extract-text msg)))))

(ert-deftest claude-agent-test-message-type ()
  "Test message type detection."
  (should (eq (claude-agent-message-type
               (claude-agent-make-user-message :content "test"))
              'user))
  (should (eq (claude-agent-message-type
               (claude-agent-make-assistant-message :content nil :model "test"))
              'assistant))
  (should (eq (claude-agent-message-type
               (claude-agent-make-system-message :subtype "init" :data nil))
              'system))
  (should (eq (claude-agent-message-type
               (claude-agent-make-result-message :subtype "success"))
              'result))
  (should (eq (claude-agent-message-type "unknown") 'unknown)))

(ert-deftest claude-agent-test-client-creation ()
  "Test client creation."
  (let ((client (claude-agent-client-create
                 :options (claude-agent-options :model "test"))))
    (should (claude-agent-client-p client))
    (should (not (claude-agent-client-connected-p client)))
    (should (null (claude-agent-client-session-id client)))))

(ert-deftest claude-agent-test-hook-events ()
  "Test hook events constant."
  (should (memq 'PreToolUse claude-agent-hook-events))
  (should (memq 'PostToolUse claude-agent-hook-events))
  (should (memq 'Stop claude-agent-hook-events)))

;; Permission System Tests

(ert-deftest claude-agent-test-permission-wildcard ()
  "Test wildcard pattern matches all tools."
  (should (claude-agent-permission-match-p "Read" nil "*"))
  (should (claude-agent-permission-match-p "Bash" nil "*"))
  (should (claude-agent-permission-match-p "mcp__emacs__evalElisp" nil "*")))

(ert-deftest claude-agent-test-permission-tool-name ()
  "Test simple tool name matching."
  (should (claude-agent-permission-match-p "WebSearch" nil "WebSearch"))
  (should-not (claude-agent-permission-match-p "WebFetch" nil "WebSearch"))
  (should (claude-agent-permission-match-p "Read" nil "Read")))

(ert-deftest claude-agent-test-permission-glob-pattern ()
  "Test glob patterns for MCP tools."
  (should (claude-agent-permission-match-p "mcp__emacs__evalElisp" nil "mcp__emacs__*"))
  (should (claude-agent-permission-match-p "mcp__context7__getDocs" nil "mcp__context7__*"))
  (should-not (claude-agent-permission-match-p "mcp__emacs__evalElisp" nil "mcp__context7__*")))

(ert-deftest claude-agent-test-permission-with-args ()
  "Test patterns with argument matching."
  (should (claude-agent-permission-match-p "Read" '(:file_path "/any/file.txt") "Read(**)"))
  (should (claude-agent-permission-match-p "Bash" '(:command "git status") "Bash(git:*)"))
  (should-not (claude-agent-permission-match-p "Bash" '(:command "rm -rf /") "Bash(git:*)")))

(ert-deftest claude-agent-test-permission-check-deny-first ()
  "Test that deny patterns take precedence."
  (let ((allow '("Bash(**)"))
        (deny '("Bash(rm *)")))
    (should (eq 'deny (claude-agent-check-permission
                       "Bash" '(:command "rm -rf /") allow deny)))
    (should (eq 'allow (claude-agent-check-permission
                        "Bash" '(:command "ls -la") allow deny)))))

(ert-deftest claude-agent-test-effective-permissions ()
  "Test getting effective permissions from presets."
  (let ((claude-agent-permission-preset "readonly"))
    (let ((perms (claude-agent-get-effective-permissions)))
      (should (member "Read(**)" (plist-get perms :allow)))
      (should (null (plist-get perms :deny))))))

;; Session Management Tests

(ert-deftest claude-agent-test-session-key-creation ()
  "Test session key creation."
  (should (equal "/path/to/file.org"
                 (claude-agent--make-session-key "/path/to/file.org" nil)))
  (should (equal "/path/to/file.org::my-session"
                 (claude-agent--make-session-key "/path/to/file.org" "my-session"))))

(ert-deftest claude-agent-test-session-mapping ()
  "Test session UUID mapping."
  (claude-agent--clear-all-sessions)
  (let ((key "test-file::test-session")
        (uuid "abc-123-def-456"))
    (should (null (claude-agent--get-sdk-uuid key)))
    (claude-agent--store-sdk-uuid key uuid)
    (should (equal uuid (claude-agent--get-sdk-uuid key)))
    (claude-agent--clear-session key)
    (should (null (claude-agent--get-sdk-uuid key)))))

(ert-deftest claude-agent-test-session-expired-detection ()
  "Test session expiration detection."
  (should (claude-agent--session-expired-p "No conversation found with session ID abc-123"))
  (should (claude-agent--session-expired-p "session not found"))
  (should (claude-agent--session-expired-p "session expired"))
  (should-not (claude-agent--session-expired-p "some other error")))

;; IDE Context Tests

(ert-deftest claude-agent-test-system-reminder-empty ()
  "Test system reminder with no context returns empty string."
  (should (equal "" (claude-agent-build-system-reminder))))

(ert-deftest claude-agent-test-system-reminder-with-file ()
  "Test system reminder with current file."
  (let ((result (claude-agent-build-system-reminder
                 :current-file '(:name "test.el" :path "/path/test.el" :modified t))))
    (should (string-match-p "<system-reminder>" result))
    (should (string-match-p "test.el" result))
    (should (string-match-p "(modified)" result))))

(ert-deftest claude-agent-test-system-reminder-with-notebook ()
  "Test system reminder with conversation notebook."
  (let ((result (claude-agent-build-system-reminder
                 :file-path "/path/to/notes.org")))
    (should (string-match-p "Conversation notebook:" result))
    (should (string-match-p "/path/to/notes.org" result))))
#+END_SRC

* Permission System

This section provides permission pattern matching for controlling which
Claude tools are allowed or denied. It ports the permission system from
the Python backend.

** Permission Presets

#+BEGIN_SRC elisp
(defcustom claude-agent-permission-preset "readonly"
  "Permission preset for Claude operations.
Options:
  - \"readonly\": Read, Glob, Grep, WebSearch, WebFetch, Task, MCP tools
  - \"accept-edits\": Adds Write, Edit, MultiEdit, TodoWrite
  - \"bypass\": Allow all operations
  - \"custom\": Use `claude-agent-permissions'"
  :type '(choice (const :tag "Read-only (recommended)" "readonly")
                 (const :tag "Accept Edits" "accept-edits")
                 (const :tag "Bypass All" "bypass")
                 (const :tag "Custom" "custom"))
  :group 'claude-agent)

(defcustom claude-agent-permissions
  '(:allow ("Read(**)" "Glob(**)" "Grep(**)" "WebSearch" "WebFetch")
    :deny ())
  "Custom permission patterns when preset is \"custom\".
Format: (:allow (patterns...) :deny (patterns...))

Pattern examples:
  - \"Read(**)\" - Allow reading any file
  - \"Bash(git:*)\" - Allow bash commands starting with git
  - \"Read(**/.env)\" - Match .env files (use in :deny)
  - \"mcp__emacs__*\" - Allow all Emacs MCP tools"
  :type '(plist :key-type symbol :value-type (repeat string))
  :group 'claude-agent)

(defconst claude-agent--preset-permissions
  '(("readonly" . (:allow ("Read(**)" "Glob(**)" "Grep(**)" "WebSearch" "WebFetch" "Task"
                           "mcp__emacs__*" "mcp__context7__*")
                   :deny ()))
    ("accept-edits" . (:allow ("Read(**)" "Glob(**)" "Grep(**)" "Write(**)" "Edit(**)"
                               "MultiEdit(**)" "WebSearch" "WebFetch" "Task" "TodoWrite"
                               "mcp__emacs__*" "mcp__context7__*")
                      :deny ()))
    ("bypass" . (:allow ("*")
                 :deny ())))
  "Built-in permission presets.")

(defconst claude-agent--default-deny-patterns
  '("Bash(rm *)" "Bash(sudo *)" "Bash(chmod 777 *)")
  "Default deny patterns for safety.
These are always checked regardless of preset.")
#+END_SRC

** Pattern Matching

#+BEGIN_SRC elisp
(defun claude-agent--get-tool-first-arg (tool-name tool-input)
  "Get the first string argument from TOOL-INPUT for pattern matching.
Different tools have different primary arguments."
  (cond
   ;; File operations use file_path
   ((member tool-name '("Read" "Write" "Edit" "MultiEdit"))
    (plist-get tool-input :file_path))
   ;; Glob uses pattern
   ((string= tool-name "Glob")
    (plist-get tool-input :pattern))
   ;; Grep uses path or pattern
   ((string= tool-name "Grep")
    (or (plist-get tool-input :path)
        (plist-get tool-input :pattern)))
   ;; Bash uses command
   ((string= tool-name "Bash")
    (plist-get tool-input :command))
   ;; WebSearch uses query
   ((string= tool-name "WebSearch")
    (plist-get tool-input :query))
   ;; WebFetch uses url
   ((string= tool-name "WebFetch")
    (plist-get tool-input :url))
   ;; Task uses subagent_type
   ((string= tool-name "Task")
    (plist-get tool-input :subagent_type))
   ;; TodoWrite uses first todo content
   ((string= tool-name "TodoWrite")
    (let ((todos (plist-get tool-input :todos)))
      (when (and todos (listp todos) (car todos))
        (plist-get (car todos) :content))))
   ;; Default: find first string value
   (t
    (cl-loop for val in tool-input
             when (stringp val)
             return val))))

(defun claude-agent-permission-match-p (tool-name tool-input pattern)
  "Check if TOOL-NAME with TOOL-INPUT matches PATTERN.
Patterns can be:
  - \"*\" matches all tools
  - \"ToolName\" matches tool by name only
  - \"ToolName(**)\" matches tool with any arguments
  - \"ToolName(arg-pattern)\" matches tool with specific argument pattern
  - \"mcp__server__*\" matches MCP tools with glob"
  (cond
   ;; Wildcard matches everything
   ((string= pattern "*") t)

   ;; Glob pattern for tool names (e.g., mcp__emacs__*)
   ((and (string-match-p "\\*" pattern)
         (not (string-match-p "(" pattern)))
    (let ((regex (concat "^"
                         (replace-regexp-in-string "\\*" ".*" (regexp-quote pattern))
                         "$")))
      ;; Remove double escaping from the replacement
      (setq regex (replace-regexp-in-string "\\\\\\.\\*" ".*" regex))
      (string-match-p regex tool-name)))

   ;; Pattern with arguments: ToolName(args)
   ((string-match "^\\([A-Za-z_][A-Za-z0-9_]*\\)(\\(.*\\))$" pattern)
    (let ((pattern-tool (match-string 1 pattern))
          (pattern-args (match-string 2 pattern)))
      (and (string= tool-name pattern-tool)
           (claude-agent--match-arg-pattern
            (claude-agent--get-tool-first-arg tool-name tool-input)
            pattern-args))))

   ;; Simple tool name match
   ((string-match "^[A-Za-z_][A-Za-z0-9_]*$" pattern)
    (string= tool-name pattern))

   ;; No match
   (t nil)))

(defun claude-agent--match-arg-pattern (arg pattern)
  "Check if ARG matches PATTERN.
Supports:
  - \"**\" matches anything
  - \"prefix:*\" matches args starting with prefix
  - \"*\" at end for prefix matching
  - Literal string matching"
  (when (and arg pattern)
    (cond
     ;; ** matches anything
     ((string= pattern "**") t)

     ;; prefix:* pattern (e.g., git:* matches 'git status')
     ((string-match "^\\([^:]+\\):\\*$" pattern)
      (let ((prefix (match-string 1 pattern)))
        (string-prefix-p prefix arg)))

     ;; Ends with * for prefix matching
     ((string-suffix-p "*" pattern)
      (string-prefix-p (substring pattern 0 -1) arg))

     ;; Contains ** for glob-style matching
     ((string-match-p "\\*\\*" pattern)
      (let ((regex (concat "^"
                           (replace-regexp-in-string
                            "\\*\\*" ".*"
                            (regexp-quote pattern))
                           "$")))
        (setq regex (replace-regexp-in-string "\\\\\\.\\*" ".*" regex))
        (string-match-p regex arg)))

     ;; Literal match
     (t (string= arg pattern)))))
#+END_SRC

** Permission Checking

#+BEGIN_SRC elisp
(defun claude-agent-check-permission (tool-name tool-input allow-patterns deny-patterns)
  "Check if TOOL-NAME with TOOL-INPUT should be allowed.
Returns 'allow, 'deny, or 'ask.
Deny patterns are checked first and take precedence."
  (catch 'result
    ;; Always check default deny patterns first
    (dolist (pattern claude-agent--default-deny-patterns)
      (when (claude-agent-permission-match-p tool-name tool-input pattern)
        (throw 'result 'deny)))
    ;; Check user deny patterns
    (dolist (pattern deny-patterns)
      (when (claude-agent-permission-match-p tool-name tool-input pattern)
        (throw 'result 'deny)))
    ;; Check allow patterns
    (dolist (pattern allow-patterns)
      (when (claude-agent-permission-match-p tool-name tool-input pattern)
        (throw 'result 'allow)))
    ;; Default to ask
    'ask))

(defun claude-agent-get-effective-permissions ()
  "Get effective permissions based on current preset.
Returns plist with :allow and :deny lists."
  (if (string= claude-agent-permission-preset "custom")
      claude-agent-permissions
    (alist-get claude-agent-permission-preset claude-agent--preset-permissions
               nil nil #'string=)))

(defun claude-agent-make-permission-hook (allow-patterns deny-patterns)
  "Create a PreToolUse hook for permission checking.
ALLOW-PATTERNS is list of patterns that allow tool use.
DENY-PATTERNS is list of patterns that deny tool use.
Returns a function that can be used with the hook system."
  (lambda (input)
    (let* ((tool-name (claude-agent-pre-tool-use-input-tool-name input))
           (tool-input (claude-agent-pre-tool-use-input-tool-input input))
           (decision (claude-agent-check-permission
                      tool-name tool-input allow-patterns deny-patterns)))
      (pcase decision
        ('allow
         '(:decision "allow"))
        ('deny
         '(:decision "deny" :reason "Denied by permission policy"))
        ('ask
         ;; Default to allow for now; could prompt user
         '(:decision "allow"))))))
#+END_SRC

* IDE Context

This section provides functions for collecting IDE context from Emacs
and building system reminder tags that match the Python backend format.

** Buffer Filtering

#+BEGIN_SRC elisp
(defcustom claude-agent-ide-context-exclude-buffer-names
  '("*Claude Chat*" "*Messages*" "*scratch*" "*Completions*")
  "List of buffer name patterns to exclude from IDE context.
Patterns are matched using `string-match-p' (regexp)."
  :type '(repeat string)
  :group 'claude-agent)

(defcustom claude-agent-ide-context-exclude-modes
  '(claude-agent-chat-mode special-mode dired-mode)
  "List of major modes to exclude from IDE context."
  :type '(repeat symbol)
  :group 'claude-agent)

(defvar claude-agent-ide-context-exclude-predicates nil
  "List of predicate functions for excluding buffers from IDE context.
Each function takes a buffer as argument and returns non-nil to exclude it.
This allows dynamic exclusion, e.g., for claude-org-mode buffers.")

(defun claude-agent--buffer-excluded-p (buffer)
  "Check if BUFFER should be excluded from IDE context.
Returns non-nil if buffer matches any exclusion criteria."
  (or
   ;; Check buffer name patterns
   (cl-some (lambda (pattern)
              (string-match-p pattern (buffer-name buffer)))
            claude-agent-ide-context-exclude-buffer-names)
   ;; Check major mode
   (with-current-buffer buffer
     (cl-some (lambda (mode)
                (derived-mode-p mode))
              claude-agent-ide-context-exclude-modes))
   ;; Check custom predicates
   (cl-some (lambda (pred)
              (funcall pred buffer))
            claude-agent-ide-context-exclude-predicates)))
#+END_SRC

** Buffer Information

#+BEGIN_SRC elisp
(defun claude-agent--format-buffer-info (buffer)
  "Format BUFFER info as plist with :name :path :modified."
  (with-current-buffer buffer
    (list :name (buffer-name)
          :path (buffer-file-name)
          :modified (buffer-modified-p))))

(defun claude-agent--get-file-buffers (&optional limit)
  "Get list of file-visiting buffers, up to LIMIT (default 10).
Excludes buffers matching `claude-agent-ide-context-exclude-buffer-names',
`claude-agent-ide-context-exclude-modes', or any predicate in
`claude-agent-ide-context-exclude-predicates'."
  (let ((limit (or limit 10))
        (buffers nil))
    (dolist (buf (buffer-list))
      (when (and (buffer-file-name buf)
                 (not (claude-agent--buffer-excluded-p buf))
                 (< (length buffers) limit))
        (push (claude-agent--format-buffer-info buf) buffers)))
    (nreverse buffers)))
#+END_SRC

** Selection Formatting

#+BEGIN_SRC elisp
(defun claude-agent--format-selection ()
  "Format current selection as plist with :text :start-line :end-line.
Returns nil if no region active. Truncates text at 500 chars."
  (when (use-region-p)
    (let* ((start (region-beginning))
           (end (region-end))
           (text (buffer-substring-no-properties start end))
           (start-line (line-number-at-pos start))
           (end-line (line-number-at-pos end)))
      (list :text (if (> (length text) 500)
                      (concat (substring text 0 500) "...")
                    text)
            :start-line start-line
            :end-line end-line))))
#+END_SRC

** IDE Context Collection

#+BEGIN_SRC elisp
(defun claude-agent--get-current-file-buffer ()
  "Get the most recently used file buffer that is not excluded.
Returns the buffer object or nil if none found.
This finds the most recently visited file buffer from `buffer-list',
which works correctly even when called from a special buffer like Claude Chat."
  (cl-loop for buf in (buffer-list)
           when (and (buffer-file-name buf)
                     (not (claude-agent--buffer-excluded-p buf)))
           return buf))

(defun claude-agent-collect-ide-context ()
  "Collect IDE context from current Emacs state.
Returns plist with:
  :current-file - Most recent non-excluded file buffer info (name, path, modified)
  :open-files   - List of file-visiting buffers (max 10), excludes filtered buffers
  :selection    - Region info if active (text, start-line, end-line)
  :cwd          - Current working directory

Buffers are filtered according to `claude-agent-ide-context-exclude-buffer-names',
`claude-agent-ide-context-exclude-modes', and `claude-agent-ide-context-exclude-predicates'.

Note: current-file is determined by finding the most recently used file buffer
from `buffer-list', not necessarily `current-buffer'. This allows correct context
collection when called from special buffers like Claude Chat."
  (let ((current-buf (claude-agent--get-current-file-buffer)))
    (list :current-file (when current-buf
                          (claude-agent--format-buffer-info current-buf))
          :open-files (claude-agent--get-file-buffers 10)
          :selection (claude-agent--format-selection)
          :cwd default-directory)))
#+END_SRC

** System Reminder Building

#+BEGIN_SRC elisp
(cl-defun claude-agent-build-system-reminder (&key current-file open-files
                                                   selection file-path)
  "Build <system-reminder> tag with IDE context.
Returns string suitable for prepending to user prompt.

CURRENT-FILE is plist with :name :path :modified.
OPEN-FILES is list of such plists.
SELECTION is plist with :text :start-line :end-line.
FILE-PATH is the conversation notebook path."
  (let ((parts nil))
    ;; Current file
    (when current-file
      (let ((name (or (plist-get current-file :name)
                      (plist-get current-file :path)
                      "unknown"))
            (path (plist-get current-file :path))
            (modified (plist-get current-file :modified)))
        (push (concat "The user is currently editing: "
                      name
                      (if modified " (modified)" "")
                      (if path (format " (%s)" path) ""))
              parts)))

    ;; Open files
    (when open-files
      (let ((file-list
             (mapconcat
              (lambda (f)
                (concat (or (plist-get f :name)
                            (plist-get f :path)
                            "unknown")
                        (if (plist-get f :modified) "*" "")))
              (seq-take open-files 10)
              ", ")))
        (push (format "Open files in editor: %s" file-list) parts)))

    ;; Selection
    (when selection
      (let ((text (plist-get selection :text))
            (start-line (plist-get selection :start-line))
            (end-line (plist-get selection :end-line)))
        (when text
          (push (format "Selected code (lines %d-%d):\n```\n%s\n```"
                        start-line end-line text)
                parts))))

    ;; Conversation notebook
    (when file-path
      (push (format "Conversation notebook: %s" file-path) parts))

    ;; Build final string
    (if parts
        (concat "<system-reminder>\n"
                (mapconcat #'identity (nreverse parts) "\n")
                "\n</system-reminder>")
      "")))

(defun claude-agent-get-system-reminder (&optional file-path)
  "Get system reminder with automatically collected IDE context.
FILE-PATH is the optional conversation notebook path.
All other context (current-file, open-files, selection) is collected
automatically from current Emacs state."
  (let ((context (claude-agent-collect-ide-context)))
    (claude-agent-build-system-reminder
     :current-file (plist-get context :current-file)
     :open-files (plist-get context :open-files)
     :selection (plist-get context :selection)
     :file-path file-path)))
#+END_SRC

* Session Management

This section provides file-based session management, mapping internal
session keys (file_path::session_id) to SDK UUIDs for conversation resume.

** Session Mapping

#+BEGIN_SRC elisp
(defvar claude-agent--session-mapping (make-hash-table :test 'equal)
  "Map internal session keys to SDK UUIDs.
Internal keys use format: file_path::session_id or just file_path.
SDK UUIDs are returned by Claude CLI for session resume.")

(defun claude-agent--make-session-key (file-path &optional session-id)
  "Create internal session key from FILE-PATH and optional SESSION-ID.
If SESSION-ID provided: \"file-path::session-id\"
Otherwise: \"file-path\""
  (if (and file-path session-id)
      (format "%s::%s" file-path session-id)
    file-path))

(defun claude-agent--get-sdk-uuid (session-key)
  "Look up SDK UUID for SESSION-KEY.
Returns nil if no mapping exists."
  (gethash session-key claude-agent--session-mapping))

(defun claude-agent--store-sdk-uuid (session-key sdk-uuid)
  "Store SDK-UUID mapping for SESSION-KEY."
  (when (and session-key sdk-uuid)
    (puthash session-key sdk-uuid claude-agent--session-mapping)
    (claude-agent--debug-log "Session stored: %s -> %s" session-key sdk-uuid)))

(defun claude-agent--clear-session (session-key)
  "Clear session mapping for SESSION-KEY.
Use when session expires or needs reset."
  (when session-key
    (remhash session-key claude-agent--session-mapping)
    ;; Optionally kill verbose buffer
    (when claude-agent-verbose-buffer-auto-kill
      (when-let ((buf (gethash session-key claude-agent--session-verbose-buffers)))
        (when (buffer-live-p buf)
          (kill-buffer buf)))
      (remhash session-key claude-agent--session-verbose-buffers))
    (claude-agent--debug-log "Session cleared: %s" session-key)))

(defun claude-agent--clear-all-sessions ()
  "Clear all session mappings."
  (clrhash claude-agent--session-mapping)
  ;; Optionally kill all verbose buffers
  (when claude-agent-verbose-buffer-auto-kill
    (maphash (lambda (_key buf)
               (when (buffer-live-p buf)
                 (kill-buffer buf)))
             claude-agent--session-verbose-buffers)
    (clrhash claude-agent--session-verbose-buffers)))
#+END_SRC

** Session Expiration

#+BEGIN_SRC elisp
(defun claude-agent--session-expired-p (error-message)
  "Check if ERROR-MESSAGE indicates session expiration.
Returns non-nil if the error is about an expired/missing session."
  (when (stringp error-message)
    (or (string-match-p "No conversation found with session ID" error-message)
        (string-match-p "session.*not found" error-message)
        (string-match-p "session.*expired" error-message))))
#+END_SRC

* Query Cancellation

This section provides query cancellation support by tracking active
queries and allowing them to be interrupted.

** Active Query Tracking

#+BEGIN_SRC elisp
(defvar claude-agent--active-queries (make-hash-table :test 'equal)
  "Map request-id to process state for cancellation support.")

(defvar claude-agent--request-counter 0
  "Counter for generating unique request IDs.")

(defun claude-agent--generate-request-id ()
  "Generate a unique request ID for query tracking."
  (format "req-%d-%.0f" (cl-incf claude-agent--request-counter) (* 1000 (float-time))))

(defun claude-agent--register-query (request-id state)
  "Register STATE for REQUEST-ID in active queries table."
  (when request-id
    (puthash request-id state claude-agent--active-queries)))

(defun claude-agent--unregister-query (request-id)
  "Remove REQUEST-ID from active queries table."
  (when request-id
    (remhash request-id claude-agent--active-queries)))

(defun claude-agent--get-active-query (request-id)
  "Get process state for REQUEST-ID."
  (gethash request-id claude-agent--active-queries))
#+END_SRC

** Cancellation Functions

#+BEGIN_SRC elisp
(defun claude-agent-cancel-query (request-id)
  "Cancel active query by REQUEST-ID.
Sends SIGINT to process and marks state as cancelled.
Returns t if cancelled, nil if not found."
  (let ((state (claude-agent--get-active-query request-id)))
    (when state
      (let ((process (claude-agent--process-state-process state)))
        (when (and process (process-live-p process))
          ;; Mark as cancelled
          (setf (claude-agent--process-state-closed state) t)
          ;; Send interrupt signal
          (interrupt-process process)
          (claude-agent--debug-log "Query cancelled: %s" request-id)
          t)))))

(defun claude-agent-cancel-all-queries ()
  "Cancel all active queries."
  (maphash (lambda (id _state)
             (claude-agent-cancel-query id))
           claude-agent--active-queries))
#+END_SRC

* Activity Mode-Line

This section provides a mode-line indicator showing when Claude queries are active.
Displays a spinning indicator when queries are in progress. Auto-enabled on load.

** State Variables

#+BEGIN_SRC elisp
(defvar claude-agent-activity-string ""
  "Current activity string for mode-line display.
Shows spinner when queries are active, empty when idle.")

(defvar claude-agent--activity-timer nil
  "Timer for updating the activity spinner.")

(defconst claude-agent--spinner-frames '("" "" "" "")
  "Spinner animation frames for activity indicator.")

(defvar claude-agent--spinner-index 0
  "Current index in spinner-frames for animation.")
#+END_SRC

** Activity Count

#+BEGIN_SRC elisp
(defun claude-agent-active-query-count ()
  "Return count of currently active queries."
  (let ((count 0))
    (maphash (lambda (_id state)
               (when (and state
                          (claude-agent--process-state-p state)
                          (not (claude-agent--process-state-closed state)))
                 ;; Count as active if not closed, even if process ended
                 ;; (process might be nil during cleanup)
                 (cl-incf count)))
             claude-agent--active-queries)
    count))

(defun claude-agent-active-p ()
  "Return non-nil if any queries are currently active."
  (> (claude-agent-active-query-count) 0))
#+END_SRC

** Activity Display

#+BEGIN_SRC elisp
(defun claude-agent--format-elapsed (start-time)
  "Format elapsed time since START-TIME as human-readable string."
  (if (null start-time)
      "unknown"
    (let ((elapsed (- (float-time) start-time)))
      (cond
       ((< elapsed 60)
        (format "%ds" (round elapsed)))
       ((< elapsed 3600)
        (format "%dm" (round (/ elapsed 60))))
       (t
        (format "%dh" (round (/ elapsed 3600))))))))

(defun claude-agent--format-activity-tooltip ()
  "Format tooltip showing all active queries."
  (let ((lines (list "Active Queries" "")))
    (maphash
     (lambda (id state)
       (when (and state
                  (claude-agent--process-state-p state)
                  (not (claude-agent--process-state-closed state)))
         (let* ((start-time (claude-agent--process-state-start-time state))
                (elapsed (claude-agent--format-elapsed start-time))
                (spinner (nth claude-agent--spinner-index claude-agent--spinner-frames))
                ;; Extract short ID from request-id
                (short-id (if (string-match "req-\\([0-9]+\\)" id)
                              (format "#%s" (match-string 1 id))
                            (substring id 0 (min 12 (length id))))))
           (push (format " %s  [%s %s]" short-id spinner elapsed) lines))))
     claude-agent--active-queries)
    (if (= (length lines) 2)
        "No active queries\n\nClick to open session manager"
      (concat (string-join (nreverse lines) "\n")
              "\n\nClick to open session manager"))))

(defun claude-agent--update-activity-string ()
  "Update the activity mode-line string based on active queries."
  (let ((count (claude-agent-active-query-count)))
    (if (> count 0)
        (let* ((spinner (nth claude-agent--spinner-index claude-agent--spinner-frames))
               (display (if (= count 1)
                            (format " [C:%s]" spinner)
                          (format " [C:%s%d]" spinner count))))
          (setq claude-agent--spinner-index
                (mod (1+ claude-agent--spinner-index)
                     (length claude-agent--spinner-frames)))
          (setq claude-agent-activity-string
                (propertize display
                            'face '(:foreground "orange" :weight bold)
                            'help-echo (claude-agent--format-activity-tooltip)
                            'mouse-face 'mode-line-highlight
                            'local-map (let ((map (make-sparse-keymap)))
                                         (define-key map [mode-line mouse-1]
                                                     #'claude-agent-list-queries)
                                         map))))
      ;; No active queries
      (setq claude-agent-activity-string "")
      (setq claude-agent--spinner-index 0)))
  (force-mode-line-update t))
#+END_SRC

** Session Manager

#+BEGIN_SRC elisp
(defvar claude-agent-queries-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "k") #'claude-agent-queries-cancel-at-point)
    (define-key map (kbd "K") #'claude-agent-cancel-all-queries)
    (define-key map (kbd "g") #'claude-agent-list-queries)
    (define-key map (kbd "q") #'quit-window)
    map)
  "Keymap for `claude-agent-queries-mode'.")

(define-derived-mode claude-agent-queries-mode special-mode "Claude-Queries"
  "Major mode for viewing and managing Claude Agent queries."
  (setq buffer-read-only t)
  (setq truncate-lines t))

(defun claude-agent-list-queries ()
  "Display buffer showing all active queries."
  (interactive)
  (let ((buf (get-buffer-create "*Claude Queries*")))
    (with-current-buffer buf
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert "Active Queries\n")
        (insert "\n\n")
        (let ((has-queries nil))
          (maphash
           (lambda (id state)
             (when (and state
                        (claude-agent--process-state-p state)
                        (not (claude-agent--process-state-closed state)))
               (setq has-queries t)
               (let* ((start-time (claude-agent--process-state-start-time state))
                      (elapsed (claude-agent--format-elapsed start-time))
                      ;; Short display ID
                      (short-id (if (string-match "req-\\([0-9]+\\)" id)
                                    (format "#%s" (match-string 1 id))
                                  id)))
                 (insert (propertize (format " %s" short-id)
                                     'face 'font-lock-function-name-face
                                     'query-id id))
                 (insert (format "  [%s]\n" elapsed)))))
           claude-agent--active-queries)
          (unless has-queries
            (insert "No active queries.\n")))
        (insert "\n")
        (insert "Keys: k=cancel  K=cancel all  g=refresh  q=quit\n"))
      (claude-agent-queries-mode)
      (goto-char (point-min)))
    (display-buffer buf)))

(defun claude-agent-queries-cancel-at-point ()
  "Cancel the query on the current line."
  (interactive)
  (let ((query-id (get-text-property (point) 'query-id)))
    (if query-id
        (progn
          (claude-agent-cancel-query query-id)
          (message "Cancelled query: %s" query-id)
          (claude-agent-list-queries))
      (message "No query on this line."))))
#+END_SRC

** Auto-Enable

#+BEGIN_SRC elisp
;; Cancel existing timer if any
(when (timerp claude-agent--activity-timer)
  (cancel-timer claude-agent--activity-timer))

;; Start activity timer (shows nothing when idle)
(setq claude-agent--activity-timer
      (run-with-timer 0 0.2 #'claude-agent--update-activity-string))

;; Add to mode-line if not already present
(unless (member '(:eval claude-agent-activity-string) mode-line-misc-info)
  (push '(:eval claude-agent-activity-string) mode-line-misc-info))
#+END_SRC

* Usage Mode-Line

This section provides Claude usage statistics display in the Emacs mode-line,
showing 5-hour, 7-day, and 7-day Sonnet utilization percentages.

** Customization

#+BEGIN_SRC elisp
(defcustom claude-agent-usage-org-id nil
  "Claude organization ID for usage tracking.
Get from claude.ai account settings or from the URL when logged in."
  :type '(choice (const :tag "Not set" nil) string)
  :group 'claude-agent)

(defvar claude-agent-usage-string ""
  "Current usage string for mode-line display.")

(defvar claude-agent-usage-timer nil
  "Timer for refreshing Claude usage.")

(defvar claude-agent-usage-data nil
  "Cached usage data for tooltip.")
#+END_SRC

** Helper Functions

#+BEGIN_SRC elisp
(defun claude-agent--get-session-key ()
  "Get CLAUDE_SESSION_KEY from environment variable.
Returns nil if not set."
  (getenv "CLAUDE_SESSION_KEY"))

(defun claude-agent-usage-working-hours-p ()
  "Return t if current time is within working hours (Mon-Fri, 8am-7pm)."
  (let ((hour (string-to-number (format-time-string "%H")))
        (dow (string-to-number (format-time-string "%u")))) ; 1=Mon, 7=Sun
    (and (>= dow 1) (<= dow 5)      ; Monday to Friday
         (>= hour 8) (< hour 19)))) ; 8am to 7pm

(defun claude-agent-usage-format-reset-time (iso-time)
  "Format ISO-TIME to human readable relative time.
Shows days and hours for periods >= 24h, otherwise hours and minutes."
  (if iso-time
      (let* ((time (parse-iso8601-time-string iso-time))
             (diff (float-time (time-subtract time (current-time)))))
        (if (> diff 0)
            (let* ((days (floor (/ diff 86400)))
                   (hours (floor (/ (mod diff 86400) 3600)))
                   (mins (floor (/ (mod diff 3600) 60))))
              (if (>= days 1)
                  (format "%dd %dh" days hours)
                (format "%dh %dm" hours mins)))
          "soon"))
    "N/A"))
#+END_SRC

** Fetch and Callback

#+BEGIN_SRC elisp
(defun claude-agent-usage-fetch ()
  "Fetch usage data directly from claude.ai and update mode-line."
  (interactive)
  (let ((session-key (claude-agent--get-session-key))
        (org-id claude-agent-usage-org-id))
    (if (and session-key org-id)
        (let ((url (format "https://claude.ai/api/organizations/%s/usage" org-id))
              (url-request-extra-headers
               `(("Accept" . "application/json")
                 ("Content-Type" . "application/json")
                 ("Cookie" . ,(format "sessionKey=%s" session-key))
                 ("User-Agent" . "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36")
                 ("Origin" . "https://claude.ai")
                 ("Referer" . "https://claude.ai/"))))
          (url-retrieve url #'claude-agent-usage-callback '() t t))
      ;; Show config error
      (setq claude-agent-usage-string
            (propertize " [C:CFG]"
                        'face '(:foreground "orange")
                        'help-echo "Configure claude-agent-usage-org-id and set CLAUDE_SESSION_KEY env var"))
      (force-mode-line-update t))))

(defun claude-agent-usage-fetch-if-working-hours ()
  "Fetch usage data only during working hours."
  (when (claude-agent-usage-working-hours-p)
    (claude-agent-usage-fetch)))

(defun claude-agent-usage-callback (status)
  "Process usage response and update mode-line. STATUS contains error info."
  (let ((error-msg nil))
    ;; Check for connection/HTTP errors
    (when (plist-get status :error)
      (setq error-msg (format "Connection error: %s" (plist-get status :error))))
    ;; Parse response
    (unless error-msg
      (goto-char (point-min))
      (when (re-search-forward "^$" nil t)
        (condition-case err
            (let* ((json (json-parse-buffer :object-type 'alist))
                   (api-error (alist-get 'error json))
                   (api-detail (alist-get 'detail json)))
              (cond
               ;; API returned error
               ((or api-error api-detail)
                (setq error-msg (or api-error api-detail "API error")))
               ;; Success - parse usage data
               (t
                (let* ((five-hr-data (alist-get 'five_hour json))
                       (seven-day-data (alist-get 'seven_day json))
                       (sonnet-data (alist-get 'seven_day_sonnet json))
                       (five-hr (alist-get 'utilization five-hr-data))
                       (seven-day (alist-get 'utilization seven-day-data))
                       (sonnet (alist-get 'utilization sonnet-data))
                       (five-reset (alist-get 'resets_at five-hr-data))
                       (seven-reset (alist-get 'resets_at seven-day-data))
                       (sonnet-reset (alist-get 'resets_at sonnet-data))
                       (display (format " [C:%d|%d|%d]"
                                        (truncate (or five-hr 0))
                                        (truncate (or seven-day 0))
                                        (truncate (or sonnet 0))))
                       (tooltip (format "Claude Usage\n\n5-hour:       %3d%% (resets in %s)\n7-day:        %3d%% (resets in %s)\n7-day Sonnet: %3d%% (resets in %s)\n\nClick to refresh"
                                        (truncate (or five-hr 0))
                                        (claude-agent-usage-format-reset-time five-reset)
                                        (truncate (or seven-day 0))
                                        (claude-agent-usage-format-reset-time seven-reset)
                                        (truncate (or sonnet 0))
                                        (claude-agent-usage-format-reset-time sonnet-reset))))
                  (setq claude-agent-usage-data json)
                  (setq claude-agent-usage-string
                        (propertize display
                                    'help-echo tooltip
                                    'mouse-face 'mode-line-highlight
                                    'local-map (let ((map (make-sparse-keymap)))
                                                 (define-key map [mode-line mouse-1] #'claude-agent-usage-fetch)
                                                 map)))))))
          (error (setq error-msg (format "Parse error: %s" (error-message-string err)))))))
    ;; Handle errors
    (when error-msg
      (setq claude-agent-usage-string
            (propertize " [C:ERR]"
                        'face '(:foreground "red")
                        'help-echo (format "Claude usage error:\n%s\n\nClick to retry" error-msg)
                        'mouse-face 'mode-line-highlight
                        'local-map (let ((map (make-sparse-keymap)))
                                     (define-key map [mode-line mouse-1] #'claude-agent-usage-fetch)
                                     map))))
    (force-mode-line-update t))
  (kill-buffer))
#+END_SRC

** Mode-Line Control

#+BEGIN_SRC elisp
(defun claude-agent-usage-mode-line-start ()
  "Start Claude usage mode-line display with 5-min refresh."
  (interactive)
  (claude-agent-usage-mode-line-stop)
  (claude-agent-usage-fetch)  ; Always fetch on start
  (setq claude-agent-usage-timer
        (run-at-time 300 300 #'claude-agent-usage-fetch-if-working-hours))
  (unless (member '(:eval claude-agent-usage-string) mode-line-misc-info)
    (push '(:eval claude-agent-usage-string) mode-line-misc-info))
  (message "Claude usage mode-line started"))

(defun claude-agent-usage-mode-line-stop ()
  "Stop Claude usage mode-line display."
  (interactive)
  (when claude-agent-usage-timer
    (cancel-timer claude-agent-usage-timer)
    (setq claude-agent-usage-timer nil))
  (setq claude-agent-usage-string "")
  (setq mode-line-misc-info
        (delete '(:eval claude-agent-usage-string) mode-line-misc-info))
  (force-mode-line-update t)
  (message "Claude usage mode-line stopped"))
#+END_SRC

* Verbose Output

This section provides per-session verbose output buffers that display
CLI-like output for all queries within a session.

** Verbose Buffer Storage

#+BEGIN_SRC elisp
(defvar claude-agent--session-verbose-buffers (make-hash-table :test 'equal)
  "Map session-key to verbose output buffer.")

(defcustom claude-agent-verbose-buffer-auto-kill nil
  "If non-nil, kill verbose buffer when session is cleared."
  :type 'boolean
  :group 'claude-agent)
#+END_SRC

** Verbose Mode

#+BEGIN_SRC elisp
(define-derived-mode claude-agent-verbose-mode special-mode "Claude-Verbose"
  "Major mode for viewing Claude session verbose output."
  (setq buffer-read-only t)
  (setq truncate-lines nil)
  (visual-line-mode 1))
#+END_SRC

** Verbose Buffer Management

#+BEGIN_SRC elisp
(defun claude-agent--get-session-verbose-buffer (session-key)
  "Get or create verbose buffer for SESSION-KEY."
  (or (let ((buf (gethash session-key claude-agent--session-verbose-buffers)))
        (and buf (buffer-live-p buf) buf))
      (let ((buf (generate-new-buffer
                  (format "*Claude Session[%s]*"
                          (if (string-match "::\\(.+\\)$" session-key)
                              (match-string 1 session-key)
                            (file-name-nondirectory session-key))))))
        (with-current-buffer buf
          (claude-agent-verbose-mode)
          (let ((inhibit-read-only t))
            (insert (format " Claude Session \n"))
            (insert (format "Session: %s\n" session-key))
            (insert (format "Started: %s\n\n" (format-time-string "%Y-%m-%d %H:%M:%S")))))
        (puthash session-key buf claude-agent--session-verbose-buffers)
        buf)))

(defun claude-agent--verbose-insert-query-header (session-key prompt &optional cli-path args cwd)
  "Insert query header in verbose buffer for SESSION-KEY with PROMPT.
CLI-PATH is the path to claude CLI, ARGS are command line arguments, CWD is working directory."
  (when-let ((buf (gethash session-key claude-agent--session-verbose-buffers)))
    (when (buffer-live-p buf)
      (with-current-buffer buf
        (let ((inhibit-read-only t))
          (goto-char (point-max))
          (insert "\n")
          (insert "\n")
          (insert (format " Query [%s]\n" (format-time-string "%H:%M:%S")))
          ;; Show CLI command if provided
          (when (and cli-path args)
            (insert "\n")
            (insert (propertize "Command:\n" 'face 'font-lock-keyword-face))
            (insert (format "  %s \\\n" cli-path))
            (let ((arg-pairs nil)
                  (i 0))
              ;; Group args into option-value pairs for better display
              (while (< i (length args))
                (let ((arg (nth i args)))
                  (if (string-prefix-p "-" arg)
                      (if (and (< (1+ i) (length args))
                               (not (string-prefix-p "-" (nth (1+ i) args))))
                          (progn
                            (push (cons arg (nth (1+ i) args)) arg-pairs)
                            (setq i (+ i 2)))
                        (push (cons arg nil) arg-pairs)
                        (setq i (1+ i)))
                    (push (cons arg nil) arg-pairs)
                    (setq i (1+ i)))))
              (dolist (pair (nreverse arg-pairs))
                (let ((opt (car pair))
                      (val (cdr pair)))
                  (if val
                      ;; Truncate very long values (like system prompts)
                      (let ((display-val (if (> (length val) 100)
                                             (concat (substring val 0 100) "...")
                                           val)))
                        (insert (format "    %s %s \\\n"
                                        (propertize opt 'face 'font-lock-constant-face)
                                        display-val)))
                    (insert (format "    %s \\\n"
                                    (propertize opt 'face 'font-lock-constant-face))))))))
          ;; Show working directory
          (when cwd
            (insert (format "\n%s %s\n"
                            (propertize "Working directory:" 'face 'font-lock-keyword-face)
                            cwd)))
          (insert "\n")
          (insert (propertize "Prompt:\n" 'face 'font-lock-keyword-face))
          (insert prompt)
          (insert "\n\n"))))))
#+END_SRC

** Message Formatter

#+BEGIN_SRC elisp
(defun claude-agent--verbose-format-tool-input (input)
  "Format tool INPUT for display, handling different types."
  (cond
   ((null input) "")
   ((stringp input) input)
   ((listp input)
    ;; Convert plist or alist to readable format
    (let ((json-str (condition-case nil
                        (json-encode input)
                      (error (format "%S" input)))))
      json-str))
   (t (format "%S" input))))

(defun claude-agent--verbose-format-content-block (block)
  "Format a single content BLOCK for verbose display."
  (cond
   ;; Tool use block - show full tool call with input
   ((claude-agent-tool-use-block-p block)
    (let* ((name (claude-agent-tool-use-block-name block))
           (input (claude-agent-tool-use-block-input block))
           (input-str (claude-agent--verbose-format-tool-input input)))
      (concat
       (format "\n%s %s\n"
               (propertize " Tool:" 'face 'font-lock-keyword-face)
               (propertize name 'face 'font-lock-function-name-face))
       (when (and input-str (not (string-empty-p input-str)))
         (format "%s\n%s\n"
                 (propertize "  Input:" 'face 'font-lock-comment-face)
                 input-str)))))

   ;; Tool result block - show content
   ((claude-agent-tool-result-block-p block)
    (let* ((is-error (claude-agent-tool-result-block-is-error block))
           (content (claude-agent-tool-result-block-content block))
           (content-str (if (stringp content)
                            content
                          (claude-agent--verbose-format-tool-input content))))
      (concat
       (format "%s %s\n"
               (propertize " Result:" 'face 'font-lock-keyword-face)
               (if is-error
                   (propertize "ERROR" 'face 'error)
                 (propertize "OK" 'face 'success)))
       (when (and content-str (not (string-empty-p content-str)))
         (format "%s\n" content-str)))))

   ;; Thinking block - show actual thinking content
   ((claude-agent-thinking-block-p block)
    (let ((thinking (claude-agent-thinking-block-thinking block)))
      (concat
       (format "\n%s\n" (propertize " Thinking:" 'face 'font-lock-comment-face))
       (when (and thinking (not (string-empty-p thinking)))
         (format "%s\n" (propertize thinking 'face 'font-lock-doc-face))))))

   ;; Text block
   ((claude-agent-text-block-p block)
    (claude-agent-text-block-text block))

   (t nil)))

(defun claude-agent--verbose-format-message (msg)
  "Format MSG for verbose buffer display."
  (cond
   ;; Assistant message - iterate through content blocks
   ((claude-agent-assistant-message-p msg)
    (let ((content (claude-agent-assistant-message-content msg))
          (parts nil))
      (claude-agent--debug-log "Assistant content blocks: %d items" (length content))
      (dolist (block content)
        (claude-agent--debug-log "  Block type: %s"
                                 (cond
                                  ((claude-agent-tool-use-block-p block) "tool_use")
                                  ((claude-agent-thinking-block-p block) "thinking")
                                  ((claude-agent-text-block-p block) "text")
                                  ((claude-agent-tool-result-block-p block) "tool_result")
                                  (t (format "unknown: %S" (type-of block)))))
        (when-let ((formatted (claude-agent--verbose-format-content-block block)))
          (push formatted parts)))
      (when parts
        (mapconcat #'identity (nreverse parts) ""))))

   ;; User message - show tool results if any
   ((claude-agent-user-message-p msg)
    (let ((content (claude-agent-user-message-content msg)))
      (cond
       ;; Content is a list of blocks (tool results)
       ((and (listp content) (listp (car content)))
        (let ((parts nil))
          (dolist (block content)
            (when-let ((formatted (claude-agent--verbose-format-content-block
                                   (claude-agent--parse-content-block block))))
              (push formatted parts)))
          (when parts
            (mapconcat #'identity (nreverse parts) ""))))
       ;; Content is just a string
       ((stringp content)
        nil)  ; Don't show user input (already shown in header)
       (t nil))))

   ;; System message
   ((claude-agent-system-message-p msg)
    (let* ((subtype (claude-agent-system-message-subtype msg))
           (data (claude-agent-system-message-data msg))
           (message-text (plist-get data :message)))
      (cond
       ;; Show error messages with message text
       ((string= subtype "error")
        (format " Error: %s\n" (or message-text subtype)))
       ;; Show init messages
       ((string= subtype "init")
        (format " %s\n" (or message-text "Initializing...")))
       ;; Show any message that has text (like "Compacting conversation...")
       (message-text
        (format " %s\n" message-text))
       ;; For other subtypes, just show the subtype
       (subtype
        (format " %s\n" subtype))
       (t nil))))

   ;; Result message
   ((claude-agent-result-message-p msg)
    (format "\n%s\n"
            (propertize
             (format " Complete: %.1fs | $%.4f "
                     (/ (or (claude-agent-result-message-duration-ms msg) 0) 1000.0)
                     (or (claude-agent-result-message-total-cost-usd msg) 0))
             'face 'font-lock-comment-face)))

   (t nil)))

(defun claude-agent--verbose-write-message (session-key msg)
  "Write MSG to verbose buffer for SESSION-KEY."
  (claude-agent--debug-log "Verbose write: session=%s msg-type=%s"
                           session-key
                           (cond
                            ((claude-agent-assistant-message-p msg) "assistant")
                            ((claude-agent-user-message-p msg) "user")
                            ((claude-agent-system-message-p msg) "system")
                            ((claude-agent-result-message-p msg) "result")
                            (t "unknown")))
  (when session-key
    (when-let* ((buf (gethash session-key claude-agent--session-verbose-buffers))
                (formatted (claude-agent--verbose-format-message msg)))
      (when (and buf (buffer-live-p buf) (not (string-empty-p formatted)))
        (with-current-buffer buf
          (let ((inhibit-read-only t))
            (goto-char (point-max))
            (insert formatted)))))))
#+END_SRC

** View Commands

#+BEGIN_SRC elisp
(defun claude-agent-show-session-verbose (session-key)
  "Show verbose buffer for SESSION-KEY."
  (interactive
   (list (completing-read "Session: "
           (let (keys)
             (maphash (lambda (k buf)
                        (when (buffer-live-p buf)
                          (push k keys)))
                      claude-agent--session-verbose-buffers)
             keys))))
  (when-let ((buf (gethash session-key claude-agent--session-verbose-buffers)))
    (when (buffer-live-p buf)
      (display-buffer buf))))

(defun claude-agent-list-session-verbose-buffers ()
  "List all session verbose buffers."
  (interactive)
  (let ((bufs nil))
    (maphash (lambda (key buf)
               (when (buffer-live-p buf)
                 (push (cons key buf) bufs)))
             claude-agent--session-verbose-buffers)
    (if bufs
        (let ((selected (completing-read "Session buffer: "
                          (mapcar #'car bufs))))
          (when-let ((buf (cdr (assoc selected bufs))))
            (switch-to-buffer buf)))
      (message "No session verbose buffers"))))
#+END_SRC

* Interactive Chat Mode

This section provides an interactive chat interface based on comint-mode,
allowing users to interact with Claude in a REPL-like environment.

** Chat Mode Variables

#+BEGIN_SRC elisp
(defgroup claude-agent-chat nil
  "Interactive chat interface for Claude Agent."
  :group 'claude-agent
  :prefix "claude-agent-chat-")

(defcustom claude-agent-chat-prompt "You> "
  "Prompt string for user input in chat mode."
  :type 'string
  :group 'claude-agent-chat)

(defcustom claude-agent-chat-buffer-name "*Claude Chat*"
  "Name of the Claude chat buffer."
  :type 'string
  :group 'claude-agent-chat)

(defcustom claude-agent-chat-show-system-messages nil
  "Whether to display system messages in the chat buffer."
  :type 'boolean
  :group 'claude-agent-chat)

(defcustom claude-agent-chat-show-cost t
  "Whether to display cost information after each response."
  :type 'boolean
  :group 'claude-agent-chat)

(defcustom claude-agent-chat-include-ide-context t
  "Whether to include IDE context (current file, open files, selection) in prompts.
When non-nil, a <system-reminder> tag with context is prepended to each message."
  :type 'boolean
  :group 'claude-agent-chat)

(defvar-local claude-agent-chat--session-id nil
  "Current session ID for conversation continuity.")

(defvar-local claude-agent-chat--waiting nil
  "Non-nil when waiting for Claude's response.")

(defvar-local claude-agent-chat--current-response ""
  "Accumulator for the current streaming response.")

(defvar-local claude-agent-chat--response-start-marker nil
  "Marker for the start of the current response.")

(defvar-local claude-agent-chat--total-cost 0.0
  "Total cost accumulated in this chat session.")
#+END_SRC

** Chat Mode Faces

#+BEGIN_SRC elisp
(defface claude-agent-chat-prompt-face
  '((t :inherit comint-highlight-prompt))
  "Face for the user prompt in Claude chat."
  :group 'claude-agent-chat)

(defface claude-agent-chat-response-face
  '((t :inherit default))
  "Face for Claude's responses."
  :group 'claude-agent-chat)

(defface claude-agent-chat-thinking-face
  '((t :inherit font-lock-comment-face :slant italic))
  "Face for thinking indicators."
  :group 'claude-agent-chat)

(defface claude-agent-chat-tool-face
  '((t :inherit font-lock-function-name-face))
  "Face for tool use indicators."
  :group 'claude-agent-chat)

(defface claude-agent-chat-error-face
  '((t :inherit error))
  "Face for error messages."
  :group 'claude-agent-chat)

(defface claude-agent-chat-info-face
  '((t :inherit font-lock-comment-face))
  "Face for informational messages like cost."
  :group 'claude-agent-chat)
#+END_SRC

** Chat Mode Functions

#+BEGIN_SRC elisp
(defun claude-agent-chat--insert (text &optional face)
  "Insert TEXT at the end of the chat buffer with optional FACE."
  (let ((inhibit-read-only t))
    (save-excursion
      (goto-char (point-max))
      (let ((start (point)))
        (insert text)
        (when face
          (add-text-properties start (point) (list 'face face)))))))

(defun claude-agent-chat--insert-response-start ()
  "Insert the response header and set up markers."
  (let ((inhibit-read-only t))
    (save-excursion
      (goto-char (point-max))
      (insert "\nClaude> ")
      (add-text-properties (- (point) 8) (point)
                           '(face claude-agent-chat-response-face
                             font-lock-face claude-agent-chat-response-face))
      (setq claude-agent-chat--response-start-marker (point-marker)))))

(defun claude-agent-chat--update-response (text)
  "Update the current response with TEXT (streaming update)."
  (let ((inhibit-read-only t))
    (save-excursion
      (goto-char claude-agent-chat--response-start-marker)
      (delete-region (point) (point-max))
      (insert text))))

(defun claude-agent-chat--handle-message (msg)
  "Handle incoming MSG from Claude."
  (with-current-buffer claude-agent-chat-buffer-name
    (let ((type (claude-agent-message-type msg)))
      (pcase type
        ('system
         (when claude-agent-chat-show-system-messages
           (let ((subtype (claude-agent-system-message-subtype msg)))
             (claude-agent-chat--insert
              (format "\n[System: %s]\n" subtype)
              'claude-agent-chat-info-face))))

        ('assistant
         (let ((text (claude-agent-extract-text msg)))
           (when text
             (setq claude-agent-chat--current-response text)
             (claude-agent-chat--update-response text)))
         ;; Check for tool use
         (let ((content (claude-agent-assistant-message-content msg)))
           (dolist (block content)
             (when (claude-agent-tool-use-block-p block)
               (claude-agent-chat--insert
                (format "\n[Tool: %s]\n"
                        (claude-agent-tool-use-block-name block))
                'claude-agent-chat-tool-face)))))

        ('result
         (setq claude-agent-chat--session-id
               (claude-agent-result-message-session-id msg))
         (let ((cost (claude-agent-result-message-total-cost-usd msg)))
           (when cost
             (setq claude-agent-chat--total-cost
                   (+ claude-agent-chat--total-cost cost))
             (when claude-agent-chat-show-cost
               (claude-agent-chat--insert
                (format "\n[Cost: $%.4f | Session total: $%.4f]\n"
                        cost claude-agent-chat--total-cost)
                'claude-agent-chat-info-face)))))))))

(defun claude-agent-chat--handle-error (err)
  "Handle error ERR from Claude."
  (with-current-buffer claude-agent-chat-buffer-name
    (claude-agent-chat--insert
     (format "\n[Error: %s]\n" err)
     'claude-agent-chat-error-face)
    (setq claude-agent-chat--waiting nil)
    (claude-agent-chat--show-prompt)))

(defun claude-agent-chat--handle-complete (_result)
  "Handle completion of Claude's response."
  (with-current-buffer claude-agent-chat-buffer-name
    (setq claude-agent-chat--waiting nil)
    (setq claude-agent-chat--current-response "")
    (claude-agent-chat--insert "\n")
    (claude-agent-chat--show-prompt)))

(defun claude-agent-chat--show-prompt ()
  "Show the input prompt using comint."
  (let ((inhibit-read-only t)
        (proc (get-buffer-process (current-buffer))))
    (goto-char (point-max))
    (let ((start (point)))
      (insert claude-agent-chat-prompt)
      (add-text-properties start (point)
                           '(face claude-agent-chat-prompt-face
                             font-lock-face claude-agent-chat-prompt-face
                             front-sticky (face font-lock-face read-only)
                             rear-nonsticky t
                             read-only t)))
    (when proc
      (set-marker (process-mark proc) (point)))))

(defun claude-agent-chat--send-input (input)
  "Send INPUT to Claude."
  (when (and input (not (string-empty-p (string-trim input))))
    (if claude-agent-chat--waiting
        (message "Still waiting for Claude's response...")
      (setq claude-agent-chat--waiting t)
      (setq claude-agent-chat--current-response "")
      (claude-agent-chat--insert-response-start)
      (claude-agent-chat--insert "[Waiting...]" 'claude-agent-chat-thinking-face)
      ;; Build options with session continuation if we have a session
      (let* ((opts (if claude-agent-chat--session-id
                       (claude-agent-options
                        :continue-conversation t
                        :resume claude-agent-chat--session-id)
                     (claude-agent-options)))
             ;; Prepend system reminder with IDE context if enabled
             (system-reminder (when claude-agent-chat-include-ide-context
                                (claude-agent-get-system-reminder)))
             (actual-prompt (if (and system-reminder
                                     (not (string-empty-p system-reminder)))
                                (concat system-reminder "\n" input)
                              input)))
        (claude-agent-query
         actual-prompt
         :options opts
         :on-message #'claude-agent-chat--handle-message
         :on-error #'claude-agent-chat--handle-error
         :on-complete #'claude-agent-chat--handle-complete)))))

(defun claude-agent-chat-interrupt ()
  "Interrupt the current Claude request."
  (interactive)
  (claude-agent-cleanup)
  (with-current-buffer claude-agent-chat-buffer-name
    (setq claude-agent-chat--waiting nil)
    (claude-agent-chat--insert "\n[Interrupted]\n" 'claude-agent-chat-error-face)
    (claude-agent-chat--show-prompt)))

(defun claude-agent-chat-clear ()
  "Clear the chat buffer and reset the session."
  (interactive)
  (when (yes-or-no-p "Clear chat history and start new session? ")
    (let ((inhibit-read-only t))
      (erase-buffer)
      (setq claude-agent-chat--session-id nil)
      (setq claude-agent-chat--total-cost 0.0)
      (setq claude-agent-chat--waiting nil)
      (claude-agent-chat--initialize-buffer))))

(defun claude-agent-chat-new-session ()
  "Start a new conversation session without clearing history."
  (interactive)
  (setq claude-agent-chat--session-id nil)
  (claude-agent-chat--insert "\n--- New Session ---\n" 'claude-agent-chat-info-face)
  (message "Started new session"))
#+END_SRC

** Chat Mode Definition

#+BEGIN_SRC elisp
(require 'comint)

(defvar claude-agent-chat-mode-map
  (let ((map (nconc (make-sparse-keymap) comint-mode-map)))
    (define-key map (kbd "C-c C-k") #'claude-agent-chat-interrupt)
    (define-key map (kbd "C-c C-l") #'claude-agent-chat-clear)
    (define-key map (kbd "C-c C-n") #'claude-agent-chat-new-session)
    map)
  "Keymap for `claude-agent-chat-mode'.")

(defun claude-agent-chat--input-sender (_proc input)
  "Send INPUT to Claude (comint input sender).
_PROC is ignored since we don't use a real process."
  (claude-agent-chat--send-input input))

(define-derived-mode claude-agent-chat-mode comint-mode "Claude-Chat"
  "Major mode for interactive chat with Claude.
Based on comint-mode for proper input handling.

\\{claude-agent-chat-mode-map}"
  :group 'claude-agent-chat
  ;; Set up local variables
  (setq-local claude-agent-chat--session-id nil)
  (setq-local claude-agent-chat--waiting nil)
  (setq-local claude-agent-chat--current-response "")
  (setq-local claude-agent-chat--total-cost 0.0)
  (setq-local claude-agent-chat--response-start-marker nil)
  ;; Comint configuration
  (setq-local comint-prompt-regexp (concat "^" (regexp-quote claude-agent-chat-prompt)))
  (setq-local comint-input-sender #'claude-agent-chat--input-sender)
  (setq-local comint-process-echoes nil)
  ;; We don't have a real process, so we need a dummy
  ;; The input sender handles everything
  )

(defun claude-agent-chat--initialize-buffer ()
  "Initialize the chat buffer with header and prompt."
  (let ((inhibit-read-only t))
    (insert "Claude Agent Chat\n")
    (insert "================\n")
    (insert (format "CLI: %s\n" (claude-agent--find-cli)))
    (insert "Type your message and press RET to send.\n")
    (insert "Commands: C-c C-k (interrupt), C-c C-l (clear), C-c C-n (new session)\n\n")
    ;; Set the prompt using comint's mechanism
    (setq-local comint-prompt-read-only t)
    (insert claude-agent-chat-prompt)
    (set-marker (process-mark (get-buffer-process (current-buffer))) (point))))
#+END_SRC

** Main Entry Point

#+BEGIN_SRC elisp
;;;###autoload
(defun claude-agent-chat ()
  "Start or switch to the Claude chat buffer."
  (interactive)
  ;; Check for CLI first
  (unless (claude-agent--find-cli)
    (user-error "Claude CLI not found. Set `claude-agent-cli-path' or install Claude Code CLI"))
  (let ((buf (get-buffer-create claude-agent-chat-buffer-name)))
    (with-current-buffer buf
      (unless (eq major-mode 'claude-agent-chat-mode)
        (claude-agent-chat-mode)
        ;; Start a fake process for comint to work with
        ;; We use 'cat' as a simple no-op process
        (let ((proc (start-process "claude-chat" buf "cat")))
          (set-process-query-on-exit-flag proc nil)
          (set-process-filter proc #'claude-agent-chat--comint-filter))
        (claude-agent-chat--initialize-buffer)))
    (pop-to-buffer buf)
    (goto-char (point-max))))

(defun claude-agent-chat--comint-filter (_proc _output)
  "Filter for the dummy comint process.
Ignores all output from the dummy process."
  ;; Do nothing - we handle output ourselves
  nil)
#+END_SRC

* Package Footer

#+BEGIN_SRC elisp
(provide 'claude-agent)
;;; claude-agent.el ends here
#+END_SRC

* Release

This section contains the tangle configuration for generating the
standalone ~claude-agent.el~ file.

#+BEGIN_SRC elisp :load no
;; To tangle this file to claude-agent.el, evaluate:
(require 'literate-elisp)
(literate-elisp-tangle
 "claude-agent.org"
 :header ";;; claude-agent.el --- Emacs client for Claude Code CLI -*- lexical-binding: t; -*-

;; Copyright (C) 2024 Jingtao Xu

;; Author: Jingtao Xu
;; Version: 0.1.0
;; Package-Requires: ((emacs \"27.1\"))
;; Keywords: tools, processes, ai
;; URL: https://github.com/user/claude-agent

;; This file is not part of GNU Emacs.

;; This file is auto-generated from claude-agent.org
;; DO NOT EDIT DIRECTLY - edit claude-agent.org instead.

;;; Commentary:

;; Claude Agent SDK for Emacs - A client library for the Claude Code CLI.
;; This package provides async subprocess communication with Claude,
;; streaming responses, and hook support.
;;
;; Usage:
;;   (claude-agent-query \"What is 2+2?\"
;;     :on-message (lambda (msg) (message \"%s\" msg)))

;;; Code:

"
 :tail "
(provide 'claude-agent)
;;; claude-agent.el ends here
")
#+END_SRC
